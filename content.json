{"meta":{"title":"Qussk","subtitle":"","description":"","author":"Qussk님","url":"https://Qussk.github.io","root":"/"},"pages":[],"posts":[{"title":"categories","slug":"categories","date":"2020-10-14T03:07:23.000Z","updated":"2020-10-14T03:10:22.523Z","comments":true,"path":"2020/10/14/categories/","link":"","permalink":"https://qussk.github.io/2020/10/14/categories/","excerpt":"","text":"카테고리전체보기iOSPostPost기타","categories":[],"tags":[]},{"title":"REST API - Codable","slug":"POST/REST-API-Codable","date":"2020-10-12T16:48:25.000Z","updated":"2020-10-12T11:21:23.585Z","comments":false,"path":"2020/10/13/POST/REST-API-Codable/","link":"2020/10/12/POST/REST-API-Codable","permalink":"https://qussk.github.io/2020/10/13/POST/REST-API-Codable/","excerpt":"","text":"REST API활용해서 서버 따와야하는데 , 알라모파이어 쓰랴, 코더블 쓰랴 그러면서 안되는 게 있으면 검색해보고 … (블로그는 뭐든 된다고만 하고… 되는 것만 올리니까 ;;) 이해 안되는 부분이 있었는데, 어쨋든 되니까 넘어가고;; 그런 과정이 있어서 정리했다. --; 나를 가장 혼란스럽게 했던… JSONSerialization…. 자꾸 되어야하는 게 안되서… 여러 방면으로 생각하다보니 jsonObject화 하지 않아서 안되는 건가 ?? 의문 스러워하며 이것고치고 저것고치고… 그런데 그 전엔 없어도 잘만 됐는데… 이상함… (반복) 그리고 학원에서도 분명 JSONSerialization을 배우긴 했다. 근데 왜 사용하는 지도 모르고 그냥 달달… 외우고 코드보면서 썼던 것… 🤔결국 이제야 알게된 것은, JSONSerialization은 swift3에서 지원했던 내용이고 5부터는 그냥 Codable하나면 오케이…😨👌 나를 혼란스럽게 한 swift 3방식을 보자. 이전 Swift 3 방식 JSON Data 123456789//\"https://api.letsbuildthatapp.com/jsondecodable/course\"&#123; id = 1; imageUrl = \"https://letsbuildthatapp-videos.s3-us-west-2.amazonaws.com/04782e30-d72a-4917-9d7a-c862226e0a93\"; link = \"https://www.letsbuildthatapp.com/course/instagram-firebase\"; name = \"Instagram Firebase\"; \"number_of_lessons\" = 49;&#125; 이런 json형식의 데이터가 있다고 가정한다. Data Model 1234567891011121314151617struct Course &#123; let id: Int let name: String let link: String let imageUrl: String init(json: [String: Any]) &#123; id = json[\"id\"] as? Int ?? -1 name = json[\"name\"] as? String ?? \"\" link = json[\"link\"] as? String ?? \"\" imageUrl = json[\"imageUrl\"] as? String ?? \"\" &#125;&#125;//자동완성됨//let myCourse = Course(id: &lt;#T##Int#&gt;, name: &lt;#T##String#&gt;, link: &lt;#T##String#&gt;, imageUrl: &lt;#T##String#&gt;)//print(myCourse) swift3에서는 반드시 init함수로 JSON데이터를 객체화 해야했다. 데이터를 사용하고 싶다면 데이터를 인스턴스화해서 사용하라!. 그리고 그것은 보통 딕셔너리타입일 것… 아래 파싱하는 부분을 보자. Parsing 123456789101112131415161718192021222324252627282930func parsingFuntion() &#123; let jsonUrlString = \"https://api.letsbuildthatapp.com/jsondecodable/course\" //http://....\" 문자열을 변환해서 url구조체로 만든 다음 -&gt; url세션으로 처리한다. guard let url = URL(string: jsonUrlString) else &#123; return &#125; //보통은 에러처리먼저 //1. URLSession.shared.dataTask(with: url) &#123; (data, response, error) in print(\"데이터 다운로드 완료\") guard let data = data else &#123; return &#125; // let dataAsString = String(data: data, encoding: .utf8) // print(dataAsString) do &#123; //2. guard let json = try JSONSerialization.jsonObject(with: data, options: .mutableContainers) as? [String: Any] else &#123; return &#125;//제이슨을 딕셔너리로 let course = Course(json: json) print(course) &#125; catch let jsonErr &#123; print(\"Error serializing json:\", jsonErr) &#125; &#125;.resume()&#125;parsingFuntion() //호출 urlSting문자열을 변환해서 url구조체로 만든 다음 URLSession을 통해 shared.dataTask하고, 이후 data, response, error 를 정의하여 처리하는 과정은 현재와 동일한 방식이지만, 아래 try이후 JSONSerialization.jsonObject 부분이 다른 걸 볼 수 있다. 순서로 코드를 보자면, 파싱을 통해서 json객체가 나오고 -&gt; 2.딕셔너리로 타입캐스팅을 한번 하고 -&gt; 3.그것을 토대로 객체(인스턴스)생성.(위에 init. 구조체이거나 클래스이거나) 그리고 그 4. 제이슨을 딕셔너리로 … 이점을 참고하여 , 아래의 글 swift 5부터 Codable등장 이후 변경된 점을 보자. Swift 5 이상 JSON Data 123456789//\"https://api.letsbuildthatapp.com/jsondecodable/course\"&#123; id = 1; imageUrl = \"https://letsbuildthatapp-videos.s3-us-west-2.amazonaws.com/04782e30-d72a-4917-9d7a-c862226e0a93\"; link = \"https://www.letsbuildthatapp.com/course/instagram-firebase\"; name = \"Instagram Firebase\"; \"number_of_lessons\" = 49;&#125; 이러한 JOSN 형식의 데이터가 있다고 가정. (위와 동일) DataModel 12345678//구조체라서 컴파일러가 알아서 init을 만들어줬기때문에 생략가능. (멤버와이징이니셜라이저)struct Course: Decodable &#123; let id: Int let name: String let link: String let imageUrl: String&#125; Codable(decode, encode둘다 사용), Decodable(데이터 가져올때), encodable(데이터 넣을 때) class인 경우 init함수를 써야하지만 swift3처럼 딕셔너리화할 필요는 없다. 그냥 쓰면 됨!! parsing 12345678910111213141516171819202122232425func parsingFuntion() &#123; let jsonUrlString = \"https://api.letsbuildthatapp.com/jsondecodable/course\" guard let url = URL(string: jsonUrlString) else &#123; return &#125; URLSession.shared.dataTask(with: url) &#123; (data, response, error) in print(\"데이터 다운로드 완료\") guard let data = data else &#123; return &#125; do &#123; //요부분.. let course = try JSONDecoder().decode(Course.self, from: data) print(course.name) &#125; catch let jsonErr &#123; print(\"Error serializing json:\", jsonErr) &#125; &#125;.resume()&#125;parsingFuntion() urlString을 URLSession을통해 변환하여 처리하는 것 동일. do 부터 swift3와 다르게, 제이슨 객체로 주는 것이 아니라, 1.제이슨 디코더로 만듦. -&gt; 4.딕셔너리로 변환함.(끝…) swift3에서 나열했던 2~3단계를 줄임. 1과 4만 존재… 파싱은 -&gt; 바로 인스턴스 객체로 감(init)을 의미하게 됨. [배열인 경우] JSON Data 1234567891011121314151617181920212223242526272829303132//\"https://api.letsbuildthatapp.com/jsondecodable/courses\"[&#123;\"id\":6, \"name\":\"AppStore JSON APIs\", \"link\":\"https://www.letsbuildthatapp.com/course/AppStore-JSON-APIs\", \"imageUrl\":\"https://letsbuildthatapp-videos.s3-us-west-2.amazonaws.com/fd78be85-b845-4672-a316-7df0abe80812_medium\", \"number_of_lessons\":47&#125;, &#123;\"id\":5, \"name\":\"Tinder Firestore Swipe and Match\", \"link\":\"https://www.letsbuildthatapp.com/course/Tinder-Firestore-Swipe-and-Match\", \"imageUrl\":\"https://letsbuildthatapp-videos.s3-us-west-2.amazonaws.com/bc5a4091-d2ea-44ab-b749-5f2ee5354c35_medium\", \"number_of_lessons\":47&#125;, &#123;\"id\":1, \"name\":\"Instagram Firebase\", \"link\":\"https://www.letsbuildthatapp.com/course/instagram-firebase\", \"imageUrl\":\"https://letsbuildthatapp-videos.s3-us-west-2.amazonaws.com/04782e30-d72a-4917-9d7a-c862226e0a93\",\"number_of_lessons\":49&#125;, &#123;\"id\":2, \"name\":\"Podcasts Course\", \"link\":\"https://www.letsbuildthatapp.com/course/podcasts\", \"imageUrl\":\"https://letsbuildthatapp-videos.s3-us-west-2.amazonaws.com/32f98d9d-5b9b-4a22-a012-6b87fd7158c2_medium\", \"number_of_lessons\":39&#125;, &#123;\"id\":3, \"name\":\"Intermediate Training Core Data\", \"link\":\"https://www.letsbuildthatapp.com/course/intermediate-training-core-data\", \"imageUrl\":\"https://letsbuildthatapp-videos.s3-us-west-2.amazonaws.com/0736fecb-5b88-483b-a83d-ca2a5a6d93f9_medium\", \"number_of_lessons\":32&#125;, &#123;\"id\":4, \"name\":\"Kindle Basic Training\", \"link\":\"https://www.letsbuildthatapp.com/basic-training\", \"imageUrl\":\"https://letsbuildthatapp-videos.s3-us-west-2.amazonaws.com/a6180731-c077-46e7-88d5-4900514e06cf_medium\", \"number_of_lessons\":19&#125;] 이런식의 배열의 데이터가 주어진다면… Parsing 1234567891011121314151617181920212223func parsingArrays() &#123; let jsonUrlString = \"https://api.letsbuildthatapp.com/jsondecodable/courses\" guard let url = URL(string: jsonUrlString) else &#123; return &#125; URLSession.shared.dataTask(with: url) &#123; (data, response, error) in print(\"데이터 다운로드 완료\") guard let data = data else &#123; return &#125; do &#123; let courses = try JSONDecoder().decode([Course].self, from: data) //배열의 경우 print(courses) &#125; catch let jsonErr &#123; print(\"Error serializing json:\", jsonErr) &#125; &#125;.resume()&#125;parsingArrays() Course를 [Course]로 감싸주기만 하면 된당… 다른 예시 123456789101112131415161718192021222324252627struct WebsiteDescription: Decodable &#123; let name: String let description: String let courses: [Course]&#125;func parsingDatas() &#123; let jsonUrlString = \"https://api.letsbuildthatapp.com/jsondecodable/website_description\" guard let url = URL(string: jsonUrlString) else &#123; return &#125; URLSession.shared.dataTask(with: url) &#123; (data, response, error) in guard let data = data else &#123; return &#125; do &#123; let websiteDescription = try JSONDecoder().decode(WebsiteDescription.self, from: data) print(websiteDescription) //이것도 그냥 맞춰서 쓰면 됨.. 배열무서워하지 말기!! &#125; catch let jsonErr &#123; print(\"Error serializing json:\", jsonErr) &#125; &#125;.resume()&#125;parsingDatas()","categories":[{"name":"post","slug":"post","permalink":"https://qussk.github.io/categories/post/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"Codable","slug":"Codable","permalink":"https://qussk.github.io/tags/Codable/"},{"name":"Decod","slug":"Decod","permalink":"https://qussk.github.io/tags/Decod/"},{"name":"REST API","slug":"REST-API","permalink":"https://qussk.github.io/tags/REST-API/"}]},{"title":"Error Handling(에러핸들링) - throwing함수, do-catch try, Result","slug":"POST/Swift-throwing-함수","date":"2020-10-10T19:41:57.000Z","updated":"2020-10-12T02:42:54.852Z","comments":false,"path":"2020/10/11/POST/Swift-throwing-함수/","link":"2020/10/10/POST/Swift-throwing-함수","permalink":"https://qussk.github.io/2020/10/11/POST/Swift-throwing-%ED%95%A8%EC%88%98/","excerpt":"","text":"Error Handling이란? 에러의 방향성을 만들어 주는 것이다. 에러시 어떤 것을 리턴을 할 건지… 특정 함수를 실행할건지… 앱을 종료할 것인지 등등… 에러에 대한 대응 및 복구에 대한 작업!!! 그 전에 에러에 대해 먼저 이해하고 넘어가자! 에러의 종류에는 '컴파일 에러’와 '런타임 에러’가 있다. '컴파일 에러’는 대부분 문법과 관련된 내용으로, 컴파일러가 제공해주는 정보를 통해 비교적 쉽게 수정이 가능하다. 예를 들면, 엑스코드가 에러났다고 빨갛게 에러창 보여주는 것! 이와 다르게 런타임 에러는 프로그램이 실행되는 동안 발생한다. 이 이유로 '런타임 에러’가 에러 핸들링(Error Handling)으로 다뤄지는 주요 내용이 된다! 런타임에러는 디바이스나 리소스 상태에 따라 에러가 발생한다. 예를 들면, 잘못된 코드로 인해, 특정 지역에서 앱이 종료되는 것이다.(프로그램이 강제로 종료함) 이렇게 앱이 종료되는 것을 막기위해 해주는 작업이 에러 핸들링!! 에러 핸들링을 하게 되면, 발생가능한 에러를 직접처리해주기 때문에 강제종료 없이 계속 실행이 가능해진다. 발생가능한 에러를 미리 처리해 두면 프로그램을 크래시 없이 계속 사용할 수 있게 되고, 강제 종료 횟수가 줄어듦에 따라 앱의 사용성이 증가된다. 개념 ? Swift에서는 런타임에 에러가 발생한 경우 이를 처리하기 위한 발생(throwig), 감지(catching), 전파(propagating), 조작(manipulating) 을 지원하는 일급 클래스를 제공한다. 어떤 함수, 메소드 혹은 Initializer가 에러를 발생 시킬 수 있다는 것을 알리기 위해 throw 키워드를 함수 선언부의 파라미터 뒤에 붙인다. throw 키워드로 표시된 함수를 throwing function이라고 부르며, 만약 함수가 리턴 값을 명시했다면 throw 키워드는 리턴 값 표시 기호인 -&gt; 전에 적으면 된다. 1func adultAge(text: String) throws -&gt; Int 오직 throwing fuction만이 에러를 발생시킬 수 있으며, 만약 throwing function이 아닌 함수에서 throw가 발생한다면 반드시 그 함수 내에서 throw에 대해 처리되어야 한다. 에러 처리(Handling Errors) 에러를 던지고(?) 싶다면 미리 정의를 해줘야한다. 던진다고 표현한 이유는 throws가 사전적으로 던진다는 의미를 가지고 있기 때문이다. 이후 에러 형식부터 선언한다. 에러 형식은 특별한 형식이 아니고 에러 프로토콜을 채용하면 에러 형식이 된다. 그리고 에러는 대부분 열거형으로 선언한다. throwing함수 에러를 미리 정의한다. (열거형) 모든 에러는 열거형으로 쓴다. 123456enum APIError: Error &#123; case aError case bError case cError&#125;var a: APIError APIError라는 Error타입의 열거형을 만든다. APIError은 타입으로 쓸 수 있다. [ 열거형 ? ] ===&gt; 한정된 케이스안에서 선택가능한 타입 예시 ) &quot;월화수목금토일&quot;은 한정된 그룹이다. 그러므로 열거형으로 선언될 수 있다. 이 외에가 없는 것. 1234567891011enum Weekdays &#123; case monday case tuesday case wednesday case thursday case friday case saturday case sunday&#125;var day: Weekdays = .monday throws / throw 정의할때는 throws -&gt; 에러를 던지겠다! 선언한다. 이후 각각 던질 때는 throw로 던져 구분한다. 1234567891011121314//정의할때는 throws -&gt; 에러를 던지겠다! 선언func parsing() throws -&gt; Int &#123; if false &#123; throw APIError.aError //각각 던질때는 throw (aError에 대한 코드) &#125; if false &#123; throw APIError.bError (bError에 대한 코드) &#125; return 0&#125; 이것을 throwing함수라고 한다. do-catch으로 에러처리 throwing함수를 이해했다면, do-catch으로 에러 처리가 가능하다. do-catch는 do블럭과 catch블럭으로 구성되어 있다. do블럭은 필수 블럭이고, 여기서는 가장 기본식인 try 표현식을 사용해서, 에러가 발생할 수 있는 코드를 실행할 것이다. try표현식에서 에러가 발생하면 do블럭에서 이어지는 코드는 실행되지 않고, 아래쪽에 있는 catch블럭이 실행된다. catch블럭은 do블럭에서 발생한 에러를 처리한다. 패턴으로 선언하고 싶은 에러를 선언하거나, 패턴을 생략하고 전체에러를 처리할 수도 있다. where절을 추가해서, 매칭시킬 에러패턴에 조건을 추가할 수 있다. do 에서 발생가능한 모든 에러는 catch블럭을 통해 모두 처리되어야하고, catch블럭을 생략한 경우에는 에러가 다른 코드로 전파될 수 있도록 구현해야한다. try(가장 일반적인) 1234567891011121314151617181920//경우 1. try (가장 일반적인)do &#123; let a = try parsing() // 그 다음 코드 - 1 // 그 다음 코드 - 2&#125; catch &#123; print(error.localizedDescription)//지역화된. 오류면 해당언어로 콘솔창에 보여줘!.별거아님 //error는 일반적인 타입 let e = error as? APIError switch e &#123; case .aError: print(\"a에러발생\") case .bError: print(\"b에러발생\") default: break &#125; &#125; error는 일반적인 타입이므로 한번 타입캐스팅을 해서 사용한다. 1let e &#x3D; error as? APIError 이 부분… try? 1234567// 경우 2. try?//do catch로 감쌀 필요없음. 나는 에러처리에 관심없어.//왜냐 ? 에러인 경우 nil이 나옴let b = try? parsing() //b의 타입을 보면 옵셔널 인트임 Int? -&gt; 그럼 무슨 말인지 이해가 됨.. try ! 1234//경우3.try!//에러발생시 앱종료. -&gt; 이러한 이유로 try!를 쓰는 경우 거의 없음.let c = try! parsing() // 에러처리 방법 3가지 do-catch문 사용(코드에서 발생한 에러를 개별적으로 처리할때) try표현식 + 옵셔널 바인딩 전달받은 에러를 다른 코드블럭으로 다시 전달(hand over) Result타입으로 에러처리 [Result을 쓰는 이유 ?] Result과 do-catch, try는 큰 차이가 있다. do-catch, try의 경우 에러타입과 성공타입을 함께 쓸 수 없다. do(성공)와 catch(에러)의 구분. 그러나 Result을 사용하게 되면, 한 함수에 성공, 에러 모두 함께 쓸 수 있다. 정리하면, Result Type은 에러랑 정상적인거랑 타입으로 묶어서 던지는 것!! 예시1 123456789//1.에러 미리정의enum NumberError: Error &#123; case negativeNumber case evenNumber&#125;enum AnotherNumberError: Error &#123; case tooLarge&#125; 이런식으로 정의 된 에러가 있다면, 12345678910111213141516171819202122//2. Throwing 함수로 선언되어 있음 (홀수만 받는 함수)// (에러를 던질 수 있다.) \"에러의 형식\"을 특정하지는 못함func process(oddNumber: Int) throws -&gt; Int &#123; guard oddNumber &gt;= 0 else &#123; // 음수일 경우 NumberError의 negativeNumber을 던진다. throw NumberError.negativeNumber &#125; guard !oddNumber.isMultiple(of: 2) else &#123; // !짝수일 경우 NumberError의 evenNumber을 던진다. throw NumberError.evenNumber &#125; guard oddNumber &lt; 1000 else &#123; //1000이하인 경우 AnotherNumberError의 tooLarge을 던진다. throw AnotherNumberError.tooLarge &#125; //정상적인 처리 return oddNumber * 2&#125; 여기서, 위와 같은 방식으로만 처리한다면 문제가 있다. throws 키워드는 코드에서 에러를 던질 수 있다는 것은 나타내지만, 에러의 형식을 특정하지는 못하므로, 이렇게만 처리하면 catch블럭에서 &quot;에러 프로토콜&quot;형식만 받을 수 있게 된다(구체화된 실제 에러 형식이 아님!!!) 즉, process함수가 던지는 실제 에러 형식을 알아야 에러를 제대로 처리한 것!!! 1234567//3.do &#123; let result = try process(oddNumber: 1) print(result)&#125; catch &#123; print(error.localizedDescription)&#125; 이런식으로 !!.. 더 제대로 처리 해보기 ↓ 12345678910111213141516do &#123; let result = try process(oddNumber: 1) // try 표현식으로 호출 print(result)&#125; catch let myErr as NumberError &#123; // 실제 에러형식으로 타입캐스팅(에러의 올바른 처리를 위해) switch myErr &#123; case .negativeNumber: print(\"negative number\") case .evenNumber: print(\"even number\") &#125;&#125; catch &#123; // catch 블록 지우면 ===&gt; 런타임 에러발생 가능(AnotherNumberError를 처리하고 있지 않기 때문에) print(error.localizedDescription) // AnotherNumberError를 올바르게 처리한 것은 아님 (에러처리에서 논리적인 오류가 발생할 가능성이 높아짐)&#125; Delayed Error Handling 1234567891011121314// Result(catching: &lt;#T##() throws -&gt; _#&gt;)//Result형식은 \"throwing클로저로 초기화\"하는 생성자를 제공한다. let result = Result &#123; try process(oddNumber: 1) &#125; // Result 객체(연관값)가 저장switch result &#123; //연관값으로 저장된 에러를 처리 (에러를 처리하는 시점이 함수를 호출하는 시점에서 작업결과를 사용하는 시점으로 이동) Delayed Error Handlingcase .success(let data): print(data) //2case .failure(let error): print(error.localizedDescription)&#125;// 성공과 실패가 더욱 명확해짐 [제네릭 이용하여 처리해보기] throws 키워드 삭제, 리턴형 형식 선언 12345678910111213141516171819202122232425262728func processResult(oddNumber: Int) -&gt; Result&lt;Int, NumberError&gt; &#123; //Result타입으로 에러를 처리할때, 함수에서 직접 에러를 던지지 않고, \"연관값\"으로 저장해서 리턴 guard oddNumber &gt;= 0 else &#123; // 음수일 경우 return Result.failure(NumberError .negativeNumber) &#125; guard !oddNumber.isMultiple(of: 2) else &#123; // 짝수일 경우 return .failure(.evenNumber) &#125; // guard oddNumber &lt; 1000 else &#123; // AnotherNumberError는 리턴할 수 없음// return AnotherNumberError.tooLarge// &#125; return .success(oddNumber * 2) // 연관값으로 리턴&#125;let result1 = processResult(oddNumber: 1)switch result1 &#123; // Delayed Error Handlingcase .success(let data): print(data)case .failure(let error): print(error.localizedDescription)&#125; 제네릭을 이용하면, 이런 식의 처리도 가능해진다…!! 좀더 쉽게 이해하고자 한다면 아래의 예제를 보자 , , , ,! 1. 에러 정의(열거형) 123456&#x2F;&#x2F;1.에러정의enum APIError2 : Error &#123; case aError case bError case cError&#125; 에러는 동일하게 열거형으로 정의한다. 2. Result 이용 함수 만들기. 12345678910func plusFunction() -&gt; Result&lt;Int, APIError2&gt; &#123; //정상적인 경우엔 Int, 에러인 경우 Error if true &#123; return Result.success(10) //성공케이스 &#125; if true &#123; return Result.failure(APIError2.bError) //에러케이스 &#125;&#125;plusFunction() Result&lt;Int, APIError2&gt; 는 제네릭 형식이다. 제네릭을 쓴 이유는 모든 자료형을 처리하기 위해 쓴다. 성공케이스가 Int이든, 에러케이스가 에러타입의 열거형이든 한 함수로 묶을 수 있게 된다. 실행후, 결론적으로 plusFunction() 은 Result타입이 되어, 우의 do-catch, try 쓸 필요가 없게 된다. Result의 가장 큰 장점은 do catch, try 를 쓰지 않아도 되는 점. 코드 길이! 1234567891011//이렇게도 사용가능. let result = plusFunction()switch result &#123;case .success(let a) : print(a)case .failure(let error) : print(error)default: break&#125; 예시 1234567891011121314151617181920//성공,에러를 아예 이 타입에 담고 싶은 것//1.에러정의enum Result1&lt;Success, Failure&gt;&#123; case success(Success) //성공(데이터) -(Success)은 연관값. 열거형에서 연관값이란 추가적인, 구체적인 정보를 담기 위한 것.(선택사항임) case failure(Failure) //에러&#125;enum Weekday &#123; //월요일의 (몇시)를 넣고 싶은 것.. //타입이 달라도 된다. (String) case monday(Int) case tuesday(Int)&#125;var dat : Weekday = Weekday.monday(8) //월요일 8시//제네릭으로 하면 이런 느낌. //enum Weekday&lt;T, A&gt; &#123;// case monday(T)// case tuesday(A)//&#125; 이렇게 …!! Generics 왜 써야할 까? 제네릭이 자주 등장하는 이유는 형식에 의존하지 않는 범용코드 작성이 가능하고, 코드의 재사용성 높아 유지보수하기에 적합하여(편의성 증대) 주로 사용되는 방식이다. Generics의 가장 큰 장점은 형식에 관계없이, 한번의 구현으로 모든 자료형을 처리한다는 점!! 예시2 12345func swapInteger(lhs: inout Int, rhs: inout Int) &#123; let tmp = lhs lhs = rhs rhs = tmp&#125; inout은 왜 쓸까 ? (코너 속의 코너) 그 전에 함수실행의 메모리 구조 먼저 이해해보자. 123456789101112131415161718192021222324252627282930&#x2F;&#x2F;main()&#123; &lt;--- 1.프레임워크엔 main함수가 숨어있다. func dosomething(a: Int, b: Int) -&gt; Int &#123;&#x2F;&#x2F; a는 let이기 때문에 a &#x3D; 5로 마음대로 바꿀 수 없고, let a &#x3D; a로 선언한다. 왜 ? 파라미터는 무조건 상수이기 때문!!! let a &#x3D; a let b &#x3D; b &#x2F;&#x2F;⭐️ 정 변경하고 싶은 경우 이런식으로 c라는 변수를 만들어 변경 var c &#x3D; a c +&#x3D; 3 return c + b &#x2F;&#x2F;10&#125;var x &#x3D; 3var y &#x3D; 4dosomething(a: 3, b: 4) &#x2F;&#x2F;보통 이런식으로 변경하지만 dosomething(a: x, b: y) &#x2F;&#x2F;인 경우.&#x2F;&#x2F;2. inout이해하기var a &#x3D; 10 var b &#x3D; 20swapInteger(lhs: &amp;a, rhs: &amp;b)a &#x2F;&#x2F;20b &#x2F;&#x2F;10&#125; 1. 함수실행시 메모리구조 이해하기 xcode든 playground든 프레임워크 가장 상위에 main()함수가 숨어 있다. dosomething()이라는 함수 가 있을 때, 함수 안에선 let a = a 이런식으로 사용해야한다. 이유는 파라미터는 항상 상수이기 때문. 값을 꼭 바꾸고 싶다면 c 라는 임의의 변수를 하나 만들어 위처럼 사용할 수도 있다. inout을 알아보기 전에 함수실행의 메모리 구조에 대해 알아보자 ! 직접 만들어서 이해해봄!! 외우자, 코 데 힙 스 ! 위 이미지는 함수실행의 메모리 구조를 보여준다. 함수실행은 항상 스택을 만든다. 스택1에 함수실행1이라고 이해하면 되고, 함수가 실행되고 그것을 마치면 스택은 사라진다. 즉, 모든 일이 종료되면 여튼 없어짐!! 이를 바탕으로 위 예시 코드로 설명할 때, main()가 가장 먼저 실행되고, 다음으로 dosomething(a: 3, b: 4)가 실행된다. x,y의 공간인 [스택 1]이 먼저 생성된다. 그 다음으로 a,b,c의 공간 [스택 2]가 생성된다. dosomething(a: x, b: y)의 함수가 실행될 때, x는 a값을 복사해오고, y는 b값을 복사해온다. 함수가 return c + b에 따라 10을 갖는다. 이때 10은 임시거처에 있고 함수는 종료되면서 임시 값이 main()으로 전해질 수 있는 상태다. 스택의 과정은 일단 이렇고, 함수를 실행할 때 파라미터는 let이라는 점! 나만의 공간을 만들고 던지는 변수 !! 그 변수를 복사해서 사용하는 것 !! 이 기본적인 함수실행의 메모리 구조인 것이다. 그래서 … inout은 왜 쓸까 ? 2. inout이해하기 inout을 쓰는 가장 큰 이유는 메모리 주소를 참조한다는 것이다.(?) 띠용… 다시 말해보자면… inout은 복사해서 사용하는 것이 아니라, inout을 붙인 파라미터의 함수를 실행할 때, 호출 시 dosomething(a: &amp;x, b: &amp;y)이런 식으로 호출하고, 이 형식은 메모리 주소를 참조한다는 의미이다. 복사하는 순간 a를 쓰고, b를 쓰는 게 아니라… a를 가르키고 b를 가르키는 것이다. (x와y를 가르키는 것이 아니라…함수실행 프레임과 반대로) 그래서 변형도 가능하다. tmp는 임시장소, inout은 원래장소에 접근하는 것. 그래서 위 예시코드를 보면 lhs과 rhs의 값을 보다 편의하게 바꿀 수 있게 된다…! Generics의 쓰임… inout까지 설명이 되었고, 본론으로 돌아와서. 그럼 Generics은 왜 써야하는 거야? 의문이 생긴다. 위에 서 말했듯, 제네릭을 쓰는 이유는 모든 자료형을 처리하기 위해 쓴다. 다시 예시코드를 보면, 예시코드(예시2) 12345func swapInteger(lhs: inout Int, rhs: inout Int) &#123; let tmp = lhs lhs = rhs rhs = tmp&#125; 해당 코드를 실행하기 위해 inout으로 효과적으로 쓸 수 있지만, 만약 (Int가 아닌) 타입이 다를 경우… 아래와 같은 코드 중복이 발생한다. 1234567891011func swapInteger16(lhs: inout Int16, rhs: inout Int16) &#123; // ...&#125;func swapInteger64(lhs: inout Int64, rhs: inout Int64) &#123; // ...&#125;func swapDouble(lhs: inout Double, rhs: inout Double) &#123; // ...&#125; 이러한 방식은 코드 중복의 문제도 있지만, 값을 바꾸어야할 때, 함수에 포함된 코드를 하나하나 다 수정해야한다는 문제도 있다. 이 이유로 제내릭을 쓴다. Generics 기본형 123func name&lt;T&gt;(parameters) -&gt; Type &#123;code&#125; 타입 파라미터는 함수 내부에서 파라미터 형식이나 리턴형으로 사용된다. (함수 바디에서 사용하는 것도 가능하다). 제네릭 선언시 보통은 T를 사용하지만 다른 이름을 사용하는 것도 문제가 없다. 다만, T로 쓰는 게 약속이기에 거의 T를 쓴다. 형식이름이기 때문에 UpperCamelcase로 대문자 한글자만 선언한다. 그리고 2개이상 선언하는 것도 가능하다. 그래서 위의 예시코드를 제네릭을 이용하여 작성해보면 아래와 같은 코드처럼 쓸 수 있게 된다. 123456789101112131415161718192021func swapValue&lt;T&gt;(lhs: inout T, rhs: inout T) &#123; //컴파일러가 전달된 형식의 적합한 코드를 자동으로 생성 let tmp = lhs lhs = rhs rhs = tmp&#125;a = 1b = 2swapValue(lhs: &amp;a, rhs: &amp;b) // Int를 파라미터로 전달a //2b //1 var c = 1.2var d = 3.4swapValue(lhs: &amp;c, rhs: &amp;d) // Double을 파라미터로 전달c //3.4d //1.2 위의 중복적으로 처리한 일반 함수와 비교해보면, 작성해야하는 코드의 양이 비약적으로 감소하는 모습을 볼 수 있다. 여기서 타입 파라미터는 실제 자료형으로 대체되는 플레이스 홀더(어떤 기호같은것) ===&gt; 새로운 형식이 생성되는 것은 아니고, 코드가 실행될 때 문맥에 따라서 실제 형식으로 대체되는 플레이스 홀더일 뿐이다. 그리고 파라미터는 깔을 맞춰줘야한다. var d = 3.4을 var d = 3으로 바꾸면 Cannot convert value of type ‘Int’ to expected argument type 'Double’라고 오류난다. 제네릭이 그저 어렵게만 느껴졌는데, 제네릭의 사전적의미는 일반적인이다. 일반적인??이라고 생각하니 좀 받아들이기 쉬워지는 것 같기도 하고… 어쨌든 제네릭 형식을 이해한 후 다시 위의 ** 2. Result타입으로 에러처리** 부분을 한번 더 참고하면 좋을 것 같다. 제네릭에 대한 자세한 내용은 이후 더 다뤄볼 생각이다. 아래링크(준비중)","categories":[{"name":"post","slug":"post","permalink":"https://qussk.github.io/categories/post/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"throwing","slug":"throwing","permalink":"https://qussk.github.io/tags/throwing/"},{"name":"do-catch,try","slug":"do-catch-try","permalink":"https://qussk.github.io/tags/do-catch-try/"},{"name":"Result","slug":"Result","permalink":"https://qussk.github.io/tags/Result/"},{"name":"ErrorHandling","slug":"ErrorHandling","permalink":"https://qussk.github.io/tags/ErrorHandling/"}]},{"title":"[Swift]scrollToRow 최상단 이동","slug":"Swift-최상단-이동","date":"2020-09-24T23:21:04.000Z","updated":"2020-09-24T14:32:43.550Z","comments":false,"path":"2020/09/25/Swift-최상단-이동/","link":"2020/09/24/Swift-최상단-이동","permalink":"https://qussk.github.io/2020/09/25/Swift-%EC%B5%9C%EC%83%81%EB%8B%A8-%EC%9D%B4%EB%8F%99/","excerpt":"","text":"문제사항 [정상적인 모습] [다음화면] 1번뷰에서 2번뷰로 이동하고 나서 1번뷰로 오면 버튼이 있어야함. (버튼은 ViewdidAppear 에 있음) [스크롤을 아래로 많이 내리고] [다시 화면 돌아오면 버튼 사라짐] 이게 사라지는 게 아니라, 네이게이션 높이만큼 뷰가 아래 제일 위로 올리면 네비게이션 높이만큼 뷰가 날아가 있음. 뷰가 날아갔다기 보단, 아래로 네이게이션 높이만큼 뷰가 아래로 끌려서 버튼이 안보인거임. (버튼 프레임 높게줘서 확인해봄…) 범인 12345678910111213141516171819202122//MARK:- UIScrollViewDelegate//스크롤뷰 제어extension DetailMenuVC: UIScrollViewDelegate&#123; func scrollViewDidScroll(_ scrollView: UIScrollView) &#123; if scrollView.contentOffset.y &lt; 1 &#123; scrollView.contentOffset.y = 1 &#125; if scrollView.contentOffset.y &gt;= 260 &#123; title = \"\\(data!.name)\" self.navigationController?.navigationBar.setBackgroundImage(UIImage(named: \"back\"), for: .any, barMetrics: .default) [leftButton,rightButton].forEach&#123; $0.tintColor = .black &#125; &#125;else &#123; navigationBarLess() title = \"\" [leftButton,rightButton].forEach&#123; $0.tintColor = .lightGray &#125; &#125; // print(scrollView.contentOffset.y) &#125;&#125; 범인은 이것 때문인 것 같음… 테이블뷰랑 버튼 프레임에는 문제 없음확인… 이것 주석처리 하고 했을 땐 정상적임을 확인, 나는 다 필요해 !!! 해결 : scrollToRow이용하여 처리. 1234//화면 이동시 테이블뷰의 최상단으로 강제 이동(뷰가 잘리는 부분 임시 처리)let indexPath = NSIndexPath(row: NSNotFound, section: 0)self.tableView.scrollToRow(at: indexPath as IndexPath, at: .top, animated: false)","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"scrollToRow","slug":"scrollToRow","permalink":"https://qussk.github.io/tags/scrollToRow/"}]},{"title":"[Swift] REST API - decode","slug":"Swift-RESTAPI","date":"2020-09-24T23:02:49.000Z","updated":"2020-10-12T07:27:22.343Z","comments":false,"path":"2020/09/25/Swift-RESTAPI/","link":"2020/09/24/Swift-RESTAPI","permalink":"https://qussk.github.io/2020/09/25/Swift-RESTAPI/","excerpt":"","text":"Model 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class MenuData: Codable &#123; var id: Int var name: String var image: String var caption: String var price: Int var optionGroup: [OptionGroup?] init() &#123; id = 0 name = \"\" image = \"\" caption = \"\" price = 0 optionGroup = [OptionGroup]() &#125; enum CodingKeys: String, CodingKey &#123; case id, name, image, caption, price case optionGroup = \"option_group\" &#125; class OptionGroup: Codable &#123; var id: Int var name: String var menuId: Int var mandatory: Bool var option: [Option] init() &#123; id = 0 name = \"\" mandatory = true menuId = 0 option = [Option]() &#125; enum CodingKeys: String, CodingKey &#123; case id, name, mandatory, option case menuId = \"menu_id\" &#125; class Option: Codable &#123; var id: Int var name: String var price: Int var optionGroupId: Int var selectPos: Bool init() &#123; id = 0 name = \"\" price = 0 optionGroupId = 0 selectPos = false &#125; enum CodingKeys: String, CodingKey &#123; case id, name, price, selectPos case optionGroupId = \"option_group_id\" &#125; &#125; &#125;&#125; 변수로 Model 가져오기 1var usd : MenuData? URLSession - JSONDecoder 123456789101112131415161718func fechData()&#123; let url = URL(string: UrlBase.menuInstance) URLSession.shared.dataTask(with: url!) &#123; (data, response, error) in if error == nil &#123; do&#123; self.usd = try JSONDecoder().decode(MenuData.self, from: data!) &#125;catch&#123; print(\"catch\") &#125; DispatchQueue.main.async&#123; print(\"usd?.name : \\(self.usd?.name)\") &#125; &#125;else&#123; print(\"Error\") &#125; &#125;.resume()&#125; UrlBase 1234567struct UrlBase &#123;static let menuInstance = \"http://52.79.251.125/menu/\"(중략)이런식으로 쭉 있음 &#125; id으로 api구분하여 가져오기 1public var id : Int = 20 이런식으로 id값에 따라 가져올 수 있음 12\"UrlBase.menuInstance.\\(String(id))\"\\(String(id))","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"JSON","slug":"JSON","permalink":"https://qussk.github.io/tags/JSON/"},{"name":"RESTAPI","slug":"RESTAPI","permalink":"https://qussk.github.io/tags/RESTAPI/"},{"name":"Codable","slug":"Codable","permalink":"https://qussk.github.io/tags/Codable/"}]},{"title":"[swift]Alamofire 작업하기","slug":"swift-Alamofire-작업하기","date":"2020-09-15T22:21:03.000Z","updated":"2020-09-15T13:23:24.037Z","comments":false,"path":"2020/09/16/swift-Alamofire-작업하기/","link":"2020/09/15/swift-Alamofire-작업하기","permalink":"https://qussk.github.io/2020/09/16/swift-Alamofire-%EC%9E%91%EC%97%85%ED%95%98%EA%B8%B0/","excerpt":"","text":"123456789//json에서 name만 가져옴 if let menuData = json[\"option_group\"].array&#123; for e in 0..&lt;menuData.count &#123; print(e) self.arrtest.append(menuData[e][\"name\"].stringValue) print(\"arrtest: \\(self.arrtest)\") &#125; &#125;","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"Alamofire","slug":"Alamofire","permalink":"https://qussk.github.io/tags/Alamofire/"}]},{"title":"[Swift]Could not build Objective-C module 'SnapKit'","slug":"Swift-Could-not-build-Objective-C-module-SnapKit","date":"2020-09-14T20:19:44.000Z","updated":"2020-09-14T11:54:03.978Z","comments":false,"path":"2020/09/15/Swift-Could-not-build-Objective-C-module-SnapKit/","link":"2020/09/14/Swift-Could-not-build-Objective-C-module-SnapKit","permalink":"https://qussk.github.io/2020/09/15/Swift-Could-not-build-Objective-C-module-SnapKit/","excerpt":"","text":"이런식으로 오류가 떴다. 코드상 이런 에러 뜰 리 없구 또 코코아팟의 까닭모를 오류중 하나겠지 싶어 이것저것 내가 아는 방법 총 동원했는데 해결되지 않아 검색했다… 역시나 원인은 알 수 없지만, 맨 마지막 'SnapKit’은 라이브러리 이름이고, 어떤 라이브러리에 특정하게 나는 오류가 아니라, 그냥 어느 라이브러리라면, (늘 그렇듯) 코코아팟이라면 모두 일어날 수 있는 오류… cocoapod의 불편함 이번엔 공용레포에선 정상적인데 내꺼로 가져오기만하면 오류, 둘다 새로 클론 쓴거라서 틀린거 1도 없는데… 이유는 모르겠고 그냥 정말 오류인 듯하다… 뭔가 fw데이터량이 너무 중복돼서?? 인것 같기도… 근데 다 주소값 있지 않나, 어쨌든, xcode상단의 Preferences로 간다. 'cmd , '로도 나올수 있는 곳. 그럼 드라이버 데이타로 갈 수 있는 화살표가 보이는 데 이곳 클릭 열고~ 실행된 xcode프로젝트에 대한 데이타 공간인 것 같다. 여기서부터가 시작임. 1. 해당 프로젝트에 대한 데이터 폴더를 모두 삭제한다. (위 밑줄 참고) (모야 프로젝트 다 사라지는 거 아냐?라고 생각할 수 있지만 열었다는 data만 없애는 것이니 안심…) 2. 해당 프로젝트 폴더에 가서 Project의.xcworkspace, Podfile.lock 파일 과 Pods 폴더를 삭제한다. ((((총 3개!!!)))) (여긴 프로젝트를 직접 지우는 것이라 조금 긴장함…ㅠㅠ… 안되면 블로그 폭파해버릴거야… 이런 느낌…) 3. 아래 명령어를 터미널에서 실행 (주의 : 콘솔은 해당 Project로 이동되어 있는 상태). 1pod install --verbose 4. 그럼 디지몬세계처럼 뭐가 엄청 많이 깔리구 , (cocoapod을 그냥 완전히 제거했다가 다시 까는 개념인거 가틈,) 5. 조신하게 기다렸던 Project의.xcworkspace 가 다시 새로 깔리면 command + b 를 눌러 Project를 다시 빌드 해본다. 그러니 해결됨 ㅠㅠㅠ 감사합니다… 젭알 코코아팟 쓰지말구 FM 쓰자…ㅠㅠㅠ없는 건 어쩔 수 없지만 출처 : https://gogorchg.tistory.com/entry/iOS-Error-Could-not-build-ObjectiveC-module-Firebase tips cocoapod쓰면서 별별 오류를 다 경험하게 되는 데, cocoapod오류나면 제일 먼저 해보는 것 써본당., 버전 확인이 제일 기본. (라이브러리기 때문에 언제 업뎃될지 모름!!!) (이상없다면, 1번으로…) podfile가서 오류나는 라이브러리 주석처리하고 pod install, 그리고 주석 해제후 다시 pod install (없앴다가 다시 까는 개념) cocoapod를 재설치 1sudo gem uninstall cocoapods 1sudo gem install xcodeproj 1sudo gem install cocoapods (근데 여기까진 왠만하면안간다… ) xcode이전 버전으로 하고 있기… xcode업뎃하면 라이브러리에 대한 오류가 갑자기 우수수 날때가 있는데, (1~3 다 안먹히면) 그땐 그냥 이전버전을 하나 설치해서 쓰다가, 추후 안정화되면 옮긴다, ㅎㅎ…","categories":[{"name":"error","slug":"error","permalink":"https://qussk.github.io/categories/error/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"Error","slug":"Error","permalink":"https://qussk.github.io/tags/Error/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-09-14T17:28:54.146Z","updated":"2020-09-14T08:28:54.146Z","comments":false,"path":"2020/09/15/hello-world/","link":"2020/09/14/hello-world","permalink":"https://qussk.github.io/2020/09/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"[Swift]UITableView(모음)","slug":"Swift-UITableView-모음","date":"2020-09-14T12:24:16.000Z","updated":"2020-09-14T06:21:56.010Z","comments":false,"path":"2020/09/14/Swift-UITableView-모음/","link":"2020/09/14/Swift-UITableView-모음","permalink":"https://qussk.github.io/2020/09/14/Swift-UITableView-%EB%AA%A8%EC%9D%8C/","excerpt":"","text":"Cell 123456789101112import UIKitclass cell(셀이름) : UITableViewCell &#123; override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) &#123; super.init(style: style, reuseIdentifier: reuseIdentifier) &#125; required init?(coder aDecoder: NSCoder) &#123; fatalError(\"init(coder:) has not been implemented\") &#125;&#125; UITableView 1234567891011121314151617181920212223242526//선언let tableView = UITableView()func setTableView()&#123;tableView.dataSource = self //필수tableView.delegate = self //필요시//frame(크기) 정의tableView.frame = view.frame ////동적높이 -&gt; Int로 주면 해당 값이 셀의 고정높이가 됨. 예)tableView.rowHeight = 44tableView.rowHeight = UITableView.automaticDimension // tableView.estimatedRowHeight = 0 // automaticDimension이 셋팅되기 전 셀높이//배경색tableView.backgroundColor = .white //선긋기 옵션tableView.separatorStyle = .none//필수view.addSubview(tableView)tableView.register(cell(셀이름).self, forCellReuseIdentifier: \"cell(셀이름 or Identifier)\" //테이블뷰에 셀 등록&#125; UITableViewDataSource UITableView를 구현하기 위한 필수 프로토콜 임. 12345extension ViewController: UITableViewDataSource&#123;//섹션 갯수func numberOfSections(in tableView: UITableView) -&gt; Int &#123; 3&#125; 12345678910//셀 갯수func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; if section == 0 &#123; //섹션의 인덱스가 0일 경우 return 5 &#125;else section == 1 &#123; 섹션의 인덱스가 1일 경우 return 1 &#125;else &#123; return 0 // + optionsCount &#125;&#125; 123456//셀 디자인(속성)func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;let cell = tableView.dequeueReusableCell(withIdentifier: \"cell\", for: indexPath) as! cell cell.backgroundColor = .whiteretrun cell swich문 쓸때 12345678910111213141516171819202122232425262728293031switch indexPath.section &#123;case 0: if indexPath.row == 0 &#123; let imageCell = tableView.dequeueReusableCell(withIdentifier: \"ImageTableViewCell\", for: indexPath) as! ImageTableViewCell return imageCell &#125; else if indexPath.row == 1 &#123; let saleCell = tableView.dequeueReusableCell(withIdentifier: \"SaleTableViewCell\", for: indexPath) as! SaleTableViewCell return saleCell &#125; else if indexPath.row == 2 &#123; let nameCell = tableView.dequeueReusableCell(withIdentifier: \"NameTableViewCell\", for: indexPath) as! NameTableViewCell nameCell.detailmenuName.text = \"\\(mainName)\" return nameCell ...(중략) 이런식으로 indexPath.row == 5까지..(셀이 고정값이라면..) indexPath.row 는 셀의 인덱스값. //case 0~ 2는 section의 인덱스값에 해당됨. //section은 case 2+optionGroupCount(Int값) 이런식으로도 표현하여 임의적으로 섹션 순서 변경 할 수 있음.... //예를들면,, case 1 + optionGroupCount: let costCell = tableView.dequeueReusableCell(withIdentifier: \"CostTableViewCell\", for: indexPath) as! CostTableViewCell costCell.costLableWon.text = \"\\(menuCost)원\" return costCell case 2 + optionGroupCount - 2 : //라면, case 2+optionGroupCount-2는 1+optionGroupCount보다 더 우선 순위에 보여지게 됨. UITableViewDelegate UITableView를 구현하고 필요 옵션이 필요한 경우 사용되는 부가 프로토콜 임. 12 Header 1234567891011121314151617181920212223242526272829303132333435//Header text넣기 (원치 않는 다면, 공백으로 처리)func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? &#123; switch section &#123; case 0: return \" \" case 1: return \" \" case 2 + optionGroupCount: return \"jjjjj\"// menuData[section].category case 3 + optionGroupCount: return \" \" case 4 + optionGroupCount-2: return \" \" default: return \"ddddddddd\" //\"\\(details[section].optionGroup)\" &lt;- 이런식으로 데이터값 불러 올 수 있음 &#125; &#125;//Header 높이 지정(원치 않는 다면 0)func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat &#123; switch section &#123; case 0: return 0 case 1: return 0 case 2+optionsCount: return 44 case 3+optionsCount: return 0 case 4+optionsCount: return 0 default: return 44 &#125;&#125; 주의 모두 공백으로 처리하고 싶은데 안될 경우 123func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat &#123; return CGFloat.leastNormalMagnitude //CGFloat 양수 최소값 상수 &#125; 이런 식으로 처리 Footer //Footer에 text 넣기 (원치 않는 다면, 공백으로 처리) func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? { switch section { case 0: return &quot; &quot; case 1: return &quot; &quot; case 2: return &quot; &quot; default: return &quot;안뇽&quot; } } //Footer 높이 지정(원치 않는 다면 0) func tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -&gt; CGFloat { switch section { case 0: return 1 case 1: return 1 case 2: return 1 case 3: return 1 case 4: return 2 default: return 0 } }","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"UITableView","slug":"UITableView","permalink":"https://qussk.github.io/tags/UITableView/"}]},{"title":"[Swift] Set<UITouch> 터치 판단","slug":"Swift-Set-UITouch-터치-판단","date":"2020-09-05T21:49:24.000Z","updated":"2020-09-05T12:52:56.329Z","comments":false,"path":"2020/09/06/Swift-Set-UITouch-터치-판단/","link":"2020/09/05/Swift-Set-UITouch-터치-판단","permalink":"https://qussk.github.io/2020/09/06/Swift-Set-UITouch-%ED%84%B0%EC%B9%98-%ED%8C%90%EB%8B%A8/","excerpt":"","text":"https://developer.apple.com/documentation/swift/set https://developer.apple.com/documentation/uikit/uitouch 터치 좌표 얻기 123456override func touchesMoved(_ youches: Set&lt;UITouch&gt;, with event : UIEvent?) &#123;let touch = touches.first!//터치가 발생한 뷰 기준 좌표let point = touch.location(in: touch.view)&#125;","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"UITouch","slug":"UITouch","permalink":"https://qussk.github.io/tags/UITouch/"}]},{"title":"[Swift]특정 Lable 속성 변경하기","slug":"Swift-특정-Lable-속성-변경하기","date":"2020-09-02T14:40:10.000Z","updated":"2020-09-02T05:56:06.980Z","comments":false,"path":"2020/09/02/Swift-특정-Lable-속성-변경하기/","link":"2020/09/02/Swift-특정-Lable-속성-변경하기","permalink":"https://qussk.github.io/2020/09/02/Swift-%ED%8A%B9%EC%A0%95-Lable-%EC%86%8D%EC%84%B1-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0/","excerpt":"","text":"한 Lable안 text에 다른 속성을 달리 주어야 하는 경우가 있다. lable을 2개 붙여도 되지만, 각각의 lable이 큰 기능을 가지고 있지 않고 뷰 용도로만 사용된다면 하나의 레이블에 다른 text 속성을 달리하여 사용해도 무방하다. “앱에서 미리결제” 이 부분을 NSAttributedString을 이용하여 다른 폰트~ 칼라로 적용해보자. Lable 1234567let yogiseoPay: UILabel = &#123; let l = UILabel() l.text = \"요기서 결제 앱에서 미리 결제\" l.font = FontModel.toSize.customFont l.textAlignment = .center return l &#125;() NSAttributedString 1234567let attr = NSMutableAttributedString(string: yogiseoPay.text!)attr.addAttribute(NSAttributedString.Key.foregroundColor, value: ColorPiker.customDarkGray, range: (yogiseoPay.text! as NSString).range(of: \"앱에서 미리 결제\")) // 글자 색깔attr.addAttribute(NSAttributedString.Key.init(kCTFontAttributeName as String), value: FontModel.toSize.customSmallFont as Any, range: (yogiseoPay.text! as NSString).range(of: \"앱에서 미리 결제\"))// 폰트yogiseoPay.attributedText = attr 적용","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"UILable","slug":"UILable","permalink":"https://qussk.github.io/tags/UILable/"}]},{"title":"[Swift]스와이프 제스처로 뒤로가기(navi)","slug":"Swift-스와이프-제스처로-뒤로가기-navi","date":"2020-08-29T19:24:47.000Z","updated":"2020-08-29T11:15:45.997Z","comments":false,"path":"2020/08/30/Swift-스와이프-제스처로-뒤로가기-navi/","link":"2020/08/29/Swift-스와이프-제스처로-뒤로가기-navi","permalink":"https://qussk.github.io/2020/08/30/Swift-%EC%8A%A4%EC%99%80%EC%9D%B4%ED%94%84-%EC%A0%9C%EC%8A%A4%EC%B2%98%EB%A1%9C-%EB%92%A4%EB%A1%9C%EA%B0%80%EA%B8%B0-navi/","excerpt":"","text":"navigationController이 있는 controller의 경우 interactivePopGestureRecognizer을 통해 push, pop의 연속동작을 제어할 수 있다. 1. interactivePopGestureRecognizer 1234import UIKit //스와이프제스쳐로 뒤로가기 허용navigationController?.interactivePopGestureRecognizer?.isEnabled = true false : 중단 2. UIGestureRecognizerDelegate 123456extension UIViewController : UIGestureRecognizerDelegate &#123; public func gestureRecognizer(gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWithGestureRecognizer otherGestureRecognizer: UIGestureRecognizer) -&gt; Bool &#123; return true &#125; &#125; UIGestureRecognizerDelegate 이용. 화면 왼쪽끝에서 오른쪽으로 밀어서 이전화면으로 돌아가는 제스처. 맨 상위뷰에서 구현하면 하위뷰 에는 자동으로 적용됨!","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"UINavigationController","slug":"UINavigationController","permalink":"https://qussk.github.io/tags/UINavigationController/"}]},{"title":"[Swift]ScrollView 상/하단 및 특정 셀로 이동하기","slug":"Swift-ScrollView-상-하단-이동","date":"2020-08-29T15:55:43.000Z","updated":"2020-08-29T09:00:07.915Z","comments":false,"path":"2020/08/30/Swift-ScrollView-상-하단-이동/","link":"2020/08/29/Swift-ScrollView-상-하단-이동","permalink":"https://qussk.github.io/2020/08/30/Swift-ScrollView-%EC%83%81-%ED%95%98%EB%8B%A8-%EC%9D%B4%EB%8F%99/","excerpt":"","text":"상/하단 이동은 기본적으로 scrollRectToVisible을 이용한 방법이 있고 1scrollView.scrollRectToVisible (myElementView.frame, animated : true) setContentOffset을 이용한 방법이 있다. 1scrollView.setContentOffset(CGPoint(x: 0, y: 0), animated: true) 상단이동 12345scrollView.scrollRectToVisible(CGRect(x: 0, y: 0, width: 1, height: 1), animated: true)orscrollView.setContentOffset(CGPoint(x: 0, y: 0), animated: true) 하단이동 123456789scrollView.scrollRectToVisible(CGRectMake(0, scrollView.contentSize.height - scrollView.bounds.height,scrollView.bounds.size.width,scrollView.bounds.size.height),animated: true)orscrollView.setContentOffset(CGPoint(x: 0,y: scrollView.contentSize.height - scrollView.bounds.height), animated: true) 특정 셀로 이동 만약, 특정 섹션/셀로 이동하여야 한다면 12//스위프트 4tableView.scrollToRow(at: IndexPath(row:0, section: 0, width: 1, height: 1), animated : true) 123456789101112//스위프트5func hasRowAtIndexPath(indexPath: IndexPath)-&gt;Bool &#123;return indexPath.section &lt; numberOfSections &amp;&amp; indexPath.row &lt; numberOfRows(insection: indexPath.section) &#125;func scrollToTop(_ animated: Bool = false)&#123;let indexPath = IndecPath(row: 0, section: 0)if hasRowAtIndexPath(indexPath: indexPath) &#123;scrollToRow(at: indexPath, at: .top, animated: animated) &#125; &#125;&#125; 만약, 네비게이션이 포함되어 있다면 네비게이션바 높이 값을 곱해 줘야할 수 있다. 1(self.navigationController!.navigationBar.height + UIApplication.sharedApplication().ststusBarFrame.height)), animated: true) 만약, 탭바를 포함하고 있다면, 아래의 코드를 참고해야 한다. extension UITableView { func scrollToTop(){ for i in 0...numberOfSections - 1 { if numeberOfSections &gt; 0 &amp;&amp; numberOfRows(inSection: index), at: .top, animated: true) break } if i == numberOfSections - 1 { setContentOffset(.zero, animated: true) break } } }","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"UIScrollView","slug":"UIScrollView","permalink":"https://qussk.github.io/tags/UIScrollView/"}]},{"title":"[Swift]url-Scheme(앱에서 앱으로 연결)","slug":"Swift-url-Scheme-앱에서-앱으로-연결","date":"2020-08-27T21:39:13.000Z","updated":"2020-10-12T07:03:59.924Z","comments":false,"path":"2020/08/28/Swift-url-Scheme-앱에서-앱으로-연결/","link":"2020/08/27/Swift-url-Scheme-앱에서-앱으로-연결","permalink":"https://qussk.github.io/2020/08/28/Swift-url-Scheme-%EC%95%B1%EC%97%90%EC%84%9C-%EC%95%B1%EC%9C%BC%EB%A1%9C-%EC%97%B0%EA%B2%B0/","excerpt":"","text":"네이버 지도 1234567891011@objc func naverCliked(_ sender: UIButton)&#123; let url = URL(string: \"navermaps://route/walk\")! let appStoreURL = URL(string: \"http://itunes.apple.com/app/id311867728?mt=8\")! if UIApplication.shared.canOpenURL(url) &#123; UIApplication.shared.open(url) &#125; else &#123; UIApplication.shared.open(appStoreURL) &#125;&#125; 지도앱으로 연결됨 인스타그램 123456789101112131415161718@objc func instarCliked(_ sender : UIButton)&#123; let instagram = \"instagram://app\" if let appUrl = URL(string: instagram) &#123; if UIApplication.shared.canOpenURL(appUrl)&#123; if #available(iOS 10.0, *)&#123; UIApplication.shared.open(appUrl) print(instagram) &#125;else &#123; print(\"not found\")// UIApplication.shared.openURL(URL(string: \"http://itunes.apple.com/app/id389801252?mt=8\")!) //https://apps.apple.com/us/app/kakaotalk/id362057947 &#125; &#125; &#125; &#125; 인스타그램 앱으로 연결됨 카카오톡 카카오의 경우 sdk를 깔아야한다. 12345678910111213141516//MARK: -kakaoScheme(url) @objc func kakaodidTap(_ sender : UIButton)&#123; let kakaoScheme = \"kakao4885bd샬라샬라샬라샬라샬라샬라샬라99://kakaolink\" //\"kakao&#123;kakaosdkappid&#125;://kakaolink\" if let url = URL(string: kakaoScheme) &#123; print(\"카카오ing\") if UIApplication.shared.canOpenURL(url)&#123; if #available(iOS 10.0, *)&#123; UIApplication.shared.open(url) print(kakaoScheme) &#125;else &#123; print(\"not found\") &#125; &#125; &#125; &#125; 카카오톡 앱으로 링크 연결됨. AppStoreReview Page(앱리뷰) 1234567if let reviewURL = URL(string: \"itms-apps://itunes.apple.com/app/itunes-u/id\\(YourAppID)?ls=1&amp;mt=8&amp;action=write-review\"), UIApplication.shared.canOpenURL(reviewURL) &#123; //유효한 URL인지 검사. if #available(iOS 10.0, *) &#123; UIApplication.shared.open(reviewURL, options: [:], completionHandler: nil) &#125; else &#123; UIApplication.shared.openURL(reviewURL) &#125;&#125; YourAppID에 아이튠즈에 나와있는 고유ID를 넣어주면 된다. 출시전에도 앱의 고유아디를 받을 수 있음!","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"Scheme","slug":"Scheme","permalink":"https://qussk.github.io/tags/Scheme/"},{"name":"kakao","slug":"kakao","permalink":"https://qussk.github.io/tags/kakao/"}]},{"title":"[Swift]클립보드에 복사하기(UIPasteboard)","slug":"Swift-클립보드에-복사","date":"2020-08-27T20:47:13.000Z","updated":"2020-08-29T03:07:01.548Z","comments":false,"path":"2020/08/28/Swift-클립보드에-복사/","link":"2020/08/27/Swift-클립보드에-복사","permalink":"https://qussk.github.io/2020/08/28/Swift-%ED%81%B4%EB%A6%BD%EB%B3%B4%EB%93%9C%EC%97%90-%EB%B3%B5%EC%82%AC/","excerpt":"","text":"자주보는 클립보드 복사기능! UIPasteboard을 이용하여 String으로 클립보드에 복사할 값을 넣어주기만 하면 된다. 클립보드로 복사 123456@objc func cilpdidTap(_ sender: UIButton)&#123; UIPasteboard.general.string = \"https://apps.apple.com/us/app/kakaotalk/id362057947\" print(\"클립이 복사되었습니다.\") cancelAnimation() dismiss(animated: true, completion: nil)&#125; 위의 예시는 특정 버튼을 누르면 dismiss되면서 지정된 String값의 URL주소가 복사되는 것이다. 그리고 다른 앱에 post 해보면 이런식으로 해당 값이 copy되어 붙여넣기가 됨. 클립보드에 복사된 String값 가져오기 123if let isCopy = UIPasteboard.general.string &#123; print(\"가져오기 \\(isCopy)\")&#125; 이런식으로 변수를 만들어 복사한 값을 가져올 수도 있다.","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"UIPasteboard","slug":"UIPasteboard","permalink":"https://qussk.github.io/tags/UIPasteboard/"}]},{"title":"[Swfit]간단 API확인하기(터미널, Alamofire & SwiftyJSON)","slug":"Swfit-간단-API확인하기-터미널-Alamofire-SwiftyJSON","date":"2020-08-22T11:23:21.000Z","updated":"2020-08-22T02:33:15.650Z","comments":false,"path":"2020/08/22/Swfit-간단-API확인하기-터미널-Alamofire-SwiftyJSON/","link":"2020/08/22/Swfit-간단-API확인하기-터미널-Alamofire-SwiftyJSON","permalink":"https://qussk.github.io/2020/08/22/Swfit-%EA%B0%84%EB%8B%A8-API%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0-%ED%84%B0%EB%AF%B8%EB%84%90-Alamofire-SwiftyJSON/","excerpt":"","text":"http://3.34.192.121/tests에 대한 API 확인하기! terminal curl 명령어를 사용하면 해당 api의 제이슨을 읽어볼 수 있다. (get) Alamofire &amp; SwiftyJSON 흔히 사용하는 Alamofire와 SwiftyJSON 조합으로 Swift에서 간단히 읽어낼 수 있다. (아래 코드 이용) 1234567891011121314151617181920212223242526272829import UIKitimport Alamofireimport SwiftyJSONclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() AlamofireRequest() &#125; func AlamofireRequest() &#123; AF.request(\"http://3.34.192.121/tests\", method: .get).validate().responseJSON &#123; response in switch response.result &#123; case .success(let value): let json = JSON(value) print(\"JSON: \\(json)\") case .failure(let error): print(error) &#125;&#125;&#125;&#125;","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"Alamofire","slug":"Alamofire","permalink":"https://qussk.github.io/tags/Alamofire/"},{"name":"SwiftyJSON","slug":"SwiftyJSON","permalink":"https://qussk.github.io/tags/SwiftyJSON/"}]},{"title":"[Swift] 설정화면으로 이동","slug":"Swift-설정화면으로-이동","date":"2020-08-20T16:59:02.000Z","updated":"2020-08-29T11:15:49.633Z","comments":false,"path":"2020/08/21/Swift-설정화면으로-이동/","link":"2020/08/20/Swift-설정화면으로-이동","permalink":"https://qussk.github.io/2020/08/21/Swift-%EC%84%A4%EC%A0%95%ED%99%94%EB%A9%B4%EC%9C%BC%EB%A1%9C-%EC%9D%B4%EB%8F%99/","excerpt":"","text":"sharedApplication에서 지원해준답 😛 12345678@objc func didTap(_ sender: UIButton)&#123; if #available(iOS 10.0, *)&#123; UIApplication.shared.openURL(NSURL(string : \"\\(UIApplication.openSettingsURLString)com.Qussk.tokki\" )! as URL) &#125;&#125;&#125; com.Qussk.tokki 은 프로젝트 번들 이름! (identifier) 사용자권한 허용 유도할 때 주로 사용 !","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"sharedApplication","slug":"sharedApplication","permalink":"https://qussk.github.io/tags/sharedApplication/"}]},{"title":"[Swift]UITest 진행","slug":"Swift-UITest-진행","date":"2020-08-12T16:12:49.000Z","updated":"2020-09-14T08:28:54.135Z","comments":false,"path":"2020/08/13/Swift-UITest-진행/","link":"2020/08/12/Swift-UITest-진행","permalink":"https://qussk.github.io/2020/08/13/Swift-UITest-%EC%A7%84%ED%96%89/","excerpt":"","text":"나중에 다듬으기루… 시작하기 하단의 + 버튼을 누른다. UI Testing Bundle 을 생성한다. 상단에 test로 검색하면 빠르게 찾을 수 있다. 프로젝트명+Test.Swift이 생성된다. 들어가면 테스트 할 수 있는 에딧창이 뜬다. 넘버라인쪽에 다이아몬드모양을 누르면 해당 메소드가 실행된다. 아랫것을 누르게 되면 위에서 부터 아래로 순차적으로 실행된다. 단축키는 cmd + U 로 자동실행 할 수 있다. 테스트가 성공적이면 이런 화면이 뜬다. 아래 녹화를 누르면 tap()한 순서에 따라 코드가 자동적으로 작성된다. 실행 XCUIApplication의 경우 accessibilityIdentifier로 식별. UITableView 예시) 1let firstCell &#x3D; app.tables.cells.staticTexts[&quot;WWDC보기&quot;] 셀에 직접 접근 .tap() 을 주면 클릭됨 12 if firstCell.waitForExistence(timeout: 1)&#123;&#x2F;&#x2F;if addButton.isHittable&#125; 시간차 주면서 버튼으로 옮김 1self.app.tables.cells.element(boundBy: 0).tap() 엘리먼트로 접근가능. XCUIElement tap() dubleTap Press swipeUp/Down/Left/Right typeText 잠자기 1sleep(1) 비동기작업 1XCTAssertTrue(self.userlist.count) TextView, TextField의 경우 1234let textView &#x3D; app.textViews[&quot;textView&quot;]textView.tap() &#x2F;&#x2F;텍스뷰하기전에 꼭 탭을 해야함. 필드도 마찬가지textView.typeText(&quot;안녕하세요&quot;)&#x2F;&#x2F;키보드올리기 귀찮을때 이렇게 써서 테스트해볼수 있다. //Recording UI Test 주의사항 중복 코드가 있는 경우 코드가 구현되어 있지 않은 경우 XCUIElementQuery staticTexts firstMatch element(boundBy:) waitForExistence Assertion Method XCTAssertTrue(true) XCTAssertFalse(false) XCTAssertNil(true) XCTAssertNotNil(true) XCTAssertEqual(true, true) isHittable 화면이 존재하고 클릭가능한지의 여부 exists 화면이 존재하는지 여부","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"UITest","slug":"UITest","permalink":"https://qussk.github.io/tags/UITest/"}]},{"title":"[Swift]FireBase이용하여 faceBook로그인","slug":"Swift-FireBase이용하여-faceBook로그인","date":"2020-08-11T16:58:51.000Z","updated":"2020-09-14T08:28:54.121Z","comments":false,"path":"2020/08/12/Swift-FireBase이용하여-faceBook로그인/","link":"2020/08/11/Swift-FireBase이용하여-faceBook로그인","permalink":"https://qussk.github.io/2020/08/12/Swift-FireBase%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-faceBook%EB%A1%9C%EA%B7%B8%EC%9D%B8/","excerpt":"","text":"","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"FireBase","slug":"FireBase","permalink":"https://qussk.github.io/tags/FireBase/"},{"name":"FaceBook","slug":"FaceBook","permalink":"https://qussk.github.io/tags/FaceBook/"}]},{"title":"[Swift] FierBase 로그인/로그아웃","slug":"Swift-FierBase-로그인-로그아웃","date":"2020-08-11T16:58:10.000Z","updated":"2020-09-14T08:28:54.120Z","comments":false,"path":"2020/08/12/Swift-FierBase-로그인-로그아웃/","link":"2020/08/11/Swift-FierBase-로그인-로그아웃","permalink":"https://qussk.github.io/2020/08/12/Swift-FierBase-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EB%A1%9C%EA%B7%B8%EC%95%84%EC%9B%83/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"[Swift] FierBase 실시간 데이터 베이스","slug":"Swift-FierBase-실시간-데이터-베이스","date":"2020-08-11T15:01:01.000Z","updated":"2020-09-14T08:28:54.121Z","comments":false,"path":"2020/08/12/Swift-FierBase-실시간-데이터-베이스/","link":"2020/08/11/Swift-FierBase-실시간-데이터-베이스","permalink":"https://qussk.github.io/2020/08/12/Swift-FierBase-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B2%A0%EC%9D%B4%EC%8A%A4/","excerpt":"","text":"흑ㄷ흑 짱난다… https://firebase.google.com/docs/database/ios/start?hl=ko","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/tags/ios/"},{"name":"FierBase","slug":"FierBase","permalink":"https://qussk.github.io/tags/FierBase/"}]},{"title":"[Swift]Textfield 터치시 키보드내리기, 리턴시 커서이동(resignFirstResponder())","slug":"Swift-Textfield-터치시-키보드내리기-리턴시-커서이동","date":"2020-08-09T16:10:42.000Z","updated":"2020-09-14T08:28:54.133Z","comments":false,"path":"2020/08/10/Swift-Textfield-터치시-키보드내리기-리턴시-커서이동/","link":"2020/08/09/Swift-Textfield-터치시-키보드내리기-리턴시-커서이동","permalink":"https://qussk.github.io/2020/08/10/Swift-Textfield-%ED%84%B0%EC%B9%98%EC%8B%9C-%ED%82%A4%EB%B3%B4%EB%93%9C%EB%82%B4%EB%A6%AC%EA%B8%B0-%EB%A6%AC%ED%84%B4%EC%8B%9C-%EC%BB%A4%EC%84%9C%EC%9D%B4%EB%8F%99/","excerpt":"","text":"delegate = slef선언 12idTextField.delegate = selfpwTextField.delegate = self UITextFieldDelegate 123456789101112131415161718extension ViewController: UITextFieldDelegate &#123; //1.리턴시 다음 텍필로 커서 이동 ~ 이후 종료와 로그인 액션으로 접근 func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool &#123; if textField == idTextField &#123; pwTextField.becomeFirstResponder() &#125; else if textField == pwTextField &#123; loginButtonAction() pwTextField.resignFirstResponder() &#125; return true &#125; //2. 화면터치시 키보드 종료 override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; self.pwTextField.resignFirstResponder() self.idTextField.resignFirstResponder() &#125;&#125; 1. textFieldShouldReturn은 리턴시 수행할 메서드를 정의합니다. 1-1. textField가 idTextField일 경우 pwTextField.becomeFirstResponder()을 호출합니다. 1-2. textField가 pwTextField일 경우 pwTextField.resignFirstResponder()을 호출합니다. resignFirstResponder는 텍스트필드의 현재상태를 포기했다는 요청을 리시버에게 알려주고, 키보드가 자동으로 내려가게 합니다. 1-3. loginButtonAction()을 호출하여, 로그인 버튼에 접근합니다. 참고 : resignFirstResponder() 화면전환 소스를 넣거나해두 됨… 2. touchesBegan 메서드를 통해 resignFirstResponder()호출하여 텍스트필드에 대한 현재상태 종료함.","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"UITextfield","slug":"UITextfield","permalink":"https://qussk.github.io/tags/UITextfield/"},{"name":"resignFirstResponder()","slug":"resignFirstResponder","permalink":"https://qussk.github.io/tags/resignFirstResponder/"}]},{"title":"[Swift]Contacts - 연락처 정보가져오기","slug":"Swift-Contacts-연락처-정보가져오기","date":"2020-08-08T09:52:18.000Z","updated":"2020-09-14T08:28:54.118Z","comments":false,"path":"2020/08/08/Swift-Contacts-연락처-정보가져오기/","link":"2020/08/08/Swift-Contacts-연락처-정보가져오기","permalink":"https://qussk.github.io/2020/08/08/Swift-Contacts-%EC%97%B0%EB%9D%BD%EC%B2%98-%EC%A0%95%EB%B3%B4%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0/","excerpt":"","text":"Contacts을 이용하여, 앱으로 연락처 정보를 가져오기,! 들어가기 전에 아래 CNContact에 대한 애플문서를 확인하자. 링크 : https://developer.apple.com/documentation/contacts/cncontact 문서를 요약하자면, 오른쪽의 정보들을 가져온다는 뜻. 나는 phoneNumbers와 class func descriptorForAllComparatorKeys() -&gt; CNKeyDescriptor (연락처 정렬 비교기에 필요한 모든 키를 가져옵니다.)을 이용해 fullname을 가져왔다. 자세한 내용은 아래 코드에서 주석으로 숫자를 달았는데, 코드와 비교해보면서 읽어보길 바란다! 1. ViewController 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134import UIKitimport Contactsclass ViewController: UIViewController &#123; let tableView = UITableView(frame: .zero, style: .grouped) var objects = [CNContact]() //1-1. override func viewDidLoad() &#123; super.viewDidLoad() tableView.dataSource = self tableView.delegate = self tableView.rowHeight = 80 tableView.backgroundColor = .white view.addSubview(tableView) tableView.register(testTableViewCell.self, forCellReuseIdentifier: \"testTableViewCell\") findContactsOnBackgroundThread &#123; (contacts) in self.objects = contacts! self.tableView.reloadData() &#125; tableView.translatesAutoresizingMaskIntoConstraints = false NSLayoutConstraint.activate([ tableView.topAnchor.constraint(equalTo: view.topAnchor), tableView.leadingAnchor.constraint(equalTo: view.leadingAnchor), tableView.trailingAnchor.constraint(equalTo: view.trailingAnchor), tableView.bottomAnchor.constraint(equalTo: view.bottomAnchor) ]) &#125; func findContactsOnBackgroundThread (_ completionHandler: @escaping (_ contacts:[CNContact]?)-&gt;()) &#123; DispatchQueue.global(qos: .background).async(execute: &#123; () -&gt; Void in //1-2. let keysToFetch = [CNContactFormatter.descriptorForRequiredKeys(for: .fullName), CNContactPhoneNumbersKey] as [Any] let fetchRequest = CNContactFetchRequest( keysToFetch: keysToFetch as! [CNKeyDescriptor]) /* This is the array of objects that will be passed into the completion block. And then retrieved as the objects array objects 배열이 데이터를 검색함. */ var contacts = [CNContact]() //1-3. CNContact.localizedString(forKey: CNLabelPhoneNumberiPhone) if #available(iOS 10.0, *) &#123; fetchRequest.mutableObjects = false &#125; else &#123; // Fallback on earlier versions &#125; //1-4. fetchRequest.unifyResults = true fetchRequest.sortOrder = .userDefault //연락처를 가져오는 중 에러남. 성공을 위해 do/try/catch block 필요. //1-5. do &#123; // For each CNContact in your phone... try CNContactStore().enumerateContacts(with: fetchRequest) &#123; (contact, stop) -&gt; Void in //연락처를 정렬 // If this contact has a phone number, append to the array if contact.phoneNumbers.count &gt; 0 &#123; contacts.append(contact) &#125; &#125; // Catch the error, if it exists &#125; catch let e as NSError &#123; print(e.localizedDescription) &#125; DispatchQueue.main.async(execute: &#123; () -&gt; Void in //완성되면 contacts 배열을 제공 completionHandler(contacts) &#125;) &#125;) &#125; &#125;//MARK: -UITableViewDataSourceextension ViewController: UITableViewDataSource&#123; func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return objects.count &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: \"testTableViewCell\", for: indexPath) as! testTableViewCell let contact = self.objects[indexPath.row] configureCell(cell, contact: contact) return cell &#125; &#125;extension ViewController: UITableViewDelegate&#123; func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123; return 80 &#125; func configureCell(_ cell: testTableViewCell, contact: CNContact) &#123; let formatter = CNContactFormatter() let contactPhoneNumber = (contact.phoneNumbers[0].value).value(forKey: \"digits\") as? String cell.personName.text = formatter.string(from: contact) cell.conditionMassge.text = contactPhoneNumber &#125;&#125; 일단 테스트용으로 만든거라… viewDidLoad가 빵빵 ㅎㅎ… 1-1. objects = CNContact 는 CNContact(연락처)의 배열을 담은 객체 1-2. 연락처비교 : class func descriptorForAllComparatorKeys() -&gt;. CNKeyDescriptor (연락처 정렬 비교기에 필요한 모든 키를 가져옴.) 1let keysToFetch = [CNContactFormatter.descriptorForRequiredKeys(for: .fullName), CNContactPhoneNumbersKey] as [Any] keysToFetch는 CNContactFormatter의 descriptorForRequiredKeys로 접근하여, .fullName을 가져오고 CNContactPhoneNumbersKey에도 접근하도록 하는 그릇이다. 이 그릇을 123456789101112131415161718192021222324252627 let fetchRequest = CNContactFetchRequest( keysToFetch: keysToFetch as! [CNKeyDescriptor])``` fetchRequest에CNContactFetchRequest(연락처를 일치시키기위한 술어) 에 CNKeyDescriptor의 배열을 업캐스팅하여 CNKeyDescriptor의 정보를 가져온다.CNKeyDescriptor에 대한 정보는 퀵헬퍼로 확인가능. ![](/image/Contact4.png) 이렇게 되어있었다 ! ...- 1-3. **연락처 데이터 현지화 : class func localizedString(forKey: String) -&gt; String지역화 된 연락처 속성 이름이 포함 된 문자열을 반환.** ```swiftCNContact.localizedString(forKey: CNLabelPhoneNumberiPhone) if #available(iOS 10.0, *) &#123; fetchRequest.mutableObjects = false &#125; else &#123; // Fallback on earlier versions &#125; localizedString은 문자열을 반환하는 용도, 그중 CNLabelPhoneNumberiPhone 핸드폰 번호를 가져와 반환시킨다. 만약 iOS10이하면, fetchRequest.mutableObjects = falese로 string의 값 뮤터블(변수) 변경불가능하게 처리 이전 버전의 폰이 왔을 때의 대비책인거 같다. 그런데 이미 프로젝트를 13이상에서만 다운할수 있도록 해놔서… ㅎㅎ 안써도될듯하지만… 공부해볼겸 ,!! 1-4. 123//1-4. fetchRequest.unifyResults = true fetchRequest.sortOrder = .userDefault unifyResults현재 연락처가 통합 연락처이고 지정된 식별자를 가진 연락처를 포함하는지 여부를 나타내는 Bool값. sortOrder 연락처의 정렬 순서를 나타냄 1-5. 연락처의 열거가 성공적으로 실행되었는지 판단. (ㅇㅖ외사항 처리) do/try/catch /block을 이용해 오류 판단. 123456789101112do &#123; //1-5. // For each CNContact in your phone... try CNContactStore().enumerateContacts(with: fetchRequest) &#123; (contact, stop) -&gt; Void in //연락처를 정렬 // If this contact has a phone number, append to the array if contact.phoneNumbers.count &gt; 0 &#123; contacts.append(contact) &#125; &#125; do 나는 try하겠다, CNContactStore()을 통해, enumerateContacts(연락처 가져 오기 요청과 일치하는 모든 연락처의 열거가 성공적으로 실행되었는지 여부를 나타내는 부울 값을 반환)에 접근 ~ fetchRequest(검색 기준을 지정하는 연락처 가져 오기 요청. )을 요청하여 (contact(성공), stop(오류))시 에 대한 정보 클로저 이용하여 성공 및 오류사항 정의. 만약 성공시, contact.phoneNumbers.count &gt; 0 { 이면 contxts.append(contact) 그냥 정렬한다는 소리… 1234567891011&#125; catch let e as NSError &#123; print(e.localizedDescription) &#125; DispatchQueue.main.async(execute: &#123; () -&gt; Void in //완성되면 contacts 배열을 제공 completionHandler(contacts) &#125;) &#125;) &#125; 만약 에러나면, e.localizedDescription을 프린트하고, 어씽크(시분할방식 - 비동기) 통해 completionHandler(비동기 완료시점)에 (contacts)반환 (Void를 반환)하여 오류가 반환됨. 이 메서드는 열거가 완료 될 때까지 기다리기 때문에, 결과가 없으면 블록이 호출되지 않고 메서드가 true를 반환한다. 모든 연락처를 한 번에 메모리에 보관하지 않고 모든 연락처를 가져오기 때문에 비용이 많이 든다. 연락처 가져 오기 요청과 일치하는 모든 연락처의 열거가 성공적으로 실행되면 true이고, 그렇지 않으면 거짓 휴… 동기/비동기를 다시 한번 훑어봐야겠다… 동기/비동기 참고하기 셀 부분은 그냥 코드보면 대충 무슨 뜻인지 알것이라 생각하고 cell로 넘어가자. 2. testTableViewCell 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import UIKitclass testTableViewCell: UITableViewCell &#123; let identifier = \"testTableViewCell\" let personImage = UIImageView() let personName = UILabel() let conditionMassge = UILabel() let inPerson = UIButton() // let personAddButton = UIButton() override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) &#123; super.init(style: style, reuseIdentifier: reuseIdentifier) selectionStyle = .none personImage.backgroundColor = .systemGray4 personImage.image = UIImage(systemName: \"person\") personImage.tintColor = .lightGray personImage.layer.cornerRadius = 15 contentView.addSubview(personImage) personName.text = \"이름\" // personName.font = UIFont.boldSystemFont(ofSize: 17) conditionMassge.font = UIFont(name: \"PingFangHK-Medium\", size: 17) contentView.addSubview(personName) conditionMassge.text = \"즐거운 하루~~ 빛나는 미래가 보여🐶\" conditionMassge.font = UIFont(name: \"PingFangHK-Thin\", size: 14) conditionMassge.textColor = .gray contentView.addSubview(conditionMassge) // conditionCheck.text = \"21분전\" inPerson.setTitle(\"+ 초대\", for: .normal) inPerson.titleLabel?.font = UIFont(name: \"PingFangHK-Medium\", size: 12) inPerson.setTitleColor(.black, for: .normal) inPerson.layer.borderColor = UIColor.black.cgColor inPerson.backgroundColor = .yellow inPerson.layer.borderWidth = 1 inPerson.layer.cornerRadius = contentView.frame.width/23 contentView.addSubview(inPerson) setConstrain() &#125; func setConstrain()&#123; 레이아웃은 생략.. ]) &#125; required init?(coder aDecoder: NSCoder) &#123; fatalError(\"init(coder:) has not been implemented\") &#125; &#125; 위의 vc가 연락처목록을 가져오는 tablewView였다면, estTableViewCell은 그에 대한 셀이다. 테스트용으로 만든것이라서… 변수명이 좀 헷깔릴 수 있는데 conditionMassge가 폰넘버에 해당된다. 원래 상태메세지 가져오는 걸 구현할 계획이었던거라… 번호는 사실 셀에 표현안되어도 되지만 눈으로 확인하기 위해 여기다가 뿌렸다…ㅋㅋㅋ… 아래 이미지를 보면 이해가 더 쉬울것 같다. 🙂 이러케 ㅎㅎ… 어쨌든 나는 이름과 폰넘버만 가져왔지만, 필드만 지정해주면 연락처상에 저장된 모든 데이터(NCContact)를 통해 메모,이메일, 기념일?등도 가져올 수 있다는점 !!! 그리고 폰넘버가 만약 2개 저장된 정보라면, 가장 상단에 있는 값을 가져온다는 점! 알아두면 좋을 듯 하다!","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"Contacts","slug":"Contacts","permalink":"https://qussk.github.io/tags/Contacts/"}]},{"title":"[Swift]Custom Tabbar","slug":"Swift-Custom-Tabbar","date":"2020-08-07T15:56:35.000Z","updated":"2020-09-14T08:28:54.120Z","comments":false,"path":"2020/08/08/Swift-Custom-Tabbar/","link":"2020/08/07/Swift-Custom-Tabbar","permalink":"https://qussk.github.io/2020/08/08/Swift-Custom-Tabbar/","excerpt":"","text":"UITabbarController에 구애받지 않고 ViewController로 Tabbar 만들기! 참고한 사이트 : https://milyo-codingstories.tistory.com/m/11 https://dvpzeekke.tistory.com/69 첫번째 방법은 vc에 tabbar를 만들고 스택뷰를 이용하여 버튼 -&gt; 화면 이동의 방식이고, 두번째 방법은 vc에 collectionView올려서 셀 클릭 -&gt; 화면 이동 의 방식인 거 같은데 난 첫번째 방법을 사용했다. ㅎㅎ 공유해주시는 분들 언제나 감사합니다 1. BaseView 베이스가 되는 UIView만들기 1234567891011121314151617181920212223242526272829import UIKitclass BaseView: UIView &#123; let titleLabel: UILabel = &#123; return UILabel() &#125;() /// TitleLabel의 AutoLayout 설정 func makeTitleLableConstraint() &#123; titleLabel.translatesAutoresizingMaskIntoConstraints = false NSLayoutConstraint.activate([ titleLabel.centerYAnchor.constraint(equalTo: centerYAnchor), titleLabel.centerXAnchor.constraint(equalTo: centerXAnchor) ]) &#125; override init(frame: CGRect) &#123; super.init(frame: frame) addSubview(titleLabel) makeTitleLableConstraint() &#125; required init?(coder aDecoder: NSCoder) &#123; super.init(coder: aDecoder) &#125;&#125; 일단 UIView하나가 필요하다. 화면을 담당하는 녀석. 가운데에 콘트롤러마다 &quot;Lable&quot;이 들어가고, 화면마다 lable의 text가 다른데, 어쨌든 그러한 점을 보면 BaseView를 타입캐스팅 해서 여러개의 콘트롤러들이 본인들 View에 상속을 받는 방식이다. 아래를 보면 조금 이해가 된다. 2. firstView ~ … TabbarItem에 해당될 vc만들기 12345678910111213141516import UIKitclass SNSViewController: UIViewController &#123; override func loadView() &#123; view = BaseView() guard let ownView = view as? BaseView else &#123; return &#125; ownView.titleLabel.text = \"First View\" &#125; &#125; 탭바아이템 3개짜리를 만든다면, 위와 같은 VC이 3개 필요하다. 나는 [chatVC, snsVC, mywriteVC ] 총 3개로 했다. 해당 vc에서의 view는 BaseView가 되고, 이것의 이름 정의는 ownView가 된다. 3. TabbarView TabbatView 디자인하기 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221import UIKitclass CustomTabbarView: UIView &#123; var buttonSize: CGFloat = 60 var buttonBackImageSize: CGFloat = 0 let contentView: UIView = &#123; let contentView = UIView() contentView.backgroundColor = .white return contentView &#125;() //탭바 아이템 let customTabBar: UITabBar = &#123; let customTabBar = UITabBar() customTabBar.backgroundImage = UIImage() customTabBar.shadowImage = UIImage() // customTabBar.barTintColor = UIColor(red: 251/255, green: 252/255, blue:157/255, alpha:1) // customTabBar.alpha = 0.5 return customTabBar &#125;() let leftStack: ButtonStack = &#123; return ButtonStack() &#125;() let centerButtonBackImage: UIImageView = &#123; return UIImageView() &#125;() let centerButton: UIButton = &#123; return UIButton() &#125;() func makeContentViewConstraint() &#123; contentView.translatesAutoresizingMaskIntoConstraints = false NSLayoutConstraint.activate([ contentView.centerXAnchor.constraint(equalTo: centerXAnchor), contentView.widthAnchor.constraint(equalTo: widthAnchor), contentView.topAnchor.constraint(equalTo: topAnchor), contentView.bottomAnchor.constraint(equalTo: bottomAnchor), ]) &#125; func makeCustomTabBarConstraint() &#123; customTabBar.translatesAutoresizingMaskIntoConstraints = false NSLayoutConstraint.activate([ customTabBar.bottomAnchor.constraint(equalTo: safeAreaLayoutGuide.bottomAnchor, constant: -20), customTabBar.centerXAnchor.constraint(equalTo: centerXAnchor), // customTabBar.heightAnchor.constraint(equalToConstant: 44), customTabBar.widthAnchor.constraint(equalTo: widthAnchor), ]) &#125; func makeStackConstraint(targetStack: UIView) &#123; targetStack.translatesAutoresizingMaskIntoConstraints = false NSLayoutConstraint.activate([ targetStack.heightAnchor.constraint(equalTo: customTabBar.heightAnchor), targetStack.widthAnchor.constraint(equalTo: customTabBar.widthAnchor,multiplier: 1), targetStack.centerYAnchor.constraint(equalTo: customTabBar.centerYAnchor) ]) &#125; func makeLeftStackConstraint() &#123; leftStack.leadingAnchor.constraint(equalTo: customTabBar.leadingAnchor,constant: 16).isActive = true &#125; //버튼 back이미지 func makeCenterButtonBackImageConstraint() &#123; centerButtonBackImage.translatesAutoresizingMaskIntoConstraints = false NSLayoutConstraint.activate([ centerButtonBackImage.trailingAnchor.constraint(equalTo: customTabBar.trailingAnchor, constant: -16), centerButtonBackImage.widthAnchor.constraint(equalToConstant: buttonBackImageSize), centerButtonBackImage.heightAnchor.constraint(equalTo: centerButtonBackImage.widthAnchor), centerButtonBackImage.topAnchor.constraint(equalTo: customTabBar.topAnchor, constant: -(buttonBackImageSize/2)) ]) &#125; func makeCenterButtonConstraint() &#123; centerButton.translatesAutoresizingMaskIntoConstraints = false NSLayoutConstraint.activate([ centerButton.centerXAnchor.constraint(equalTo: centerButtonBackImage.centerXAnchor), centerButton.centerYAnchor.constraint(equalTo: centerButtonBackImage.centerYAnchor), centerButton.widthAnchor.constraint(equalToConstant: buttonSize), centerButton.heightAnchor.constraint(equalTo: centerButton.widthAnchor), centerButton.topAnchor.constraint(equalTo: customTabBar.topAnchor, constant: -(buttonSize/2)) ]) &#125; func makeView() &#123; addSubview(contentView) addSubview(customTabBar) addSubview(leftStack) addSubview(centerButtonBackImage) addSubview(centerButton) &#125; func makeItemConstraints() &#123; makeContentViewConstraint() makeCustomTabBarConstraint() makeStackConstraint(targetStack: leftStack) makeLeftStackConstraint() makeCenterButtonBackImageConstraint() makeCenterButtonConstraint() &#125; func makeCircleBackButtonImage() &#123; centerButtonBackImage.backgroundColor = UIColor(red: 251/255, green: 252/255, blue:157/255, alpha:1.0) centerButtonBackImage.layer.cornerRadius = buttonBackImageSize / 2 &#125; func makeCircleBackButton() &#123; centerButton.backgroundColor = .clear//UIColor(red: 251/255, green: 252/255, blue:157/255, alpha:1.0) centerButton.setImage(UIImage(systemName: \"camera.viewfinder\", withConfiguration: UIImage.SymbolConfiguration(pointSize: 24, weight: .bold, scale: .large)), for: .normal) centerButton.tintColor = UIColor.lightGray centerButton.layer.cornerRadius = buttonSize / 2 &#125; func makeLabelTitle() &#123; [leftStack.firstButton,leftStack.secondButton, leftStack.threeButton].forEach&#123; $0.backgroundColor = .clear $0.backgroundColor = UIColor(red: 251/255, green: 252/255, blue:157/255, alpha:1) $0.tintColor = UIColor.white // $0.alpha = 0.5 $0.setPreferredSymbolConfiguration(.init(scale: .large), forImageIn: .normal) &#125; //symbols 디자인 leftStack.firstButton.setImage(UIImage(systemName: \"bubble.left.and.bubble.right.fill\", withConfiguration: UIImage.SymbolConfiguration(pointSize: 24, weight: .bold, scale: .large)), for: .normal) leftStack.secondButton.setImage(UIImage(systemName: \"timer\",withConfiguration: UIImage.SymbolConfiguration(pointSize: 24, weight: .bold, scale: .large)), for: .normal) leftStack.threeButton.setImage(UIImage(systemName: \"person\",withConfiguration: UIImage.SymbolConfiguration(pointSize: 24, weight: .bold, scale: .large)), for: .normal) leftStack.vecLable.text = \"\" leftStack.vecLable.frame = CGRect(x: 0, y: 0, width: 40, height: 50) leftStack.vecLable.backgroundColor = UIColor(red: 251/255, green: 252/255, blue:157/255, alpha:1) // leftStack.vecLable.alpha = 0.5 &#125; func linkTagNumber() &#123; leftStack.firstButton.tag = 0 leftStack.secondButton.tag = 1 leftStack.threeButton.tag = 2 leftStack.vecLable.tag = 3 &#125; override init(frame: CGRect) &#123; super.init(frame: frame) buttonBackImageSize = buttonSize + 10 makeView() makeItemConstraints() makeLabelTitle() makeCircleBackButtonImage() makeCircleBackButton() linkTagNumber() &#125; required init?(coder aDecoder: NSCoder) &#123; super.init(coder: aDecoder) &#125;&#125;class ButtonStack: UIView &#123; let buttonStackView: UIStackView = &#123; let buttonStackView = UIStackView() buttonStackView.axis = .horizontal buttonStackView.distribution = .fillEqually return buttonStackView &#125;() let firstButton: UIButton = &#123; return UIButton() &#125;() let secondButton: UIButton = &#123; return UIButton() &#125;() let threeButton: UIButton = &#123; return UIButton() &#125;() let vecLable: UILabel = &#123; return UILabel() &#125;() override init(frame: CGRect) &#123; super.init(frame: frame) addSubview(buttonStackView) buttonStackView.translatesAutoresizingMaskIntoConstraints = false NSLayoutConstraint.activate([ buttonStackView.widthAnchor.constraint(equalTo: widthAnchor), buttonStackView.heightAnchor.constraint(equalTo: heightAnchor), buttonStackView.centerXAnchor.constraint(equalTo: centerXAnchor), buttonStackView.centerYAnchor.constraint(equalTo: centerYAnchor), ]) buttonStackView.addArrangedSubview(firstButton) buttonStackView.addArrangedSubview(secondButton) buttonStackView.addArrangedSubview(threeButton) buttonStackView.addArrangedSubview(vecLable) &#125; required init?(coder aDecoder: NSCoder) &#123; super.init(coder: aDecoder) &#125; &#125; TabbarView에 대한 정보. 레이아웃, 디자인, addsubView, 모두 이쪽에서 해주면 된다. 카메라 버튼이 하나 있는 데, 그건 그냥 버튼일 뿐이고, 마치 탭바에 있는 것처럼 레이아웃을 잡아주면 되는 방식이다. vecLable는 스택뷰의 tag=3에 대한 정보인데, 거의 Nil이라고보면 된다. 이 위에 카메라 버튼 이 와야하는 부분이고, 스택뷰 비율 예쁘게 맞춰야해서… 버튼 추가보다 레이블을 추가하여 맞췄다. Tabbar 실선 없애기? 여기서 좀 헤맸는데, 일단 미리보여주자면, 위 코드로 작성되면 이렇게 나온다. (아직 탭바 콘트롤러 작성적이기 때문에 안보이실 것…) 아, 저 위에 검정 실선 너무 거슬려 해서 없애려한게 이 것의 발단… 123customTabBar.backgroundImage = UIImage()customTabBar.shadowImage = UIImage()// customTabBar.barTintColor = UIColor(red: 251/255, green: 252/255, blue:157/255, alpha:1) navigationvar생략도 약간 비슷한 방식으로 없애서, tabbar에 적용해보았더니 되었다 ㅋㅋ 그런데?? 옆에 애들이 날아갔다… 왜지?, ㅡㅡ;;;; 다시 부랴부랴 색을 채우려고 코드 이것저것 적용해보고… 결국 알파값을 0.5 씩 낮춰봤는데… 아… 탭바 위에 스택뷰 backgroundColor 때문에 동일하게 알파 0.5 씩 줬음에도, 탭바 부분은 0.5+0.5 가 겹쳐져 더 진하게 보인다. (틴트 컬러나 백그라운드 컬러에서 알파를 낮추는게 아니라, 탭바.알파 = 0.5 로 직접 적용해야함. 주석 보면 알 수 있음!!) 그렇다면 ? 일단, 실선을 없애려면 backgroundImage 와 shadowImage 를 줘야하는게 맞다. 그러면 tabbar에 대한 이미지 처리가 완전히 없어진 것이기 때문에, 스택뷰의 backgroundColor로 tabbar의 색을 대신해 주는 것이다. 그래서 노란 영역은 탭바가 아닌 스택뷰의 영역인 것…!!! 그래서 위에 vecLabel을 추가한 것이다… 간격 맞추려고… vacLable에 프레임도 주고 배경색도 동일하게 준 것 !! 눈이 아파서 일단 이 정도로 마무리… 디자인은 아직 나온게 아니니까… 이거하면서 느꼈다. 나 디자인 개못하구나…🐶 이제 마지막이다. Custom Tabbar 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import UIKitclass CustomTabbar: UIViewController &#123; var chatVC: ChatlistViewController? var snsVC: SNSViewController? var mywriteVC: MyWriteHistoryViewController? var vcList = [UIViewController]() var prevIndex: Int? @objc func linkAction(_ sender: UIButton) &#123; checkView() prevIndex = sender.tag moveView(sender.tag) &#125; /// 새로운 뷰를 만들기 전에 기본의 뷰가 있으면 그 뷰를 제거한다. func checkView() &#123; guard let prevSelectedIndex = prevIndex else &#123; return &#125; vcList[prevSelectedIndex].willMove(toParent: nil) vcList[prevSelectedIndex].view.removeFromSuperview() vcList[prevSelectedIndex].removeFromParent() &#125; /// 새로운 뷰로 이동한다. func moveView(_ index: Int) &#123; guard let targetView = view as? CustomTabbarView else &#123; return &#125; addChild(vcList[index]) targetView.contentView.addSubview(vcList[index].view) vcList[index].view.frame = targetView.contentView.bounds vcList[index].didMove(toParent: self) &#125; @objc func moveWriteView() &#123; let vc = CameraViewController() present(vc,animated: true) &#125; ///각 탭바의 아이템들을 액션에 연결한다. func linkTargetAction() &#123; guard let targetView = view as? CustomTabbarView else &#123; return &#125; targetView.leftStack.firstButton.addTarget(self, action: #selector(linkAction), for: .touchUpInside) targetView.leftStack.secondButton.addTarget(self, action: #selector(linkAction), for: .touchUpInside) targetView.leftStack.threeButton.addTarget(self, action: #selector(linkAction), for: .touchUpInside) targetView.centerButton.addTarget(self, action: #selector(moveWriteView), for: .touchUpInside) &#125; func makeViewList() &#123; guard let views = [chatVC, snsVC, mywriteVC] as? [UIViewController] else &#123; return &#125; vcList = views &#125; //탭바뷰 override func loadView() &#123; view = CustomTabbarView() &#125; override func viewDidLoad() &#123; chatVC = ChatlistViewController() snsVC = SNSViewController() mywriteVC = MyWriteHistoryViewController() makeViewList() linkTargetAction() &#125; /// 뷰가 로딩이 다 되고 난 뒤 기본 뷰를 셋팅한다. override func viewDidAppear(_ animated: Bool) &#123; if prevIndex == nil &#123; prevIndex = 0 moveView(0) &#125; &#125; &#125; 드디어 탭바컨트롤러!! 읽으면 대충 감은 온다… ㅎㅎ (이 부분은 포스팅 맨 위에 작성된 첫번째 방법 참고 링크를 보면 좀 더 이해가 쉽다.!!) 링크! 일단 이정도로 글을 마치고, 시간이 남으면 스크롤시 사라지는 것, tabbar아이템 클릭시의 애니매이션을 추가할 계획이다.","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"Tabbar","slug":"Tabbar","permalink":"https://qussk.github.io/tags/Tabbar/"}]},{"title":"weak self","slug":"POST/weak-self","date":"2020-08-07T15:47:19.000Z","updated":"2020-09-14T08:28:54.114Z","comments":false,"path":"2020/08/08/POST/weak-self/","link":"2020/08/07/POST/weak-self","permalink":"https://qussk.github.io/2020/08/08/POST/weak-self/","excerpt":"","text":"weak self 클로저함수 내부에서 self를 캡쳐하는 문법인거 같다 시간날때… 정리해보자. 참조 https://yagom.net/forums/topic/closure%EC%9D%98-weak-self-%EC%82%AC%EC%9A%A9%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A7%88%EB%AC%B8%EC%9E%85%EB%8B%88%EB%8B%A4/ https://greenchobo.tistory.com/3 http://minsone.github.io/mac/ios/rules-of-weak-and-unowned-in-swift -http://minsone.github.io/mac/ios/swift-automatic-reference-counting-summary","categories":[{"name":"post","slug":"post","permalink":"https://qussk.github.io/categories/post/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"공부","slug":"공부","permalink":"https://qussk.github.io/tags/%EA%B3%B5%EB%B6%80/"}]},{"title":"[Swift]SF Symbols 정리","slug":"Swift-SF-Sybols-정리","date":"2020-08-07T13:56:59.000Z","updated":"2020-09-14T08:28:54.129Z","comments":false,"path":"2020/08/07/Swift-SF-Sybols-정리/","link":"2020/08/07/Swift-SF-Sybols-정리","permalink":"https://qussk.github.io/2020/08/07/Swift-SF-Sybols-%EC%A0%95%EB%A6%AC/","excerpt":"","text":"개발할 때 자주 사용하는 SFSymbols ! 이번 기회에 확실히 정리하고자 한다. SFSymbols은 다양한 인터페이스를 지원한다. iOS13부터. SF symbols 사용 1centerButton.setImage(UIImage(systemName: \"camera.viewfinder\"), for: .normal) Size 조절 1centerButton.setPreferredSymbolConfiguration(.init(scale: .large), forImageIn: .normal) 스몰, 미디움, 라지가 있다. Font 조절 12leftStack.firstButton.setImage(UIImage(systemName: \"bubble.left.and.bubble.right.fill\", withConfiguration: UIImage.SymbolConfiguration(pointSize: 24, weight: .bold, scale: .large)), for: .normal) SymbolConfiguration에서 아래의 파라미터는 본인이 선택해서 쓰면 된다. 이것저것 찾아보다가 베타버전 다운받는 것도 있어서 아래 링크 첨부… SF 기호 2베타 다운로드","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"SFSymbols","slug":"SFSymbols","permalink":"https://qussk.github.io/tags/SFSymbols/"}]},{"title":"SDK와 API차이","slug":"POST/SDK와-API차이","date":"2020-08-05T08:47:00.000Z","updated":"2020-09-14T08:28:54.113Z","comments":false,"path":"2020/08/05/POST/SDK와-API차이/","link":"2020/08/05/POST/SDK와-API차이","permalink":"https://qussk.github.io/2020/08/05/POST/SDK%EC%99%80-API%EC%B0%A8%EC%9D%B4/","excerpt":"","text":"SDK와 API차이 쉽게 말하면, SDK는 특정 플랫폼을 대상으로하는 소프트웨어 응용 프로그램을 개발하는 데 사용할 수있는 도구 모음이다. SDK에는 프로그래머가 응용 프로그램을 개발하는 데 도움이되는 도구, 라이브러리, 설명서 및 샘플 코드가 포함되어 있다. 대부분의 SDK는 인터넷에서 다운로드 할 수 있으며 프로그래머가 SDK의 프로그래밍 언어를 사용하도록 장려하기 위해 많은 SDK가 무료로 제공되기도 한다. 예를들면,페이스북 SDK, 인스타 SDK, iOS SDK 등… 널리 사용되는 일부 SDK는 모든 라이브러리, 디버깅 유틸리티 등을 포함하는 Java SDK (JDK)로, Java에서 프로그램 작성을 훨씬 쉽게 해준다. SDK는 서로 호환되는 구성 요소 / 도구를 찾을 필요가없고 모든 패키지가 설치하기 쉬운 단일 패키지에 통합되어 있다. 그래서, API와의 가장 큰 차이는 SKD는 통합키트라는 개념이고, API는 소프트웨어 프로그램이 서로 상호 작용할 수있는 인터페이스라는 것이다. API는 서로 통신하기 위해 프로그램이 따라야하는 일련의 규칙을 정의하고, 일반적으로 두 응용 프로그램이 통신하기 위해 루틴, 데이터 구조 등을 정의하는 방법을 지정한다. API이 제공하는 기능은 Java API와 같은 프로그래밍 언어의 라이브러리 기능을 제공하는 일반 API가 있고, Google Maps API와 같은 특정 기능을 제공하는 API도 있다. 언어 별 API도 있으며 이는 특정 프로그래밍 언어에서만 사용할 수 있게 된다. 또한 여러 프로그래밍 언어와 함께 사용할 수있는 언어 독립적 인 API가 있다. 이 처럼, API는 필요한 기능이나 데이터 만 외부에 노출시키면서 응용 프로그램의 다른 부분에는 액세스 할 수 없도록한다. 일부 기능 및 데이터를 API를 통해 웹 외부로 허용하는 것이 매우 일반적인 사례이고, 이 기능은 사용자에게 향상된 기능을 제공하기 위해 개발자를 통해 결합 될 수 있게 된다. 정리하자면, API는 소프트웨어 프로그램이 서로 상호 작용할 수있는 인터페이스 인 반면 SDK는 특정 플랫폼을 대상으로하는 소프트웨어 응용 프로그램을 개발하는 데 사용할 수있는 도구 모음이라는 것. 가장 간단한 버전의 SDK는 특정 프로그래밍 언어와 상호 작용하는 데 필요한 일부 파일이 포함 된 API 일 수 있다. 따라서 API는 모든 디버깅 지원 등이없는 간단한 SDK로 볼 수 있다.","categories":[{"name":"post","slug":"post","permalink":"https://qussk.github.io/categories/post/"}],"tags":[{"name":"공부","slug":"공부","permalink":"https://qussk.github.io/tags/%EA%B3%B5%EB%B6%80/"}]},{"title":"[Swfit]FireBase이용하여 Google로그인 만들기","slug":"Swfit-FireBase이용하여-Google로그인-만들기","date":"2020-08-04T04:09:11.000Z","updated":"2020-09-14T08:28:54.115Z","comments":false,"path":"2020/08/04/Swfit-FireBase이용하여-Google로그인-만들기/","link":"2020/08/04/Swfit-FireBase이용하여-Google로그인-만들기","permalink":"https://qussk.github.io/2020/08/04/Swfit-FireBase%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-Google%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/","excerpt":"","text":"해당 앱에 구글아이디로 로그인 할 수 있도록 구현해보자 0. 사전 학습 Firebase 프로젝트를 만드는 과정에서 googleServicce를 받게 되는 데, 그것을 프로젝트로 옮긴 후 REVERSED_CLIENT_ID의 주소를 복사하여 아래의 url schemes에 붙여준다. 붙인 모습. 그럼 파이어베이스를 시작해보자. 1. FireBase - cocoapod에 init, install 1pod init 1-1. cocoapod에 해당 프로젝트 경로로 간 후, pod init 한다. 1pod 'GoogleSignIn' 1-2. Podfile가 만들어지면, Podfile을 열어서 위 코드를 추가한다. 1pod install 1-3. pod install로 변경사항 저장. (간단간단…) 2. AppDelegate 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import UIKitimport Firebaseimport GoogleSignIn@UIApplicationMainclass AppDelegate: UIResponder, UIApplicationDelegate, GIDSignInDelegate &#123; var window: UIWindow? func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123; setupKeyWindow() return true &#125; //1 @available(iOS 9.0, *) func application(_ application: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any]) -&gt; Bool &#123; return GIDSignIn.sharedInstance().handle(url) &#125; //2 func application(_ application: UIApplication, open url: URL, sourceApplication: String?, annotation: Any) -&gt; Bool &#123; return GIDSignIn.sharedInstance().handle(url) &#125; //3 func sign(_ signIn: GIDSignIn!, didSignInFor user: GIDGoogleUser!, withError error: Error?) &#123; // ... if let error = error &#123; // ... return &#125; guard let authentication = user.authentication else &#123; return &#125; let credential = GoogleAuthProvider.credential(withIDToken: authentication.idToken, accessToken: authentication.accessToken) //로그아웃 호출 추가(나중에) let firebaseAuth = Auth.auth() do &#123; try firebaseAuth.signOut() &#125; catch let signOutError as NSError &#123; print (\"Error signing out: %@\", signOutError) &#125; &#125; func setupKeyWindow() &#123; window = UIWindow(frame: UIScreen.main.bounds) window?.backgroundColor = .white window?.rootViewController = ViewController() window?.makeKeyAndVisible() FirebaseApp.configure() //4 GIDSignIn.sharedInstance().clientID = FirebaseApp.app()?.options.clientID GIDSignIn.sharedInstance().delegate = self &#125; &#125; 2-0. Firebase와 GoogleSignIn을 import한다. 2-1. FirebaseApp.configure() 는 초기화를 위한 필수 적인 메소드 2-2. GIDSignInDelegate 만 있어도 된다.(추가하는 것 잊지 않기) 2-3. 순서대로 쭉 붙여넣기 한다. 2-4. (주의)3부분에 아래에 //파이어베이스로 넘겨주는 부분의 코드도 추가해야한다. 이걸 추가 안했더니… 로그인은 된것처럼 보이는데, 아이디(메일주소) print해봤을때 nil값이 나오더라 ;;;;;… 늦게라도 발견해서 다행… 12345678910111213141516171819func sign(_ signIn: GIDSignIn!, didSignInFor user: GIDGoogleUser!, withError error: Error?) &#123;guard error == nil else &#123; if let error = error &#123; print(\"구글로그인에 실패함 \\(user)\") &#125; return&#125;guard let authentication = user.authentication else &#123; return &#125;let credential = GoogleAuthProvider.credential(withIDToken: authentication.idToken, accessToken: authentication.accessToken)//파이어베이스로 넘겨주는 부분Auth.auth().signIn(with: credential) &#123;(user, error) in if let error = error &#123; return &#125;&#125; 3. ViewController 12345678910111213import UIKitimport Firebaseimport GoogleSignInclass ViewController: UIViewController,GIDSignInDelegate &#123;override func viewDidLoad() &#123;super.viewDidLoad()GIDSignIn.sharedInstance()?.presentingViewController = selfGIDSignIn.sharedInstance().signIn() //회원가입 신청하는 코드&#125; 3-1. viewDidLoad에 위 2줄을 추가한다. 3-2. 회원가입 신청하는 코드는 앞으로 구현될 “구글로그인” Buttond의 Action에 옮겨적는다. 위에 것은 지우고 12345678910 //Google Loginfunc sign(_ signIn: GIDSignIn!, didSignInFor user: GIDGoogleUser!, withError error: Error?) &#123; if let error = error &#123; return &#125; guard let authentication = user.authentication else &#123; return &#125; let credential = GoogleAuthProvider.credential(withIDToken: authentication.idToken, accessToken: authentication.accessToken)&#125; 3-3. 위 코드는 GIDSignInDelegate에 대한 프로토콜 4.View(Button이 위치하는 곳) 여기서 선택사항이 있는데, Google이 로그인버튼 이미지를 GIDSignInButton라는 이름으로 지원을 해준다. 1let googleButton = GIDSignInButton() 그런데 직접 커스텀 하기를 추천…(안이쁨) 커스텀은 그냥 일반적으로 Button을 만들고 setBackgroundImage로 원하는 이미지로 로고를 주면 된다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import UIKitimport Firebaseimport GoogleSignInclass LoginView : UIView&#123; //let googleButton = GIDSignInButton() let googleButton = UIButton() override init(frame: CGRect) &#123; super.init(frame: frame) commonInit() setUI() constrain() &#125; required init?(coder: NSCoder) &#123; super.init(coder: coder) &#125; func commonInit()&#123; let viewXib = Bundle.main.loadNibNamed(\"LoginView\", owner: self, options: nil)![0] as! UIView viewXib.frame = self.bounds viewXib.backgroundColor = .white viewXib.layer.cornerRadius = 20 addSubview(viewXib) &#125; func setUI()&#123; googleButton.setBackgroundImage(UIImage(named: \"dd\"), for: .normal) googleButton.addTarget(self, action: #selector(googleLoginAction(_ :)), for: .touchUpInside) addSubview(googleButton) &#125; @objc func googleLoginAction(_ sender: UIButton)&#123; GIDSignIn.sharedInstance().signIn() //회원가입 신청하는 코드 &#125; func constrain()&#123; googleButton.translatesAutoresizingMaskIntoConstraints = false NSLayoutConstraint.activate([ googleButton.centerXAnchor.constraint(equalTo: centerXAnchor), googleButton.centerYAnchor.constraint(equalTo: centerYAnchor), googleButton.widthAnchor.constraint(equalToConstant: 47), googleButton.heightAnchor.constraint(equalToConstant: 47) ]) &#125;&#125; 4-1. 현재 Xib로 실험해 볼게 많아서 XiBView위에 버튼을 올린 꼴이라 헷깔릴 수도 있는데, 굳이 그것만 빼고 버튼 부분만 보시면 이해가 될거다… 4-2. ButtonAction부분으로 회원가입 신청하는 코드를 가져왔다. 그리고 빌드해보면 아래와 같은 화면을 확인할 수 있다 ! 첫번째 화면의 버튼은 내가 비추천 했던 구글 디폴트 버튼이미지(GIDSignInButton)이다… ㅎㅎ 보고 선택… 엿튼, 위의 모든 과정을 마치게 되면, firebase에 Authentication에 '이메일/비밀번호’와 '구글’에 사용설정 됨을 확인 할 수 있다. firebase에 google로그인에 대한 공식가이드가 있으니 아래도 참고해보고 도움되길 바란다! 참고 :https://firebase.google.com/docs/auth/ios/google-signin?hl=ko#swift_5","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"FireBase","slug":"FireBase","permalink":"https://qussk.github.io/tags/FireBase/"},{"name":"GoogleLogin","slug":"GoogleLogin","permalink":"https://qussk.github.io/tags/GoogleLogin/"}]},{"title":"[라이브러리]paper-onboarding","slug":"라이브러리-paper-onboarding","date":"2020-07-30T20:11:37.000Z","updated":"2020-09-14T08:28:54.150Z","comments":false,"path":"2020/07/31/라이브러리-paper-onboarding/","link":"2020/07/30/라이브러리-paper-onboarding","permalink":"https://qussk.github.io/2020/07/31/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-paper-onboarding/","excerpt":"","text":"paper-onboarding https://github.com/Ramotion/paper-onboarding 예쁜 온보딩 화면을 구현해주는 라이브러리다 몬가 색깔 바뀌는 게 예뻐서 한 번 써보고 싶은 라이브러리였다! 그런데 디자이너분들이 색을 하나로 통일하자고 해서, 티가 안난당…(왜 썼,.) 이왕 쓰게 된 거 포스트 !! 나는 cocoapod을 사용하지 않고 Swift Package Manager를 사용했다. SwiftPackageManager가 git 협업하기에도 좋고 파일 정리가 훨씬 깔끔해서 cocoapod은 지양하고 있다. 1.import 1import paper-onboarding 2.선언 12345678910//선언let onboarding = PaperOnboarding()override func viewDidLoad() &#123; super.viewDidLoad() onboarding.dataSource = selfonboarding.delegate = self&#125; 3.setup Onboarding 1234567891011121314151617181920 //MARK: - Onboarding func setupOnboarding()&#123; view.backgroundColor = .white view.addSubview(onboarding) onboarding.translatesAutoresizingMaskIntoConstraints = false for attribute: NSLayoutConstraint.Attribute in [.left, .right, .top, .bottom] &#123; let constraint = NSLayoutConstraint(item: onboarding, attribute: attribute, relatedBy: .equal, toItem: view, attribute: attribute, multiplier: 1, constant: 0) view.addConstraint(constraint) &#125; &#125; &#125; 4. PaperOnboardingDataSource(기본값 지정) 123456789101112131415161718192021222324252627282930313233343536373839404142//MARK:-PaperOnboardingDataSourceextension OnboardingViewController: PaperOnboardingDataSource &#123; func onboardingItem(at index: Int) -&gt; OnboardingItemInfo &#123; let titleFont = UIFont(name: \"AvenirNext-Bold\", size: 24)! let descirptionFont = UIFont(name: \"AvenirNext-Regular\", size: 18)! return [OnboardingItemInfo(informationImage: UIImage(named:\"back\")!, title: \"확실한 분리수거\", description: \"폐기물 처리 가이드를 통해\\n궁금했던 분리수거 방법을 알아보세요.\\n잘못된 분리수거 방법을 바로 잡아요\", pageIcon: UIImage(named:\"on\")!, color: UIColor.white, titleColor: UIColor.black, descriptionColor: UIColor.black, titleFont: titleFont, descriptionFont: descirptionFont), OnboardingItemInfo(informationImage: UIImage(named:\"back\")!, title: \"집 앞에서 픽업\", description: \"잠들기 전, 집 문 앞에 폐기물을 놓아두고\\n쓸애기 서비스를 이용해보세요.\\n잠든 사이에 빠르게 수거해 갈게요.\", pageIcon: UIImage(named:\"on\")!, color: UIColor.white, titleColor: UIColor.black, descriptionColor: UIColor.black, titleFont: titleFont, descriptionFont: descirptionFont), OnboardingItemInfo(informationImage: UIImage(named:\"back\")!, title: \"새롭게 재탄생!\", description: \"정성껏 분리수거된 재활용 폐기물은\\n종류별로 나눠져 재활용 업체에 넘어갑니다\\n나의 작은 노력 하나로 깨끗한 지구를 만들어요!\", pageIcon: UIImage(named:\"on\")!, color: UIColor.white, titleColor: UIColor.black, descriptionColor: UIColor.black, titleFont: titleFont, descriptionFont: descirptionFont) ][index] &#125; func onboardingItemsCount() -&gt; Int &#123; return 3 &#125; 4-1. onboardingItemsCount는 딱 봐도 온보딩페이지 갯수다. 난 3개 4-2. title,description,pageIcon…등 역시 화면만 보아도 매칭이 되서 딱 알것이다. 4-3. informationImage가 온보딩페이지의 메인 이미지라고 보면되는데, 나는 백터이미지를 넣어놓은 상태다. 왜냐면, 이게 라이브러리라서 사이즈가 이미 정해져서 나와 변경할 수가 없당… 사실 gif넣을 계획이었는데 시간이 부족해서…그냥 Image로 넣기로 한것T T… 디자이너가 바라는 사이즈가 안나와서 해당 카테고리에는 백터이미지를 넣고, 온보딩위에 새로운 UIImageView를 올려서 그것을 처리했다… (왜썻…2…) 5. Action 123456789101112//MARK:- Action@objc func buttonClicked(_ sender: UIButton)&#123; let adressVC = AddressViewController() let adressNV = UINavigationController(rootViewController: adressVC) adressNV.modalPresentationStyle = .fullScreen present(adressNV, animated: false) &#125;&#125; 5-1. 위 코드는 3번째 온보딩 화면에서 시작하기 버튼의 메서드이다. 누르면 앱의 주소입력 화면으로 넘어간당 6. PaperOnboardingDelegate 12345678910111213141516171819202122232425262728293031323334353637383940//MARK:-PaperOnboardingDelegateextension OnboardingViewController: PaperOnboardingDelegate &#123; func onboardingConfigurationItem(_: OnboardingContentViewItem, index _: Int) &#123; &#125; func onboardingWillTransitonToIndex(_ index: Int) &#123; if index == 0 &#123; if self.getButton.alpha == 1 &#123; UIView.animate(withDuration: 0.1, animations: &#123; self.getButton.alpha = 0 &#125;) &#125; &#125; &#125; func onboardingDidTransitonToIndex(_ index: Int) &#123; if index == 0 &#123; UIView.animate(withDuration: 0.1, animations: &#123; self.onboardingImage.alpha = 1 self.onboardingImage.image = UIImage(named: \"on1\") &#125;) &#125;else if index == 1 &#123; UIView.animate(withDuration: 0.1, animations: &#123; //self.onboardingImage.alpha = 0 self.onboardingImage.image = UIImage(named: \"on2\") &#125;) &#125; else &#123; UIView.animate(withDuration: 0.2, animations: &#123; self.onboardingImage.image = UIImage(named: \"on3\") self.getButton.alpha = 1 &#125;) &#125; &#125; &#125; 6-1. PaperOnboardingDelegate에서 alpha을 이용해 Button은 3번째 화면에서만 보이도록 구현 6-2. 온보딩 페이지별로 onboardingImage 다르게 처리해주기 까지 하면 완성 ! 완성모습 영상보기 https://youtu.be/LzJhSUQ_8i8","categories":[{"name":"Library","slug":"Library","permalink":"https://qussk.github.io/categories/Library/"}],"tags":[{"name":"paper-onboarding","slug":"paper-onboarding","permalink":"https://qussk.github.io/tags/paper-onboarding/"}]},{"title":"[Swift]Xib이용예제(sb: customUI)","slug":"Swift-customUIView-만들기","date":"2020-07-25T15:18:31.000Z","updated":"2020-09-14T08:28:54.138Z","comments":false,"path":"2020/07/26/Swift-customUIView-만들기/","link":"2020/07/25/Swift-customUIView-만들기","permalink":"https://qussk.github.io/2020/07/26/Swift-customUIView-%EB%A7%8C%EB%93%A4%EA%B8%B0/","excerpt":"","text":"Xib로 customa UIView를 구현하는 방식. 첫 발단은 기술면접 보면서 customUI만들어본적 있냐고 했을 때, 아, MVC 패턴 말하는 거냐고?? 물어봤는데, 정색하면서 아니라고 해서 공부시작… Xib/Nib 의 존재를 알게 되었고 적용해봄. 결론은 내가생각 했던 커스텀 이 아니라, 그냥 스토리보드 상에서 사용하는 UIView~~였음… ㅡㅡ, 그래서 좀 실망한 부분… 1. UIView 먼저, customView가 될, UIView를 하나 만든다. 시험삼아 레이블 1개,버튼 1개가 있는 커스텀 뷰를 만들 것이다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import UIKitclass MyView: UIView &#123; let myLable = UILabel() let mybutton = UIButton() override init(frame: CGRect) &#123; super.init(frame: frame) commonInit() setUI() constrain() &#125; required init?(coder: NSCoder) &#123; super.init(coder: coder) &#125; func commonInit()&#123; let viewXib = Bundle.main.loadNibNamed(\"MyView\", owner: self, options: nil)![0] as! UIView viewXib.frame = self.bounds viewXib.backgroundColor = .white viewXib.layer.cornerRadius = 20 addSubview(viewXib) &#125; func setUI()&#123; myLable.text = \"dd\" addSubview(myLable) mybutton.setTitle(\"버튼\", for: .normal) mybutton.setTitleColor(.red, for: .normal) addSubview(mybutton) &#125; func constrain()&#123; [myLable,mybutton].forEach &#123; $0.translatesAutoresizingMaskIntoConstraints = false &#125; NSLayoutConstraint.activate([ myLable.centerXAnchor.constraint(equalTo: centerXAnchor), myLable.centerYAnchor.constraint(equalTo: centerYAnchor), mybutton.topAnchor.constraint(equalTo: myLable.bottomAnchor), mybutton.centerXAnchor.constraint(equalTo: centerXAnchor), ]) &#125;&#125; 1-1. override init과 required init?은 일반 MVC와 동일하다. 1-2. 습관처럼 view.addsubview~~ 쓰려고 했는데 이미 view라서 view쓰면 오류난다. addsubView으로 그냥으로 처리… 1-3. 다른점은 commonInit 부분인데, commonInit함수가 UIview불러오는 함수다. 1-4. loadNibNamed 이 해당 xib파일의 클래스 이름을 가져와준다. Bundle.main으로?.. &quot;MyView&quot;는 xib클래스 이름! xib 이 뭐야 !!😡 라고 묻는 다면 아래를 보시라. 늦어서 미안… 2. xib만들기 2-1. cmd + n 으로 새로만들기 진행후 아래 View를 선택 스토리보드 비스무리한 게 나올텐데 우리는 코드로 하자구, , , 2-2. class이름만 지정하도록 한다. (스토리 보드로 할거라면, 위의 코드에 레이블과 버튼을 모두 @IBOulet처리 하면된다. 그리고 스토리 보드에 꾸미면 됨… 이건 다른 블로그에도 많으니까…) 그런데 파일에 직접 들어가서 class이름을 하나하나 부여하는 것도 번거로운것 같은데… 아마 다른 방법이 있긴 할 것같은데… 다음에 더 알아보기로… (지금은 궁금증해소가 먼저,) 알아본 결과: 그냥 애초에 스토리보드용이라서 그러는 거 같다 ㅋㅋㅋ 그런거 없음 2-3. 파일명도 customView와 동일하게 지정해줬다면 끝! (혼돈이 오지 않게) commonInit 함수에 viewXib 가 customView가 된다. viewXib.backgroundColor = .white 로 지정하여 구분! 3.ViewController 제작한 customView(MyUIView.swift)를 ViewController에 가져오기. 123456789101112import UIKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let customView = MyView(frame: CGRect(x: 0, y: 0, width: view.frame.width, height: view.frame.height)) view.backgroundColor = .yellow self.view.addSubview(customView) &#125;&#125; 3-1. customView의 크기는 ViewController에서 한답 일단 이정도로 해주면 ? vc위에 해당 frame 값으로 customView가 위치한 모습을 볼 수 있다. 스냅챗처럼 커스텀뷰인거 티내려고 cornerRadius = 20을 줬던건데… 생각해보니 일반 view에 cornerRadius가 안먹었었나 !? ㅡㅡ 문득 생각이 들어 vc에도 cornerRadius을 줘봤다… 결과는,? 아,… 원래 되는거구나 그냥 일반 view에서도… ((((배신감))))… 난 뭘한거지… 🤔 현재 수치 ㅋ… 구분하기 쉽게… 12view.laye.cornerRadius &#x3D; 10viewXib.layer.cornerRadius &#x3D; 20 아니 그럼 내가 믿었던 건 뭐지 ㅠㅠ… 근데 스냅챗은 뒤에가 검정색인데 ? …!! ㅎㅎ… SceneDelegate가서 window 색을 black으로 바꾸어 보았다… 1window?.backgroundColor &#x3D; .black 결과는 … ? ? ? 앗… 뭔가 원했던 그림이랑 비슷하게 나왔다 ㅋㅋ… 이제야 궁금증이 해소된… 하… 근데 면접자분 피셜, 현역에서도 customUI를 제대로 다루는 사람을 본적이 없다고 하셨따… (네이버10년 배민 2년경력이신…) 흠… 좀 더 연구해보기로… 일단 더 주어진 생각은 버튼에 액션도 달기 아, 액션도 그냥 달면된다… 특별할거 없다. Xib는 그냥 이걸로 끝인거 같다 활용가능성이 별루 없습, 흐윽… 😱… 😔 ;;","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"UIView","slug":"UIView","permalink":"https://qussk.github.io/tags/UIView/"},{"name":"CustomUI","slug":"CustomUI","permalink":"https://qussk.github.io/tags/CustomUI/"}]},{"title":"[Swift]PageView(with:ScrollView)","slug":"Swift-PageView-with-ScrollView","date":"2020-07-20T17:24:35.000Z","updated":"2020-09-14T08:28:54.128Z","comments":false,"path":"2020/07/21/Swift-PageView-with-ScrollView/","link":"2020/07/20/Swift-PageView-with-ScrollView","permalink":"https://qussk.github.io/2020/07/21/Swift-PageView-with-ScrollView/","excerpt":"","text":"[PageView] ScrollView와 세트인 PageView도 구현 1.선언 12//페이지뷰lazy var pageControl = UIPageControl(frame: CGRect(x: view.frame.midX - 100, y: view.frame.maxY - 200, width: 200, height: 50)) 2. Veiw ~ Constrain 1view.addSubview(pageControl) 12pageControl.topAnchor.constraint(equalTo: scrollView.bottomAnchor, constant: 20), pageControl.centerXAnchor.constraint(equalTo: guide.centerXAnchor), 3. pageViewControl 12345678910111213141516//MARK:-pageView func pageViewControl()&#123; pageControl.numberOfPages = images.count pageControl.currentPage = 0 pageControl.pageIndicatorTintColor = .lightGray pageControl.currentPageIndicatorTintColor = ColorPiker.customBlue pageControl.addTarget(self, action: #selector(handlePageControl(_:)), for: .valueChanged) &#125; @objc func handlePageControl(_ sender: UIPageControl) &#123; let x = CGFloat(pageControl.currentPage) * scrollView.frame.width scrollView.setContentOffset(CGPoint(x: x, y: 0), animated: true) &#125; &#125; 4.ScrollView와의 연동(UIScrollViewDelegate) 1234567//MARK:-UIScrollViewDelegateextension DescriptionViewController: UIScrollViewDelegate &#123; func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) &#123; let pageNumber = round(scrollView.contentOffset.x / scrollView.frame.width) pageControl.currentPage = Int(pageNumber) &#125;&#125;","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"UIPageView","slug":"UIPageView","permalink":"https://qussk.github.io/tags/UIPageView/"},{"name":"UIScrollView","slug":"UIScrollView","permalink":"https://qussk.github.io/tags/UIScrollView/"}]},{"title":"[swift]UIScrollView 만들기","slug":"swift-UIScrollView-만들기","date":"2020-07-20T16:12:35.000Z","updated":"2020-09-14T08:28:54.147Z","comments":false,"path":"2020/07/21/swift-UIScrollView-만들기/","link":"2020/07/20/swift-UIScrollView-만들기","permalink":"https://qussk.github.io/2020/07/21/swift-UIScrollView-%EB%A7%8C%EB%93%A4%EA%B8%B0/","excerpt":"","text":"앱을 이용하면서 자주접하는 scrollview를 공부해보자. scrollview가 까다로운게, 부모뷰가 자식뷰의 크기를 따라가는 속성이라 자식뷰의 프레임과 통일성이 굉장히 중요해진다. 이것을 frame으로 잡는 방법이 있고 autolay 아웃으로 잡는 방법이 있는데 2가지 다 알아보는 걸로 ㅋㅋ [frame 이용] 주의점 red -&gt; ScrollView whigt -&gt; ImageView 보기에 잘나온 것 같지만, 부모뷰(ScrollView)가 자식뷰(imageView)보다 더 큰 경우라서, 위처럼 구현되면 자식뷰들이 부모뷰의 영역(redView)만큼 자유자재로 움직일 수 있게 된다. 애초에 그게 구현목표였다면 상관 없겠지만… 스크롤뷰에서는 보통 고정되도록 구현하니까… 이런식으로 풀화면 채워야한다. 그리고 총 3개의 그림을 크롤 하도록… 1.선언 123lazy var scrollView = UIScrollView()var scrollFrame = CGRect(x: 0, y: 0, width: 0, height: 0)let images = [\"naver\",\"instagram\",\"naver\"] //이미지이름 2.frame잡기 12345scrollView.contentSize = CGSize(width: 375 * 3, height: scrollView.frame.height) scrollView.delegate = self scrollView.isPagingEnabled = true // scrollView.backgroundColor = .red view.addSubview(scrollView) 2-1. scrollView.contentSize는 width가 275인 이미지가 3개 들어간다는 의미로 * 3을 해주었다. height는 scrollView에 맞춤. 2-1. isPagingEnabled는 스크롤 할때 페이지값으로 프레임이 정확하게 이동하는 것 3. ScrollView에 들어갈 이미지의 size지정. 123456789101112131415//MARK:-ScrollViewfunc setScrollView()&#123; // for index in images.indices &#123; scrollFrame.origin.x = view.frame.width * CGFloat(index) scrollFrame.size = scrollView.frame.size let descriptionImage = UIImageView() descriptionImage.image = UIImage(named: images[index]) descriptionImage.frame = CGRect(x: scrollFrame.origin.x, y: 0, width: 375, height: 430) scrollView.addSubview(descriptionImage) &#125;&#125; 3-1. images.indices 이미지를 순차적으로 넣는다. 3-2. image의 사이즈 1descriptionImage.frame = CGRect(x: scrollFrame.origin.x, y: 0, width: 375, height: 430) 그러면 이미지가 scrollView의 크기와 맞게 잘 돌아가는 화면을 확인 할 수 있다. 스크롤 방향은 콜렉션뷰처럼 호라이즌, 버티컬로 지정해주는 게 아니라, scrollview가 지정범위를 주고, 자식뷰의 크기에 따라서 스크롤 해주는 개념이다. 그래서 자식뷰가 width를 늘리면서 가는지, height를 늘리면서 가는지에 따라 결정된다. fram이 정확한 값을 부여하기 쉬워서 오토레이아웃보다는 안정성 면에서 좋은 것 같지만, 나는 오토레이아웃 쟁이이니까. 그리고, 위/아래로 스크롤 되는 것이 오토레이아웃이 더 쉬울것 같아서 아래의 방법처럼 해보았다. (사실 삽질 엄청 많이함.) [autoLayout 이용] 구현해야할 사항은 아래와 같다. 컨텐츠 크기에 맞춰 아래로 스크롤 하기! (ImageView와 함께 설명!) 1. 선언 12let scrollView &#x3D; UIScrollView()let detailimageView &#x3D; UIImageView() 2. UI 123456scrollView.backgroundColor = .whiteview.addSubview(scrollView)detailimageView.clipsToBounds = truedetailimageView.image = UIImage(named: \"dc1\")scrollView.addSubview(detailimageView) 3. Constrain translatesAutoresizingMaskIntoConstraints 123[scrollView,detailimageView].forEach&#123; $0.translatesAutoresizingMaskIntoConstraints = false &#125; NSLayoutConstraint 123456789101112NSLayoutConstraint.activate([scrollView.topAnchor.constraint(equalTo: view.topAnchor, constant: -90),scrollView.leadingAnchor.constraint(equalTo: view.leadingAnchor),scrollView.trailingAnchor.constraint(equalTo: view.trailingAnchor),scrollView.bottomAnchor.constraint(equalTo: view.bottomAnchor),detailimageView.topAnchor.constraint(equalTo: scrollView.topAnchor),detailimageView.leadingAnchor.constraint(equalTo: scrollView.leadingAnchor),detailimageView.trailingAnchor.constraint(equalTo: scrollView.trailingAnchor),detailimageView.widthAnchor.constraint(equalToConstant: UIScreen.main.bounds.width),detailimageView.heightAnchor.constraint(equalToConstant: 480), 3-1. scrollView.topAnchor를 constant : -90으로 잡은 이유는 ** view.safeAreaLayoutGuide** 가 아니라 View의 범위로 하고 싶어 설정한거고, topAnchor를 (equalTo: view.topAnchor)로만 잡게 되면 top부분이 고정되어 스크롤이 안된당… 그래서 고정을 주면 안되기 때문에, 임의의 값인 -90으로만 살짝 잡은것… 3-2. scrollView의 레이아웃의 기본값을 view에 맞춰줬다면, 이제 자식뷰인 detailimageView설정이 중요해진다. top은 scrollView를 따라가고, 사실 widthAnchor가 애매한 부분인데(기기마다 크기 다르니까…), **(UIScreen.main.bounds.width)**로 아예 view가 아닌 스크린 값으로 잡아버린다. 3-3. heightAnchor를 잡은이유는 이미지의 값이 고정값이고, 그 위로 Lable이 가득한 뷰를 이어나가야하기 때문… 그러면 가장 중요한. 유동값인 bottomAnchor는 어떻게 잡아야할까? 방법은 간단하다. 구현 이미지를 보면, 스크롤 뷰 맨 마지막에 올 컨텐츠는 “브랜드 더보기 &gt;” 버튼이다. 123456 viewsButton.topAnchor.constraint(equalTo: comentLable3.bottomAnchor, constant: 40), viewsButton.widthAnchor.constraint(equalToConstant: 150), viewsButton.trailingAnchor.constraint(equalTo: detailView.trailingAnchor, constant: -23), viewsButton.bottomAnchor.constraint(equalTo: scrollView.bottomAnchor, constant: -20),]) 3-4. 이런식으로 스크롤 마지막에올 viewsButton의 레이아웃을 scrollView.bottomAnchor으로 잡으면 된다. 3-4. detailView는 UIView고 그림 상의 흰영역부분 !(브랜드 설명?) 요 흰부분 !!! 12345detailView.topAnchor.constraint(equalTo: detailimageView.bottomAnchor, constant: -39), detailView.leadingAnchor.constraint(equalTo: scrollView.leadingAnchor), detailView.trailingAnchor.constraint(equalTo: scrollView.trailingAnchor), detailView.bottomAnchor.constraint(equalTo: scrollView.bottomAnchor, constant: 20), detailView.heightAnchor.constraint(equalToConstant: 830), 이해를 돕기위해 detailView의 코드 올린다. 이해해보니 참 쉽다!!! ScrollView 지정 장소에서 멈추기 위의 방법처럼 스크롤 범위를 해당 뷰의 heightAnchor로 조절가능하지만, 화면을 끝까지 당기는 경우 빈 화면이 조금 끌어당겨진다. 이것이 싫고 그냥 딱 원하는 만큼만 스크롤이 되었으면 좋겠다! 싶으면 아래를 이용하자 1.self 선언 1scrollView.delegate = self 2. extension(UIScrollViewDelegate) 12345678extension DetaileDescriotionViewController: UIScrollViewDelegate &#123; func scrollViewDidScroll(_ scrollView: UIScrollView) &#123; if scrollView.contentOffset.y &gt; 450 &#123; scrollView.contentOffset.y = 450 &#125; print(scrollView.contentOffset.y) &#125;&#125; 2-1. scrollView.contentOffset.y &gt; 450 값이 450 이상이면, scrollView.contentOffset.y = 450을 450으로 지정하겠다는 뜻이다. 2-2. print(scrollView.contentOffset.y) 는 스크롤 되었을 때, contentOffset의 y좌표를 알려준다. 그 값에 따라 적당한 값으로 설정 가능!!","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"UIScrollView","slug":"UIScrollView","permalink":"https://qussk.github.io/tags/UIScrollView/"}]},{"title":"[Swift]NavigationBar 생략","slug":"Swift-네이베이션-바-생략","date":"2020-07-20T14:49:00.000Z","updated":"2020-09-14T08:28:54.140Z","comments":false,"path":"2020/07/20/Swift-네이베이션-바-생략/","link":"2020/07/20/Swift-네이베이션-바-생략","permalink":"https://qussk.github.io/2020/07/20/Swift-%EB%84%A4%EC%9D%B4%EB%B2%A0%EC%9D%B4%EC%85%98-%EB%B0%94-%EC%83%9D%EB%9E%B5/","excerpt":"","text":"네비게이션 바 디자인 생략할 때 자주 쓰는 코드다. 보통 히든으로 생각하는 것 같은데? 실선이 남는 듯하다… 이야기를 들어보면… 그런데 나는 전부터 아래코드로 써와서 ㅋㅋㅋㅋㅋㅋㅋ 다들 이 코드 보면 신박하다고 한다 ㅋㅋㅋㅋㅋㅋㅋ 123456func navigationBarLess()&#123; //네비게이션바 디자인 생략 navigationController?.navigationBar.setBackgroundImage(UIImage(), for: .default) navigationController?.navigationBar.shadowImage = UIImage() navigationController?.navigationBar.backgroundColor = UIColor.clear&#125; navigationBar의 setBackgroundImage로는 보통 접근안하니까… 현업에서는 어떻게 쓰일지 잘 모르겠다. 어쨌든, navigationBar는 기본 흰색이 제공되고 color역시 커스텀 가능하지만… clear로 적용만 적용하면 실선이 보이게 된다. 12navigationController?.navigationBar.setBackgroundImage(UIImage(), for: .default)navigationController?.navigationBar.shadowImage = UIImage() 이 코드가 실선을 없애고 1navigationController?.navigationBar.backgroundColor = UIColor.clear 이것은 color를 투명으로 주겠다는 뜻. 그러면 navigartionBar 영역이 해당 view의 background color를 따라가게 된다. 이미지가 있다면 이미지를 그대로 보여준다. 스크롤해도 문제없음 !! 아래의 링크를 보면 히든으로 주는 방법 , 실선없애기, 바아이템 색면경, 타이틀 색변경에 대한 내용이 있다 . 참고해보아도 좋을 듯. [dd] 아마 보통은 히든~실선없애기를 사용하거나, 애초에 통일감있게 모든 vc에대해 네비바 설정을 지정하는 방법도 있는 것 같다 달리해야할때는 fales를 줘야하는 방식으로… 공부해야지","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"NavigationBar","slug":"NavigationBar","permalink":"https://qussk.github.io/tags/NavigationBar/"}]},{"title":"[라이브러리]Kingfisher로 gif이미지 삽입","slug":"Swift-Kingfisher","date":"2020-07-19T19:43:30.000Z","updated":"2020-09-14T08:28:54.124Z","comments":false,"path":"2020/07/20/Swift-Kingfisher/","link":"2020/07/19/Swift-Kingfisher","permalink":"https://qussk.github.io/2020/07/20/Swift-Kingfisher/","excerpt":"","text":"Kingfisher 라이브러리를 이용하여 gif이미지를 삽입해보자 ! 삽입할 gif 파일 1. SwiftPackageManager 에 Kingfisher불러오기 2. gif파일을 프로젝트 안에 넣는다 에셋에 넣으면 안된다!! 3. code 1import Kingfisher 3-1. 임포트 ! 1234567891011//MARK: -kfoverride func viewDidAppear(_ animated: Bool) &#123; super.viewDidAppear(true) self.guideimage.kf.indicatorType = .activity let gifs = [\"https://qussk.github.io/image/PET.gif\"] self.guideimage.kf.setImage(with: URL(string: gifs[0])!) &#125; 3-2. 화면 켤때마다 동작되길 원해서 viewDidAppear에 넣어준다. 여러개 넣고 싶을 경우 아래의 코드를 참고한다. 1234let gifs = [\"https://qussk.github.io/image/PET.gif\", \"https://~~~~\"]self.guideimage.kf.setImage(with: URL(string: gifs[0])!)self.guideimage.kf.setImage(with: URL(string: gifs[1])!) 완성 [완성영상보기] 귀엽게 잘들어갔따. 만약, gif가 아닌 mp4파일을 넣게 되면 아래 처럼 된다… [mp4영상보기] gif로 변환해서 넣은 이유… -.-;;; 매우 당황…","categories":[{"name":"Library","slug":"Library","permalink":"https://qussk.github.io/categories/Library/"}],"tags":[{"name":"Kingfisher","slug":"Kingfisher","permalink":"https://qussk.github.io/tags/Kingfisher/"},{"name":"gif","slug":"gif","permalink":"https://qussk.github.io/tags/gif/"}]},{"title":"[기타]gifs","slug":"기타-gifs","date":"2020-07-18T23:57:16.000Z","updated":"2020-10-10T04:00:27.632Z","comments":false,"path":"2020/07/19/기타-gifs/","link":"2020/07/18/기타-gifs","permalink":"https://qussk.github.io/2020/07/19/%EA%B8%B0%ED%83%80-gifs/","excerpt":"","text":"angel Yogiyo_clone","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"gif","slug":"gif","permalink":"https://qussk.github.io/tags/gif/"}]},{"title":"[Swfit] UITextfield의 모든 것(모음)","slug":"Swfit-UITextfield의-모든-것-모음","date":"2020-07-16T17:12:44.000Z","updated":"2020-09-01T12:30:49.378Z","comments":false,"path":"2020/07/17/Swfit-UITextfield의-모든-것-모음/","link":"2020/07/16/Swfit-UITextfield의-모든-것-모음","permalink":"https://qussk.github.io/2020/07/17/Swfit-UITextfield%EC%9D%98-%EB%AA%A8%EB%93%A0-%EA%B2%83-%EB%AA%A8%EC%9D%8C/","excerpt":"","text":"Textfield placeholder == hint clearButton : text 적은 것 지워줄 것인지 선택하는 부분 clear when editing begins : 누를때 마다 지워짐. Min Font Size : 일정량 이상 text 늘어날 경우 정해진 크기만큼 text 작아짐 Keyboard Type: 키보드 타입 설정(emial.number…) Secure Text Entry : Password 타입 placeholder : 내부의 안내 문구 UIKeyboardType 종류 UIKeyboardTypeDefault : 기본적인 키보드 UIKeyboardTypeASCIICapable : 영문만 표시 UIKeyboardTypeNumbersAndPunctuation : 숫자 + 특수문자 UIKeyboardTypeURL : URL입력할 수있도록 .과 .com이 기본으로 추가됨 UIKeyboardTypeNumberPad : 숫자만 입력 UIKeyboardTypePhonePad : 전화번호를 입력 UIKeyboardTypeNamePhonePad : 대문자를 지원하지 않는 키보드 UIKeyboardTypeEmailAddress : 이메일주소를 입력할 수 있도록 @와 .이 기본으로 추가됨 UIKeyboardTypeDecimalPad : 소숫점 입력할 수 있도록 지원 UIKeyboardTypeTwitter : 트위터 입력을 빠르게 도와주도록 @,#지원 UIKeyboardTypeWebSearch : URL 및 검색어 입력에 최적화되도록 공백 및 .지원 UIKeyboardTypeAlphabet : =UIKeyboardTypeASCIICapable. 더이상 지원하지 않음. Sent Events 예시 그림 textFieldEditingDidBegin : 텍스트 필드 터치했을 때. 123@IBAction func textFieldEditingDidBegin(_ sender: UITextField)&#123; print(\"textFieldEditingDidBegin\") &#125; textFieldEditingChanged : 어떤 값 변경될 때마다. (실시간으로) 123@IBAction func textFieldEditingChanged(_ sender: UITextField) &#123; print(sender.text ?? \"\")&#125; textFieldDidEndExit : textField 선택해제 123@IBAction func textFieldDidEndExit(_ sender: Anu) &#123;&#125; textFieldPrimaryActionTriggerd : enter 눌렀을 때 호출, 입력 값 잘못됬을 때 다시 입력하는 행위등에서 사용 1234567@IBAction func txtFPrimaryActionTriggerd(_ sender: UITextField)&#123; if true&#123; sender.resignFirstResponder()//키보드 행위에서사용 &#125; print(\"PrimaryActionTriggerd\")&#125; textFieldDidEndOnExit : return 호출시 이 설정이 되어있으면 return시 무조건 내려감 123@IBAction func txtFDidOnExit(_ sender: Any)&#123; print(\"DidEndOnExit\")&#125; 여러개의 textField가 위같은 것들 하나에 여러개 연결 가능하다. idTextField.becomeFirstResponder() : idTextField가 첫번째 포커스 이자, 키보드 바 로 떠서 입력받음 resignFirstResponder() 키보드 내리거나 못내리게 하는 상황에서 사용. 12345if sender.text!.count &gt; 6&#123; sender.resignFirstResponer()&#125;view.endEditing(true) 1234567891011@IBAction func textFieldEditingChanged(_ sender: UITextField)&#123; if sender == idTextField&#123; &#125; print(sender.text ?? \"\") if sender.text!.count &gt; 6&#123; sender.resignFirstResponder() &#125; view.endEditing(true)&#125; UITextFieldDelegate 글자수 제한하기 shouldChangeCharactersIn() https://qussk.github.io/2020/05/21/Swift-TextField 밑줄 긋기 borderStyle을 .non으로 지정하고 CALayer를 적용하는 방식 https://qussk.github.io/2020/05/21/Swift-textField Textfield 가려짐 문제해결 https://qussk.github.io/2020/05/19/Swift 화면 터치시 키보드내리기, 리턴시 커서이동 https://qussk.github.io/2020/08/09/Swift-Textfield","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"Textfield","slug":"Textfield","permalink":"https://qussk.github.io/tags/Textfield/"},{"name":"UIKeyboardType","slug":"UIKeyboardType","permalink":"https://qussk.github.io/tags/UIKeyboardType/"}]},{"title":"[Swift]navigationBar title 변경(다양한 문제들)","slug":"Swift-navigationBar-title-변경-다양한-문제들","date":"2020-07-15T11:57:02.000Z","updated":"2020-09-14T08:28:54.139Z","comments":false,"path":"2020/07/15/Swift-navigationBar-title-변경-다양한-문제들/","link":"2020/07/15/Swift-navigationBar-title-변경-다양한-문제들","permalink":"https://qussk.github.io/2020/07/15/Swift-navigationBar-title-%EB%B3%80%EA%B2%BD-%EB%8B%A4%EC%96%91%ED%95%9C-%EB%AC%B8%EC%A0%9C%EB%93%A4/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"[Swift]상업용 UIFont변경","slug":"Swift-상업용-Font변경","date":"2020-07-15T11:53:26.000Z","updated":"2020-09-14T08:28:54.141Z","comments":false,"path":"2020/07/15/Swift-상업용-Font변경/","link":"2020/07/15/Swift-상업용-Font변경","permalink":"https://qussk.github.io/2020/07/15/Swift-%EC%83%81%EC%97%85%EC%9A%A9-Font%EB%B3%80%EA%B2%BD/","excerpt":"","text":"","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"UIFont","slug":"UIFont","permalink":"https://qussk.github.io/tags/UIFont/"}]},{"title":"[Swift]UISearchController ?? searchController : searchBar","slug":"Swift-UISearchController","date":"2020-07-12T02:46:00.000Z","updated":"2020-09-14T08:28:54.134Z","comments":false,"path":"2020/07/12/Swift-UISearchController/","link":"2020/07/12/Swift-UISearchController","permalink":"https://qussk.github.io/2020/07/12/Swift-UISearchController/","excerpt":"","text":"navigationBar에 UISearchBar달기 위와 같은 그림처럼 navigationBar에 searchBar를 넣는 식으로 구현하고자 한다면 아래의 코드를 참고하자. (ios11부터 생긴듯?) 선언 1let searchBar = UISearchBar() 코드 navigationItem.titleView = searchBar 12345678910111213141516func navigationBar()&#123; //BarItem navigationItem.rightBarButtonItem = UIBarButtonItem(barButtonSystemItem: .search, target: self, action: #selector(seachButton)) navigationItem.rightBarButtonItem?.tintColor = .darkGray //navi in searchBar navigationItem.titleView = searchBar &#125; @objc private func seachButton(_ sender : UIButton)&#123; //print(\"search\", searchBar.text! as Any) searchBar.becomeFirstResponder() //getAdress() &#125; setUI 1searchBar.sizeToFit() navigationItem.titleView = seachBar 를 보면, navigationItem의 titleView에 searchBar를 넣는 것을 확인 할 수 있다. navigationBar에 seachBar를 고정으로 달아 놓는 경우가 많아 seachBar는 이정도만 알고 있었는데… 😹 !! 하필 아래의 그림 처럼 구현해야할 일이 닥쳤다… ㅎㅎ… UISearchBarController 이용하여 navigationBar하단에 searchBar달기. (witfh: 스크롤시 사라짐) 선언 UISearchController 1let searchBarController = UISearchController(searchResultsController: nil) searchResultsController를 nil값으로 주면, UISearchController 초기화 시, searchcontroller에게 검색중인 동일한 뷰를 사용하여 결과를 표시하도록 지시한다. 코드 searchController 12345678910func navigationBar()&#123; navigationItem.rightBarButtonItem = UIBarButtonItem(barButtonSystemItem: .search, target: self, action: #selector(seachButton)) navigationItem.rightBarButtonItem?.tintColor = .darkGray navigationItem.title = \"Cafe Spot\" navigationItem.searchController = searchBarController &#125; @objc private func seachButton(_ sender : UIButton)&#123; &#125; 위의 titleView에 올린 것과 다르게, SearchController를 직접이용하여, navigationItem에 UISearchBarController를 불러왔다. 그런데 신기한 건, rightBarButtonItem(돋보기 모양버튼)과 navigationItem.title(타이틀)을 없애도, SearchController는 네비게이션바 아래에 달린 모습이었다… 훔… 몬가 씹어 삼킬줄 알았는데 그리고 스크롤에 따라 SearchBar가 알아서 사라지니 참고하도록 하자. 위에는 쓰이지 않았지만, UISearchController가 활성화되어있는 동안 다른 뷰 이동시 이동한 뷰에 searchBar가 화면에 남아있지 않도록 설정도 해주자. [참고링크]","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"SeachBar","slug":"SeachBar","permalink":"https://qussk.github.io/tags/SeachBar/"}]},{"title":"[Swift]Json파일 가져오기(with: decoder)","slug":"Swift-Json파일-가져오기-with-decoder","date":"2020-07-12T02:45:28.000Z","updated":"2020-09-14T08:28:54.123Z","comments":false,"path":"2020/07/12/Swift-Json파일-가져오기-with-decoder/","link":"2020/07/12/Swift-Json파일-가져오기-with-decoder","permalink":"https://qussk.github.io/2020/07/12/Swift-Json%ED%8C%8C%EC%9D%BC-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0-with-decoder/","excerpt":"","text":"JSON란? name: Value의 형태의 쌍을 이루는 콜렉션 타입(Dictionary) XML에 비해 기능이 적고 구조가 단순하여 파싱이 쉽고 빠르다. 적은 용량으로 저장가능 사람뿐 아니라, 기계가 분석하고 생성하는 것도 용이 contents type --&gt; application/json 기본 인코딩 UTF-8 JSON 깊게 이해하기 JSON 실제 위의 json 형식 파일을 데이터로 불러오는 경우. 1.구조체 만들기 123456789101112131415import UIKitstruct Cafe: Decodable &#123; let title: String let description: String let location: Location let isFavorite: Boolstruct Location: Decodable &#123; let address: String let lat: Double let lng: Double &#125;&#125; Key이름과 실제 사용할 Key이름이 다를 경우, CodingKey를 사용(enum:열거형) 하지만, 현재 key값이 동일하므로 Decode만 해줘도 된답. 2. 데이타 불러주기(해당 ViewController로 이동) Bundle이용하여 리소스 가져오기 1let path = Bundle.main.path(forResorce: \"CafeList\", ofType: \"json\") 리소스 : “CafeList”, 데이터 타입 : “json” URL이용 1lazy var url = URL(fileURLWithPath: path!) 새로만든 NSURL객체를 지정된 경로를 가진 파일 URL(let path)로 초기화하고 반환. (파일에서 바로 가져오므로 utf-8이용안함) Data try! 1lazy var data = try! Data(contentsOf: url) 구조체 담을 변수선언 (타입: [Cafe], 값:빈배열) 1var cageData : [Cafe] = [] 3.JSON가져오기 JSONDecoder 12345678910override func viewDidLoad() &#123;super.viewDidLoad() if let json = try? JSONDecoder().decode([Cafe].self, from: data) &#123; print(json) //제이슨을 배열에 담아주기 cafeData.append(contentsOf: json) &#125; &#125; data로부터, [Cafe].self(배열) decode하기 데이터 못 가져온 경우, do ~cashe 이용하여 print(error)로 애러사항 확인 가능. 성공했다면 아래와 같은 값이 디버깅에 확인됨 4. 데이터 불러오기(셋팅?) CollectionViewCell 123456789func configureCell(data: Cafe) &#123; let title = data.title let description = data.description cafeImageView.image = UIImage(named: title) cafeTitle.text = title cafeComent.text = description&#125; data는 cafe라는 (타입/값)을 가진 Key임 CollectionViewDataSource 1cell.configureCell(data: cafeData[indexPath.item]) cellForItemAt에 CollectionViewCell에서 만들어준 configureCell 값 붙이기. 결과","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"JSON","slug":"JSON","permalink":"https://qussk.github.io/tags/JSON/"},{"name":"Bundle","slug":"Bundle","permalink":"https://qussk.github.io/tags/Bundle/"},{"name":"Path","slug":"Path","permalink":"https://qussk.github.io/tags/Path/"}]},{"title":"[Swift]UIView에 shadow주기","slug":"Swift-UIView에-shadow주기","date":"2020-07-09T19:08:39.000Z","updated":"2020-09-14T08:28:54.136Z","comments":false,"path":"2020/07/10/Swift-UIView에-shadow주기/","link":"2020/07/09/Swift-UIView에-shadow주기","permalink":"https://qussk.github.io/2020/07/10/Swift-UIView%EC%97%90-shadow%EC%A3%BC%EA%B8%B0/","excerpt":"","text":"shadowColor에 black을 주는 것으로 시작 ~ ! 12345self.containView.layer.shadowColor = UIColor.black.cgColor // 검정색 self.containView.layer.masksToBounds = false self.containView.layer.shadowOffset = CGSize(width: 0, height: 4) // 그림자 시작위치 self.containView.layer.shadowRadius = 8 // 그림자크기(범위) self.containView.layer.shadowOpacity = 0.3 //그림자 불투명도 [1이 기준 - 완전 불투명] shadowPath 를 이용하면 그림자의 크기와 방향을 한꺼번에 잡을 수 있다. (베젤크기?) 1view.layer.shadowPath = UIBezierPath(rest: CGRect(x: 0, y: 0, width: 10, height: view.bounds.height)).cgPath 그림자를 사용하면 자원이 많이 드는 일? 이라고 한다. 그래서 그림자를 캐시에 저장해서 재활용하는 방법도 있다. 1view.layer.shouldRasterize = true","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"Shadow","slug":"Shadow","permalink":"https://qussk.github.io/tags/Shadow/"},{"name":"UIView","slug":"UIView","permalink":"https://qussk.github.io/tags/UIView/"}]},{"title":"[라이브러리]SnapKit으로 오토레이아웃 잡기","slug":"라이브러리-SnapKit으로-오토레이아웃-잡기","date":"2020-07-09T17:48:46.000Z","updated":"2020-09-14T08:28:54.149Z","comments":false,"path":"2020/07/10/라이브러리-SnapKit으로-오토레이아웃-잡기/","link":"2020/07/09/라이브러리-SnapKit으로-오토레이아웃-잡기","permalink":"https://qussk.github.io/2020/07/10/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-SnapKit%EC%9C%BC%EB%A1%9C-%EC%98%A4%ED%86%A0%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83-%EC%9E%A1%EA%B8%B0/","excerpt":"","text":"SnapKit 링크 SnapKit 사용 [snapKit] makeConstraints - 최초 제약설정 updateConstraint -이미 설정한 특정 값을 다른 것으로 바꿀 때 remakeConstraints - 기존의 연결을 모두 제거하고 완전히 새로 설정 아래 코드는 makeConstraints를 바탕으로 짰다. 12345678910111213141516171819202122232425262728293031//snp - 스냅킷func makeConstraints() &#123;//makeConstraints오토레이아웃을 잡겠다. squareView.snp.makeConstraints &#123; $0.centerX.equalToSuperview() $0.centerY.equalToSuperview().offset(40) $0.width.equalToSuperview().multipliedBy(0.7) $0.height.equalToSuperview().multipliedBy(0.4) &#125; topView.snp.makeConstraints&#123; $0.leading.trailing.top.equalToSuperview().inset(20) &#125; bottomView.snp.makeConstraints&#123; $0.top.equalTo(topView.snp.bottom) $0.height.equalTo(topView) $0.leading.bottom.trailing.equalToSuperview().inset(20) &#125; topLabel.snp.makeConstraints&#123; $0.edges.equalToSuperview() &#125; bottomLabel.snp.makeConstraints&#123; // $0.width.height.equalTo(topLabel) 아래와 동일 $0.size.equalTo(topLabel) $0.leading.bottom.equalToSuperview() &#125; bottomCircleView.snp.makeConstraints&#123; $0.top.equalTo(squareView.snp.bottom) $0.centerX.equalTo(squareView) $0.width.height.equalTo(squareView.snp.width).dividedBy(2) &#125;&#125; SnapKit을 이용하여 로그인화면 만들기 위 화면을 만들어보자 !! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118import UIKitimport SnapKitfinal class FloatingLabelViewController: UIViewController &#123; let containView = UIView() let idTextfield = UITextField() let pwTextfield = UITextField() let loginButton = UIButton() let signUpButton = UIButton() let naverUpButton = UIButton() let naverLogoImage = UIImageView() override func viewDidLoad() &#123; super.viewDidLoad() setupView() makeConstraints() &#125; override func viewDidAppear(_ animated: Bool) &#123; containView.alpha = 0 viewAni() &#125; func setupView()&#123; containView.backgroundColor = .white view.addSubview(containView) idTextfield.backgroundColor = .white idTextfield.placeholder = \"아이디를 입력해주세요.\" containView.addSubview(idTextfield) pwTextfield.backgroundColor = .white pwTextfield.isSecureTextEntry = true pwTextfield.placeholder = \"비밀번호를 입력해주세요.\" containView.addSubview(pwTextfield) loginButton.backgroundColor = .systemGray loginButton.setTitle(\"로그인\", for: .normal) loginButton.setTitleColor(.white, for: .normal) //loginButton.layer.cornerRadius = 8 containView.addSubview(loginButton) signUpButton.backgroundColor = .systemBlue signUpButton.setTitle(\"회원가입\", for: .normal) signUpButton.setTitleColor(.white, for: .normal) containView.addSubview(signUpButton) naverUpButton.backgroundColor = .systemGreen naverUpButton.setTitle(\"네이버 로그인\", for: .normal) naverUpButton.setTitleColor(.white, for: .normal) containView.addSubview(naverUpButton) naverLogoImage.image = UIImage(named: \"naver\") containView.addSubview(naverLogoImage) self.containView.layer.shadowColor = UIColor.black.cgColor // 검정색 사용 self.containView.layer.masksToBounds = false self.containView.layer.shadowOffset = CGSize(width: 0, height: 4) // 반경에 대해서 너무 적용이 되어서 4point 정도 내림. self.containView.layer.shadowRadius = 8 // 반경? self.containView.layer.shadowOpacity = 0.3 &#125; func makeConstraints()&#123; containView.snp.makeConstraints&#123; $0.centerX.equalToSuperview() $0.centerY.equalToSuperview() $0.width.equalToSuperview().multipliedBy(0.9) $0.height.equalToSuperview().multipliedBy(0.3) &#125; idTextfield.snp.makeConstraints&#123; $0.leading.top.equalToSuperview().inset(20) $0.bottom.equalTo(pwTextfield.snp.top).inset(-10) $0.trailing.equalToSuperview().inset(100) $0.height.equalTo(pwTextfield.snp.height) &#125; loginButton.snp.makeConstraints&#123; $0.leading.equalTo(idTextfield.snp.trailing).inset(-10) $0.top.trailing.equalToSuperview().inset(20) $0.bottom.equalTo(signUpButton.snp.top).inset(-10) &#125; pwTextfield.snp.makeConstraints&#123; $0.top.equalTo(idTextfield.snp.bottom).inset(-8) $0.leading.equalToSuperview().inset(20) $0.bottom.equalTo(signUpButton.snp.top).inset(-10) $0.trailing.equalToSuperview().inset(100) &#125; signUpButton.snp.makeConstraints&#123; $0.top.equalTo(pwTextfield.snp.bottom).inset(-10) $0.leading.trailing.equalToSuperview().inset(20) $0.height.equalToSuperview().multipliedBy(0.2) &#125; naverUpButton.snp.makeConstraints&#123; $0.top.equalTo(signUpButton.snp.bottom).inset(-10) $0.leading.trailing.equalToSuperview().inset(20) $0.height.equalToSuperview().multipliedBy(0.2) $0.bottom.equalToSuperview().inset(20) &#125; naverLogoImage.snp.makeConstraints&#123; $0.top.bottom.equalTo(naverUpButton).inset(10) $0.leading.equalTo(naverUpButton.snp.leading).inset(40) $0.trailing.equalTo(naverUpButton.snp.trailing).inset(225) &#125; &#125; func viewAni()&#123; UIView.animate(withDuration: 1)&#123; self.containView.alpha = 1 &#125; &#125;&#125; viewDidAppear에 alpha 값을 주어 좀더 있어 보이게 했다. ㅋ 아래 링크 확인 [동영상보기] 😸","categories":[{"name":"Library","slug":"Library","permalink":"https://qussk.github.io/categories/Library/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"라이브러리","slug":"라이브러리","permalink":"https://qussk.github.io/tags/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/"},{"name":"SnapKit","slug":"SnapKit","permalink":"https://qussk.github.io/tags/SnapKit/"}]},{"title":"[Swift]Text 줄바꿈(n,t,r)","slug":"Swift-Text-줄바꿈-n-t-r","date":"2020-07-08T11:44:50.000Z","updated":"2020-09-14T08:28:54.131Z","comments":false,"path":"2020/07/08/Swift-Text-줄바꿈-n-t-r/","link":"2020/07/08/Swift-Text-줄바꿈-n-t-r","permalink":"https://qussk.github.io/2020/07/08/Swift-Text-%EC%A4%84%EB%B0%94%EA%BF%88-n-t-r/","excerpt":"","text":"TextView, Lable등을 이용하면서, 줄바꿈이 필요할 때… 제어문자인 \\n, \\t, \\r을 활용하면 된다. \\n : 줄바꿈 문자(다음 줄 처음으로 이동) \\t : 탭(제일 뒤로 가서 탭) \\r : 커서를 그 줄의 맨 앞으로 이동시킴 \\n과 \\r은 거의 구분이 없다. 어쨌든, 제어 문자를 활용하게 되면? 이런 식으로 줄바꿈이 가능해져서 text가 예쁘게 정렬된 모습을 볼 수 있다. Data 코드 1234567import UIKit//StartViewControllervar images = [\"1\",\"2\",\"3\",\"4-2\",\"5\"]var titleData = [\"텔레파시\",\"복불복\",\"받아라 폭탄\",\"낚시게임\",\"현재 준비중인 화면입니다\"]var labelData = [\"상대방의 카드를 맞춰주세요!\\r1. 카드를 선택한다.\\r2. 카드를 섞는다.\\r3. 상대방이 카드를 맞춘다.\",\"나의 당첨은??\\r1. 인원수를 선택한다.\\r2. 제비에 벌칙,상금등의 값을 입력 한다.\\n3. 함께 제비를 뽑는다.\",\"상대방에게 폭탄을 선물하자!\\r1.폭탄의 타이머를 설정한다.\\r2. 서로에게 폭탄을 넘긴다. \\r3. 받는 동안 폭탄이 터지면 OUT!\",\"대어를 낚아라!\\r1.낚시장소를 선택한다.\\r2.제한시간동안 최대한 많은 물고기를 낚는다\\r(중간에 쓰레기도 있으니 조심!)\",\"\"]","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"Text","slug":"Text","permalink":"https://qussk.github.io/tags/Text/"},{"name":"제어문자","slug":"제어문자","permalink":"https://qussk.github.io/tags/%EC%A0%9C%EC%96%B4%EB%AC%B8%EC%9E%90/"}]},{"title":"[Swift]Launch screen 애니메이션 바(CAGradientLayer)","slug":"Swift-Launch-screen-애니메이션-바","date":"2020-07-08T10:12:03.000Z","updated":"2020-09-14T08:28:54.124Z","comments":false,"path":"2020/07/08/Swift-Launch-screen-애니메이션-바/","link":"2020/07/08/Swift-Launch-screen-애니메이션-바","permalink":"https://qussk.github.io/2020/07/08/Swift-Launch-screen-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98-%EB%B0%94/","excerpt":"","text":"프로젝트중 LaunchScreen이 필요 했는데, 스토리보드로 해야할 것 처럼 생겼고, swift 파일 만들어서 @IBOulet연결 해도 코드가 적용안되는 모습이고, 알아보니, Xcode에서 지원하는 LaunchScreen을 쓰기보다 보통 ViewController을 이용하여 LaunchScreen을 직접 만들어 쓴다고 한다! 🤔 그래서 vc를 만들고 animation을 주면 좋을 것 같아 찾아 보았다! [참고한 사이트 - 왕복바] 위 사이트에서는 왕복으로 왔다갔다하는 바지만, 나는 로딩이 되는 것처럼 보이기 위해 한 방향으로만 가도록 고쳤다 ㅎㅎ ! HorizontalMarqueeView.swift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import UIKitclass HorizontalMarqueeView: UIView &#123; var barView: UIView! var backgroundGradientLayer: CAGradientLayer! var grdientDelay: CFTimeInterval = 0.7 var grdientDuration: CFTimeInterval = 0.3 var moveDelay: TimeInterval = 0.3 var moveDuration: TimeInterval = 1 public func initBar() &#123; self.clipsToBounds = true self.backgroundColor = UIColor.clear let barW = self.frame.size.width / 2 let barH = self.frame.size.height barView = UIView.init(frame: CGRect.init(x: self.frame.size.width, y: 0, width: barW, height: barH)) barView.backgroundColor = UIColor.clear self.addSubview(barView) backgroundGradientLayer = CAGradientLayer() backgroundGradientLayer.frame = barView.bounds backgroundGradientLayer.startPoint = CGPoint.init(x: 0.0, y: 0.5) backgroundGradientLayer.endPoint = CGPoint.init(x: 1.0, y: 0.5) //166, 177, 225 backgroundGradientLayer.colors = [UIColor(red: 166/255, green: 177/255, blue: 225/255, alpha: 1).cgColor, UIColor.clear.cgColor] backgroundGradientLayer.locations = [1.0, 1.0] barView.layer.addSublayer(backgroundGradientLayer) moveBarToLeft() &#125; private func moveBarToLeft() &#123; // 1.reset barView.frame = CGRect.init(x: self.frame.size.width, y: 0, width: barView.frame.size.width, height: barView.frame.size.height) backgroundGradientLayer.colors = [UIColor(red: 166/255, green: 177/255, blue: 225/255, alpha: 1).cgColor, UIColor.clear.cgColor] backgroundGradientLayer.locations = [1.0, 1.0] // 2.anim gradient let gradientChangeLocation = CABasicAnimation(keyPath: \"locations\") gradientChangeLocation.beginTime = CACurrentMediaTime() + grdientDelay gradientChangeLocation.duration = grdientDuration gradientChangeLocation.toValue = [-1.0, 1.0] gradientChangeLocation.fillMode = CAMediaTimingFillMode.forwards gradientChangeLocation.isRemovedOnCompletion = false self.backgroundGradientLayer.add(gradientChangeLocation, forKey: \"locationsChange\") // 3. anim move UIView.animate(withDuration: moveDuration, delay: moveDelay, options: UIView.AnimationOptions.curveLinear, animations: &#123; self.barView.frame = CGRect.init(x: -self.barView.frame.size.width, y: 0, width: self.barView.frame.size.width, height: self.barView.frame.size.height) &#125;) &#123; (isFinish) in self.moveBarToLeft() &#125; &#125;&#125; 1. reset 바 뷰 부분에 CAGradientLayer를 이용하였다. background color위에 color gradient를 그려서 layer의 shape을 채우는 layer라고 생각하면 될 듯. startPoint와 endPoint 는 view위에 그려질 그라데이션의 시작과 끝점. backgroundGradientLayer 은 그라데이션의 비율. 기본적으로 [1,0]이 1:1 모습. 2. anim gradient anim gradient의 부분은 CABasicAnimation을 이용하여 그라데이션 주는 부분. gradientChangeLocation의 시작 시간(beginTime)은 CACurrentMediaTime(현재 절대 시간을 초 단위로 반환) + grdientDelay이다. let grdientDelay = 0.7 coloer는 커스텀 하여 사용 3. anim move 일반적인 animation을 사용 CAGradientLayer에 대한 자세한 내용은 아래의 블로그를 참고하면 된다! (매우 쉽게 설명 되어있음!) CAGradientLayer 참고 - Zedd 블로그 Launch Screen VC에 HorizontalMarqueeView코드 넣어 주기. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import UIKitclass ViewController: UIViewController &#123; var marqueeView: HorizontalMarqueeView! let timerArr : [IndexPath] = [] override func viewDidLoad() &#123; super.viewDidLoad() view.backgroundColor = .white marqueeView = HorizontalMarqueeView.init(frame: CGRect.init(x: UIScreen.main.bounds.size.width/10, y: 400, width: UIScreen.main.bounds.size.width/1.2, height: 5)) self.view.addSubview(marqueeView) DispatchQueue.main.asyncAfter(deadline: .now() + 3) &#123; let startVC = StartViewController() startVC.delegate = self startVC.modalPresentationStyle = .fullScreen self.present(startVC, animated: true) &#125; marqueeView.initBar() setupLaunchImage() &#125; func setupLaunchImage()&#123; let launchImage = UIImageView() launchImage.image = UIImage(named: \"Dadam4\") view.addSubview(launchImage) launchImage.translatesAutoresizingMaskIntoConstraints = false launchImage.topAnchor.constraint(equalTo: view.topAnchor, constant: view.frame.width/2.8).isActive = true launchImage.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: view.frame.width/3).isActive = true launchImage.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -(view.frame.width/3)).isActive = true launchImage.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: -(view.frame.width/0.7)).isActive = true &#125;&#125;extension ViewController: StartViewControllerDelegate &#123; func handleDismiss() &#123; let MainVC = MainViewController() // let navi = UINavigationController(rootViewController: MainVC) MainVC.modalPresentationStyle = .fullScreen self.present(MainVC, animated: false) &#125; &#125; DispatchQueue.main.asyncAfter(deadline: .now() + 3) { 을 이용하여, 해당 Launch화면이 main으로부터 3초뒤에 종료되도록 하였다. 완성된 모습 [영상보기]","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"Launch Screen","slug":"Launch-Screen","permalink":"https://qussk.github.io/tags/Launch-Screen/"},{"name":"animation","slug":"animation","permalink":"https://qussk.github.io/tags/animation/"},{"name":"CAGradientLayer","slug":"CAGradientLayer","permalink":"https://qussk.github.io/tags/CAGradientLayer/"}]},{"title":"[Swift]Cell에 shadow주기","slug":"Swift-Cell에-shadow주기","date":"2020-07-08T09:56:53.000Z","updated":"2020-09-14T08:28:54.116Z","comments":false,"path":"2020/07/08/Swift-Cell에-shadow주기/","link":"2020/07/08/Swift-Cell에-shadow주기","permalink":"https://qussk.github.io/2020/07/08/Swift-Cell%EC%97%90-shadow%EC%A3%BC%EA%B8%B0/","excerpt":"","text":"간단하게 Cell에 그림자 주기 👻 123456789101112private func setupView()&#123; mainImageView.clipsToBounds = true mainTitleImage.clipsToBounds = true //쉐도우 let shadowPath2 = UIBezierPath(rect: bounds) layer.masksToBounds = false layer.shadowColor = UIColor.black.cgColor layer.shadowOffset = CGSize(width: CGFloat(2.0), height: CGFloat(3.0)) layer.shadowOpacity = 0.6 layer.shadowRadius = 4 layer.shadowPath = shadowPath2.cgPath 🎃🙌🏻","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"Shadow","slug":"Shadow","permalink":"https://qussk.github.io/tags/Shadow/"},{"name":"layr","slug":"layr","permalink":"https://qussk.github.io/tags/layr/"}]},{"title":"[Swift]CollectionViewCell에 애니메이션 주기(CAAnimation)","slug":"Swift-CollectionViewCell에-애니메이션-주기","date":"2020-07-08T09:07:48.000Z","updated":"2020-09-14T08:28:54.118Z","comments":false,"path":"2020/07/08/Swift-CollectionViewCell에-애니메이션-주기/","link":"2020/07/08/Swift-CollectionViewCell에-애니메이션-주기","permalink":"https://qussk.github.io/2020/07/08/Swift-CollectionViewCell%EC%97%90-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98-%EC%A3%BC%EA%B8%B0/","excerpt":"","text":"Cell에는 애니메이션 못주나? 라는 생각하나로… CollectionViewCell에 animation을 주는 방법을 찾다가, 레이어 상태 간의 애니메이션 전환을 주는 CATransition을 발견했다! 🥺 바로 구현 고고 AnimationUtility.swift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import UIKitclass AnimationUtility: UIViewController, CAAnimationDelegate &#123; static let kSlideAnimationDuration: CFTimeInterval = 0.5 static func viewSlideInFromRight(toLeft views: UIView) &#123; var transition: CATransition? = nil transition = CATransition.init() transition?.duration = kSlideAnimationDuration transition?.timingFunction = CAMediaTimingFunction(name: CAMediaTimingFunctionName.easeInEaseOut) transition?.type = CATransitionType.push transition?.subtype = CATransitionSubtype.fromRight //transition?.delegate = (self as! CAAnimationDelegate) views.layer.add(transition!, forKey: nil) &#125; static func viewSlideInFromLeft(toRight views: UIView) &#123; var transition: CATransition? = nil transition = CATransition.init() transition?.duration = kSlideAnimationDuration transition?.timingFunction = CAMediaTimingFunction(name: CAMediaTimingFunctionName.easeInEaseOut) transition?.type = CATransitionType.push transition?.subtype = CATransitionSubtype.fromLeft // transition?.delegate = (self as! CAAnimationDelegate) views.layer.add(transition!, forKey: nil) &#125; static func viewSlideInFromTop(toBottom views: UIView) &#123; var transition: CATransition? = nil transition = CATransition.init() transition?.duration = kSlideAnimationDuration transition?.timingFunction = CAMediaTimingFunction(name: CAMediaTimingFunctionName.easeInEaseOut) transition?.type = CATransitionType.push transition?.subtype = CATransitionSubtype.fromBottom//transition?.delegate = (self as! CAAnimationDelegate) views.layer.add(transition!, forKey: nil) &#125; static func viewSlideInFromBottom(toTop views: UIView) &#123; var transition: CATransition? = nil transition = CATransition.init() transition?.duration = kSlideAnimationDuration transition?.timingFunction = CAMediaTimingFunction(name: CAMediaTimingFunctionName.easeInEaseOut) transition?.type = CATransitionType.push transition?.subtype = CATransitionSubtype.fromTop // transition?.delegate = (self as! CAAnimationDelegate) views.layer.add(transition!, forKey: nil) &#125;&#125; CATransition : 레이어 상태 간 애니메이션 전환을 제공하는 객체. 기본 전환은 크로스 페이드이지만 사전 정의 된 전환 세트와 다른 효과를 지정할 수 있다. CAMediaTimingFunction : 애니메이션의 간격의 타이밍 기능. 곡선으로 정의하는 함수의 한 세그먼트를 나타낸다. 이 함수는 범위 [0,1]과 출력 시간에 매핑 [0,1]. easeInEaseOut : 애니메이션이 느리게 시작하고 지속 시간 동안 가속 된 다음 완료하기 전에 다시 느리게함 (아래 그림 참고) subtype은 어디로부터? 올지 설정하는 것 같다. (아니면 기존 레이아웃 위치?) cellForItemAt에 animate 코드추가 123456789101112131415161718192021222324252627282930313233343536// MARK: UICollectionViewDataSourceextension MainViewController: UICollectionViewDataSource &#123; func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123; 4 &#125; func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123; let cell = collectionView.dequeueReusableCell(withReuseIdentifier: \"CollectionCell\", for: indexPath) as! MainCollectionViewCell if !cell.isAnimated &#123; UIView.animate(withDuration: 0.5, delay: 0.5 * Double(indexPath.row), usingSpringWithDamping: 1, initialSpringVelocity: 0.5, options: indexPath.row % 2 == 0 ? .transitionFlipFromLeft : .transitionFlipFromRight, animations: &#123; if indexPath.row % 2 == 0 &#123; AnimationUtility.viewSlideInFromLeft(toRight: cell) &#125; else &#123; AnimationUtility.viewSlideInFromRight(toLeft: cell) &#125; &#125;, completion: &#123; (done) in cell.isAnimated = true &#125;) &#125; cell.backgroundColor = .clear cell.mainImageView.image = UIImage(named: images[indexPath.item]) cell.mainTitleImage.image = UIImage(named: \"cardShadow\") cell.titlteLable.text = titleData[indexPath.item] return cell &#125;&#125; 코드는 stackoverflow를 참고 했다! 옛날 코드라서 바뀐 게 좀 있었지만 문제 없는 정도였다!.. 참고링크 - stackoverflow 완성된 모습 4가지 게임이 보이는 메인화면에 적용! [영상보기]","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"UICollectionView","slug":"UICollectionView","permalink":"https://qussk.github.io/tags/UICollectionView/"},{"name":"CAAnimation","slug":"CAAnimation","permalink":"https://qussk.github.io/tags/CAAnimation/"}]},{"title":"[Swift]Gesture 이해하기","slug":"Swift-Gesture-이해하기-2","date":"2020-06-25T15:17:16.000Z","updated":"2020-09-14T08:28:54.122Z","comments":false,"path":"2020/06/26/Swift-Gesture-이해하기-2/","link":"2020/06/25/Swift-Gesture-이해하기-2","permalink":"https://qussk.github.io/2020/06/26/Swift-Gesture-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-2/","excerpt":"","text":"0. 제스처?(UITapGestureRecognizer) 0-0. UITapGestureRecognizer을 상속받아 사용할 수 있는 7가지 제스처, Tap gesture recognizer Swipe gesture recognizer Pan gesture recognizer Pinch gesture recognizer Rotation gesture recognizer Screen gesture recognizer LongPress gesture recognizer 1. Tap제스처, Rotation제스처, Swipe제스처 연결. 제스처 아이템을 검색하여 해당되는 제스처를 @IBAction에 연결한다. 저는 (Tap, Rotation, Swipe)을 사용했다. 스토리 보드상으로 보면 이런 식으로 된다. 2. Tap제스처 구현(더블 클릭시 이미지 크기 4배 증가) 12345678910111213141516171819202122232425262728import UIKitfinal class GestureViewController: UIViewController &#123; @IBOutlet private weak var imageView: UIImageView!&#123; //0.제스처 대상 만들기(이미지뷰). didSet &#123; imageView.layer.cornerRadius = imageView.frame.width / 2 imageView.clipsToBounds = true &#125; &#125; //tap1-1. var isQuadruple = false //더블탭 하면 이미지가 원본의 4배 크기로 &lt;-&gt; 원본으로 @IBAction private func handleTapGesture(_ sender: UITapGestureRecognizer)&#123; guard sender.state == .ended else &#123; return &#125; //tap1-3. if !isQuadruple &#123; imageView.transform = imageView.transform.scaledBy(x: 2, y: 2) &#125; else &#123; imageView.transform = .identity &#125; isQuadruple = !isQuadruple &#125; 2-1. identity는 초기화상태로 되돌리기. (다시 더블 클릭시 원래상태로 복구) 3. Rotation시 회전 123456// MARK: Rotation@IBAction private func handleRotationGesture(_ sender: UIRotationGestureRecognizer)&#123; guard sender.state == .began || sender.state == .changed else &#123; return &#125; imageView.transform = imageView.transform.rotated(by: sender.rotation) sender.rotation = 0 //회전수 &#125; 4. Swipe 방향에 따른 이미지변경 1234567891011121314// MARK: Swipe//으론쪽으로 밀면(스와이프) = cat2//왼쪽으로 밀면(스와이프) = cat1@IBAction private func handleSwipeGesture(_ sender: UISwipeGestureRecognizer)&#123; guard sender.state == .ended else &#123; return &#125; if sender.direction == .left &#123; imageView.image = UIImage(named: \"cat1\") sender.direction = .right &#125; else &#123; imageView.image = UIImage(named: \"cat2\") sender.direction = .left &#125;&#125; 전체코드 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//// GestureViewController.swift// GestureRecognizerExample//// Copyright © 2020 Giftbot. All rights reserved.//import UIKitfinal class GestureViewController: UIViewController &#123; @IBOutlet private weak var imageView: UIImageView!&#123; //tap1-1. didSet &#123; imageView.layer.cornerRadius = imageView.frame.width / 2 imageView.clipsToBounds = true &#125; &#125; //tap1-2. var isQuadruple = false // MARK: Tap //더블탭 하면 이미지가 원본의 4배 크기로 &lt;-&gt; 원본으로 @IBAction private func handleTapGesture(_ sender: UITapGestureRecognizer)&#123; guard sender.state == .ended else &#123; return &#125; //tap1-3. if !isQuadruple &#123; imageView.transform = imageView.transform.scaledBy(x: 2, y: 2) &#125; else &#123; imageView.transform = .identity &#125; isQuadruple = !isQuadruple &#125; // MARK: Rotation @IBAction private func handleRotationGesture(_ sender: UIRotationGestureRecognizer)&#123; guard sender.state == .began || sender.state == .changed else &#123; return &#125; imageView.transform = imageView.transform.rotated(by: sender.rotation) sender.rotation = 0 //회전수 &#125; // MARK: Swipe //오른쪽 스와이프 = cat2 //왼쪽 스와이프 = cat1 @IBAction private func handleSwipeGesture(_ sender: UISwipeGestureRecognizer)&#123; guard sender.state == .ended else &#123; return &#125; if sender.direction == .left &#123; imageView.image = UIImage(named: \"cat1\") sender.direction = .right &#125; else &#123; imageView.image = UIImage(named: \"cat2\") sender.direction = .left &#125; &#125;&#125; 보충링크 : (http://minsone.github.io/mac/ios/uigesturerecognizer)","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"Gesture","slug":"Gesture","permalink":"https://qussk.github.io/tags/Gesture/"}]},{"title":"[Swift]Tuch 이해하기(touch로 이미지 끌어오기)","slug":"Swift-touch-이해하기","date":"2020-06-25T13:18:24.000Z","updated":"2020-09-14T08:28:54.140Z","comments":false,"path":"2020/06/25/Swift-touch-이해하기/","link":"2020/06/25/Swift-touch-이해하기","permalink":"https://qussk.github.io/2020/06/25/Swift-touch-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/","excerpt":"","text":"0. 터치를 적용할 이미지뷰 준비 123456 @IBOutlet private weak var imageView: UIImageView!&#123; didSet &#123; imageView.layer.cornerRadius = imageView.bounds.width / 2 imageView.clipsToBounds = true &#125;&#125; 1. touch 메소드 1234567891011121314151617//터치 시작 override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; &#125; //터치중 override func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; &#125; //터치종료 override func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; &lt;#code#&gt; &#125; //터치취소, 시스템 인터렙션, inactive상태, 터치중인 뷰가 제거될 떄 override func touchesCancelled(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; &lt;#code#&gt; &#125;&#125; 1-1. 이름만봐도 대충 느낌을 알 수 있다… ㅋ 2. touch적용해보기 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 //터치 시작 override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; super.touchesBegan(touches, with: event) guard let touch = touches.first else &#123; return &#125; print(touch) let touchPoint = touch.location(in: touch.view) //정확하게 어디(터치포인트)를 터치했는지. print(touchPoint) imageView.image = UIImage(named: \"cat2\") &#125; //터치중 override func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; super.touchesMoved(touches, with: event) guard let touch = touches.first else &#123; return &#125; print(\"----touchesMoved----\") let touchPoint = touch.location(in: touch.view) //정확하게 어디(터치포인트)를 터치했는지. print(touchPoint) &#125; //터치종료 override func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; super.touchesEnded(touches, with: event) guard let touch = touches.first else &#123; return &#125; print(\"----touchesEnded----\") let touchPoint = touch.location(in: touch.view) //정확하게 어디(터치포인트)를 터치했는지. print(touchPoint) imageView.image = UIImage(named: \"cat2\") &#125; //터치취소, 시스템 인터렙션, inactive상태, 터치중인 뷰가 제거될 떄 override func touchesCancelled(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; super.touchesCancelled(touches, with: event) guard let touch = touches.first else &#123; return &#125; print(\"----touchesCancelled---\") let touchPoint = touch.location(in: touch.view) //정확하게 어디(터치포인트)를 터치했는지. print(touchPoint) &#125;&#125; 2-1. 터치 상태에 print를 주어 확인했다. 디버깅이 위치에 따라 프린팅 된다. 3. 이미지 반응 구현 (클릭, 움직임에 따라 이미지뷰 이동 - touchPoint와 toggle이용) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import UIKit// 1. - 클릭시 이미지 변환(제스처 메서드 이용)// 1.5 - 마우스 움직임을 따라서 이미지뷰가 함께 움직이도록 구현// 2.- 이미지를 클릭했을 경우에만 마우스 움직임을 따라 이미지뷰가 반응하도록 구현// 3. 다른 방법?final class TouchViewController: UIViewController &#123; @IBOutlet private weak var imageView: UIImageView!&#123; didSet &#123; imageView.layer.cornerRadius = imageView.bounds.width / 2 imageView.clipsToBounds = true &#125;&#125; //2-1. 눌렀는지 안눌렀는지에 대한 정보 var isHoldingImage = false // MARK: - Touch //터치 시작 override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; super.touchesBegan(touches, with: event) guard let touch = touches.first else &#123; return &#125; print(touch) let touchPoint = touch.location(in: touch.view) //정확하게 어디(터치포인트)를 터치했는지. print(touchPoint) //이미지뷰 원점 + 크기를 구하는 방법도 있지만 더 쉽게 제공되는 메서드 있음 // if imageView.frame.contains(touchPoint) if imageView.frame.contains(touchPoint) &#123; //1-1. 이미지반응 (클릭시 cat2이미지) imageView.image = UIImage(named: \"cat2\") //2-2. isHoldingImage = true &#125; &#125; //터치중 override func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; super.touchesMoved(touches, with: event) guard isHoldingImage, let touch = touches.first else &#123; return &#125; let touchPoint = touch.location(in: touch.view) if imageView.frame.contains(touchPoint) &#123; //2-0. 이미지 이동 (이것만하면 뚝뚝 끊김) imageView.center = touchPoint //2-3. 트루일때만 동작하도록 isHoldingImage = true &#125; &#125; //터치종료 override func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; super.touchesEnded(touches, with: event) guard isHoldingImage else &#123; return &#125; //2-4. 끄기 (토클로 꺼도 무관) isHoldingImage.toggle() //초기화로 펄스상태 만듦. //1-2. 종료시 다시 cat1이미지 imageView.image = UIImage(named: \"cat1\") &#125; //터치취소, 시스템 인터렙션, inactive상태, 터치중인 뷰가 제거될 떄 override func touchesCancelled(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; super.touchesCancelled(touches, with: event) guard isHoldingImage else &#123; return &#125; isHoldingImage.toggle() //2-4. imageView.image = UIImage(named: \"cat1\") //1-2. &#125;&#125; 3-1. 이미지 이동할 수 있도록 center에 touchPoint를 준다. 1imageView.center = touchPoint 하지만, 이렇게만 주면 뚝뚝 끊긴다. (위 코드중 2-0 ~ 2-4 참고.) 3-1. touchesBegan(터치시작) 했을 때, 이미지 변경. 1imageView.image = UIImage(named: \"cat2\") 3-2. touchesBegan(터치시작) 했을때, 1if imageView.frame.contains(touchPoint) &#123; touchPoint 에 접근했을 때 1isHoldingImage = true 을 주어 끊김현상 방지. 4. 이미지 반응 구현 (클릭, 움직임에 따라 이미지뷰 이동 - lastTouchPoint, previousLocation이용) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import UIKit// 1. - 클릭시 이미지 변환(제스처 메서드 이용)// 1.5 - 마우스 움직임을 따라서 이미지뷰가 함께 움직이도록 구현// 2.- 이미지를 클릭했을 경우에만 마우스 움직임을 따라 이미지뷰가 반응하도록 구현// 3. 다른 방법?final class TouchViewController: UIViewController &#123; @IBOutlet private weak var imageView: UIImageView!&#123; didSet &#123; imageView.layer.cornerRadius = imageView.bounds.width / 2 imageView.clipsToBounds = true &#125;&#125; //2-1. 눌렀는지 안눌렀는지에 대한 정보 var isHoldingImage = false //3-1. 라스트 터치포인트 기억시키기 var lastTouchPoint = CGPoint.zero // MARK: - Touch //터치 시작 override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; super.touchesBegan(touches, with: event) guard let touch = touches.first else &#123; return &#125; print(touch) let touchPoint = touch.location(in: touch.view) //정확하게 어디(터치포인트)를 터치했는지. print(touchPoint) //이미지뷰 원점 + 크기를 구하는 방법도 있지만 더 쉽게 제공되는 메서드 있음 // if imageView.frame.contains(touchPoint) if imageView.frame.contains(touchPoint) &#123; //1-1. 이미지반응 (클릭시 cat2이미지) imageView.image = UIImage(named: \"cat2\") //2-2. isHoldingImage = true //3-2. lastTouchPoint = touchPoint &#125; &#125; //터치중 override func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; super.touchesMoved(touches, with: event) guard isHoldingImage, let touch = touches.first else &#123; return &#125; let touchPoint = touch.location(in: touch.view) //3-3. // currenTouchPoint = 100 (움직인위치) // lastTouchPoint = 150 (시작위치) // 100 - 150 = -50 (이동거리) //방법1.3-3. lastTouchPoint이용 //x의 이동거리, y의 이동거리를 센터x랑 센터y에게 더해준 것. // imageView.center.x = imageView.center.x + (touchPoint.x - lastTouchPoint.x) // imageView.center.y = imageView.center.y + (touchPoint.y - lastTouchPoint.y) // lastTouchPoint = touchPoint //lastTouchPoint처음위치부터 계산됨. //방법2.3-3.previousLocation이용 (lastTouchPoint와 비슷) touch.previousLocation: 직전의 터치포인트를 기억했다가 알려주는것. let prevTouchPoint = touch.previousLocation(in: touch.view) imageView.center.x = imageView.center.x + (touchPoint.x - prevTouchPoint.x) imageView.center.y = imageView.center.y + (touchPoint.y - prevTouchPoint.y) //점에서 점으로 이동했을때, 센터x랑,y한테 그 이동거리만큼 움직여라 &#125; //터치종료 override func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; super.touchesEnded(touches, with: event) guard isHoldingImage else &#123; return &#125; //2-4. 끄기 (토클로 꺼도 무관) isHoldingImage.toggle() //초기화로 펄스상태 만듦. //1-2. 종료시 다시 cat1이미지 imageView.image = UIImage(named: \"cat1\") &#125; //터치취소, 시스템 인터렙션, inactive상태, 터치중인 뷰가 제거될 떄 override func touchesCancelled(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; super.touchesCancelled(touches, with: event) guard isHoldingImage else &#123; return &#125; isHoldingImage.toggle() //2-4. imageView.image = UIImage(named: \"cat1\") //1-2. &#125;&#125; 4-1. 둘의 차이가 있다면, lastTouchPoint는 개발자가 저장한 값, previousLocation는 프레임워크에서 지원하는 값. 4-2. 3의 방법보다 lastTouchPoint와 previousLocation를 이용하는게 훨씬 깔끔? 할 것 같다는 개인적인 생각. 5. shack 모션달기(Bonus) 1234567891011121314151617181920212223// MARK: Motion override func motionBegan(_ motion: UIEvent.EventSubtype, with event: UIEvent?) &#123; super.motionBegan(motion, with: event) if motion == .motionShake &#123; imageView.image = UIImage(named: \"cat2\") &#125; &#125; override func motionEnded(_ motion: UIEvent.EventSubtype, with event: UIEvent?) &#123; super.motionEnded(motion, with: event) if motion == .motionShake &#123; imageView.image = UIImage(named: \"cat1\") &#125; &#125; override func motionCancelled(_ motion: UIEvent.EventSubtype, with event: UIEvent?) &#123; super.motionCancelled(motion, with: event) if motion == .motionShake &#123; imageView.image = UIImage(named: \"cat1\") &#125; &#125;&#125; 전체코드 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//// TouchViewController.swift// GestureRecognizerExample//// Copyright © 2020 giftbot. All rights reserved.//import UIKitfinal class TouchViewController: UIViewController &#123; @IBOutlet private weak var imageView: UIImageView! &#123; didSet &#123; imageView.layer.cornerRadius = imageView.frame.width / 2 imageView.clipsToBounds = true &#125; &#125; var isHoldingImage = false var lastTouchPoint = CGPoint.zero // MARK: Touch override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; super.touchesBegan(touches, with: event) guard let touch = touches.first else &#123; return &#125; let touchPoint = touch.location(in: touch.view) if imageView.frame.contains(touchPoint) &#123; imageView.image = UIImage(named: \"cat2\") isHoldingImage = true lastTouchPoint = touchPoint &#125; &#125; override func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; super.touchesMoved(touches, with: event) guard isHoldingImage, let touch = touches.first else &#123; return &#125; let touchPoint = touch.location(in: touch.view) // imageView.center.x = imageView.center.x + (touchPoint.x - lastTouchPoint.x)// imageView.center.y = imageView.center.y + (touchPoint.y - lastTouchPoint.y)// lastTouchPoint = touchPoint let prevTouchPoint = touch.previousLocation(in: touch.view) imageView.center.x = imageView.center.x + (touchPoint.x - prevTouchPoint.x) imageView.center.y = imageView.center.y + (touchPoint.y - prevTouchPoint.y) &#125; override func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; super.touchesEnded(touches, with: event) guard isHoldingImage else &#123; return &#125; isHoldingImage.toggle() imageView.image = UIImage(named: \"cat1\") &#125; override func touchesCancelled(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; super.touchesCancelled(touches, with: event) guard isHoldingImage else &#123; return &#125; isHoldingImage.toggle() imageView.image = UIImage(named: \"cat1\") &#125; // MARK: Motion override func motionBegan(_ motion: UIEvent.EventSubtype, with event: UIEvent?) &#123; super.motionBegan(motion, with: event) if motion == .motionShake &#123; imageView.image = UIImage(named: \"cat2\") &#125; &#125; override func motionEnded(_ motion: UIEvent.EventSubtype, with event: UIEvent?) &#123; super.motionEnded(motion, with: event) if motion == .motionShake &#123; imageView.image = UIImage(named: \"cat1\") &#125; &#125; override func motionCancelled(_ motion: UIEvent.EventSubtype, with event: UIEvent?) &#123; super.motionCancelled(motion, with: event) if motion == .motionShake &#123; imageView.image = UIImage(named: \"cat1\") &#125; &#125;&#125;","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"ImageView","slug":"ImageView","permalink":"https://qussk.github.io/tags/ImageView/"},{"name":"Touch","slug":"Touch","permalink":"https://qussk.github.io/tags/Touch/"}]},{"title":"[Swift]MapKit 이해하기-4(with: MKOverlayRenderer)","slug":"Swift-MapKit-이해하기-4","date":"2020-06-23T15:36:44.000Z","updated":"2020-09-14T08:28:54.126Z","comments":false,"path":"2020/06/24/Swift-MapKit-이해하기-4/","link":"2020/06/23/Swift-MapKit-이해하기-4","permalink":"https://qussk.github.io/2020/06/24/Swift-MapKit-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-4/","excerpt":"","text":"1import MapKit 맵킷 가져오기 1. '원’그림으로 반경 추가하기.(MKCircle) 123456@IBAction func addCircle(_ sender: Any) &#123; let center = mapView.centerCoordinate // 44000m = 44km let circle = MKCircle(center: center, radius: 44000) mapView.addOverlay(circle)&#125; 1-1. 원 = center 화면 중앙, radius: 44000은 44km값. 2. '별그림’으로 반경 추가하기.(MKPolyline) 123456789101112131415@IBAction func addStar(_ sender: Any) &#123; //별 컬러 및 굵기 지정 let center = mapView.centerCoordinate var point1 = center; point1.latitude += 0.4 var point2 = center; point2.longitude += 0.32; point2.latitude -= 0.30 var point3 = center; point3.longitude -= 0.45; point3.latitude += 0.15 var point4 = center; point4.longitude += 0.45; point4.latitude += 0.15 var point5 = center; point5.longitude -= 0.32; point5.latitude -= 0.30 let points: [CLLocationCoordinate2D] = [point1, point2, point3, point4, point5, point1] //2-1. let polyline = MKPolyline(coordinates: points, count: points.count)//2-2 mapView.addOverlay(polyline)&#125; 2-1. 마지막 배열 왜 point1을 넣었을까? point1로 돌아와야하기 때문. 1let points: [CLLocationCoordinate2D] = [point1, point2, point3, point4, point5, point1] 2-2. points: 특정 점들의 count: 카운트만큼. 3. MKMapViewDelegate(MKCircle,polyline) 12345678910111213141516171819// MARK: - MKMapViewDelegateextension RendererOverlayViewController: MKMapViewDelegate &#123; func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -&gt; MKOverlayRenderer &#123; if let circle = overlay as? MKCircle &#123; //MKCircle일때 작성. let renderer = MKCircleRenderer(circle: circle) renderer.strokeColor = UIColor.blue renderer.lineWidth = 2 return renderer &#125; if let polyline = overlay as? MKPolyline &#123; //아니면, MKPolyline을 반환 let renderer = MKPolylineRenderer(polyline: polyline) renderer.lineWidth = 2 renderer.strokeColor = .red return renderer &#125; return MKOverlayRenderer(overlay: overlay) &#125;&#125; 3-1. MKCircled일때 작성, MKCircled이 아니면, MKPolyline을 반환. 4. overlays 지우기 123@IBAction private func removeOverlays(_ sender: Any) &#123; mapView.removeOverlays(mapView.overlays)&#125; 추가로, 아래에 확대하면 별이 커진 것처럼 제스처로 화면을 최대한 작게하면 별이 작아진다 !!!","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"MapKit","slug":"MapKit","permalink":"https://qussk.github.io/tags/MapKit/"}]},{"title":"[Swift]MapKit 이해하기-3","slug":"Swift-MapKit-이해하기-3","date":"2020-06-23T14:58:36.000Z","updated":"2020-09-14T08:28:54.125Z","comments":false,"path":"2020/06/23/Swift-MapKit-이해하기-3/","link":"2020/06/23/Swift-MapKit-이해하기-3","permalink":"https://qussk.github.io/2020/06/23/Swift-MapKit-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-3/","excerpt":"","text":"1import MapKit 1. CLLocationCoordinate2DMake 123456override func viewDidAppear(_ animated: Bool) &#123; super.viewDidAppear(animated) // 시청 위치 let center = CLLocationCoordinate2DMake(37.566308, 126.977948) setRegion(coordinate: center) &#125; 1-1. app켜질때 시청위치 기본값으로 가져옴. 2. 위치 핀 사용하여 추가. (MKPointAnnotation) 123456//내가 원하는 위경도값 가져옴. private func setRegion(coordinate: CLLocationCoordinate2D) &#123; let span = MKCoordinateSpan(latitudeDelta: 0.1, longitudeDelta: 0.1) let region = MKCoordinateRegion(center: coordinate, span: span) mapView.setRegion(region, animated: true) &#125; 2-1. 내가 원하는 위경도값 가져오기. 1234567891011121314151617181920212223//위치추가@IBAction private func addAnnotation(_ sender: Any) &#123; let cityHall = MKPointAnnotation() cityHall.title = \"시청\" cityHall.subtitle = \"서울특별시\" cityHall.coordinate = CLLocationCoordinate2DMake(37.566308, 126.977948) mapView.addAnnotation(cityHall) let namsan = MKPointAnnotation() namsan.title = \"남산\" namsan.coordinate = CLLocationCoordinate2DMake(37.551416, 126.988194) mapView.addAnnotation(namsan) let gimpoAirport = MKPointAnnotation() gimpoAirport.title = \"김포공항\" gimpoAirport.coordinate = CLLocationCoordinate2DMake(37.559670, 126.794320) mapView.addAnnotation(gimpoAirport) let gangnam = MKPointAnnotation() gangnam.title = \"강남역\" gangnam.coordinate = CLLocationCoordinate2DMake(37.498149, 127.027623) mapView.addAnnotation(gangnam) &#125; 2-2. “핀추가” 눌렀을 때, 해당 위,경도에 대한 위치에 핀 꽂기 3. 랜덤 핀으로 이동 123456@IBAction private func moveToRandomPin(_ sender: Any) &#123; guard mapView.annotations.count &gt; 0 else &#123; return &#125; let random = Int.random(in: 0..&lt;mapView.annotations.count) //0 이상이면 let annotation = mapView.annotations[random] //랜덤값 가져오기. setRegion(coordinate: annotation.coordinate) //그 위치로 이동하도록 &#125; 3-1. 0개 이상이면, 랜덤으로 핀으로 위치 이동하기 4. 핀 제거하기 123@IBAction private func removeAnnotation(_ sender: Any) &#123; mapView.removeAnnotations(mapView.annotations) &#125; 4-1. removeAnnotations 이용 5. 카메라로 보기 123456789@IBAction private func setupCamera(_ sender: Any) &#123; let camera = MKMapCamera() let coordinate = CLLocationCoordinate2DMake(37.551416, 126.988194) camera.centerCoordinate = coordinate camera.centerCoordinateDistance = 200 // 고도 camera.pitch = 70.0 // 카메라 각도 (0일 때 수직으로 내려다보는 형태) camera.heading = 0 // 카메라 방향 mapView.setCamera(camera, animated: true)&#125; 5-1. centerCoordinateDistance 고도는 m단위임 5-2. camera.heading 카메라 방향 0 ~ 360 (맵을 바라보는 방향)","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"MapKit","slug":"MapKit","permalink":"https://qussk.github.io/tags/MapKit/"}]},{"title":"[Swift]MapKit이해하기-2(with: Geocoding)","slug":"Swift-MapKit이해하기-2-with-Geocoding","date":"2020-06-23T14:43:19.000Z","updated":"2020-09-14T08:28:54.127Z","comments":false,"path":"2020/06/23/Swift-MapKit이해하기-2-with-Geocoding/","link":"2020/06/23/Swift-MapKit이해하기-2-with-Geocoding","permalink":"https://qussk.github.io/2020/06/23/Swift-MapKit%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-2-with-Geocoding/","excerpt":"","text":"1import MapKit 1. 제스처를 이용 (gesture: UITapGestureRecognizer) 123456789//내가 터치한 위치가 위경도 값의 어디에 해당되는지 @IBAction func recognizeTap(gesture: UITapGestureRecognizer) &#123; let touchPoint = gesture.location(in: gesture.view) //제스처.터치포인트 let coordinate = mapView.convert(touchPoint, toCoordinateFrom: mapView) let location = CLLocation(latitude: coordinate.latitude, longitude: coordinate.longitude) //2.참고 reverseGeocode(location: location) 2. everseGeocodeLocation(위경도 값에서 주소값 가져오기) 12345678910111213141516171819202122func reverseGeocode(location: CLLocation) &#123; let geocoder = CLGeocoder() //reverseGeocodeLocation: 위경도값에서 주소값가져오기. geocoder.reverseGeocodeLocation(location) &#123; placeMark, error in print(\"\\n---------- [ 위경도 -&gt; 주소 ] ----------\") if error != nil &#123; return print(error!.localizedDescription) &#125; // 국가별 주소체계에 따라 어떤 속성 값을 가질지 다름 guard let address = placeMark?.first, let country = address.country, //대한민국 let administrativeArea = address.administrativeArea, //서울특별시 (시/도) let locality = address.locality, //서초구, 고령군, 광명시, 용산구 (시/군/구) let name = address.name //방배동 2902, 신림동 1428-12 (읍/면/동) else &#123; return &#125; let addr = \"\\(country) \\(administrativeArea) \\(locality) \\(name)\" print(addr) &#125;&#125; 2-1. 위경도 -&gt; 주소로 값 가져오기(print) 123456789101112func geocodeAddressString(_ addressString: String)&#123; print(\"[주소-&gt; 위경도]\") let geocoder = CLGeocoder() geocoder.geocodeAddressString(addressString) &#123; (placeMark, error) in if error != nil &#123; return print(error!.localizedDescription) &#125; guard let place = placeMark?.first else &#123; return &#125; print(place.location?.coordinate)&#125;&#125; 2-2. 주소 -&gt; 위경도로 값 가져오기(print)","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"MapKit","slug":"MapKit","permalink":"https://qussk.github.io/tags/MapKit/"}]},{"title":"[Swift]MapKit 이해하기","slug":"Swift-MapKit-이해하기","date":"2020-06-23T13:31:35.000Z","updated":"2020-09-14T08:28:54.126Z","comments":false,"path":"2020/06/23/Swift-MapKit-이해하기/","link":"2020/06/23/Swift-MapKit-이해하기","permalink":"https://qussk.github.io/2020/06/23/Swift-MapKit-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/","excerpt":"","text":"0. import MapKit 1import MapKit 0-1. 임포트를 하게되면 일단 기본적인 맵킷이 나온다. 1. 권한요청 123456789101112private func checkAuthorizationStatus() &#123;switch CLLocationManager.authorizationStatus() &#123;case .notDetermined: locationManager.requestWhenInUseAuthorization()case .restricted, .denied: breakcase .authorizedWhenInUse: fallthroughcase .authorizedAlways: startUpdatingLocation()@unknown default: fatalError()&#125;&#125; 1-1. info.plist에서 권한요청하기. (Privacy - Location When In Use Usage Description) 1-2. @컴파일러가 별도의 키워드로 인식하기 위해 필요한 것. (Attribut) 2. CLLocationManager 123456789private func startUpdatingLocation() &#123; let status = CLLocationManager.authorizationStatus() guard status == .authorizedAlways || status == .authorizedWhenInUse, CLLocationManager.locationServicesEnabled() else &#123; return &#125; locationManager.desiredAccuracy = kCLLocationAccuracyBest locationManager.distanceFilter = kCLHeadingFilterNone locationManager.startUpdatingLocation()&#125; 2-1. status 사용자가 위치정보 서비스를 허용했는지 안했는지 체크 2-2. kCLLocationAccuracyNearestTenMeters 10미터 단위로 (기본값은 kCLLocationAccuracyBest) 단, 너무 짧을 경우 베터리 소진량 늘어남 2-3. startUpdatingLocation 실제로 update를 요청하는 값 3. CLLocationManagerDelegate 1locationManager.delegate = self 3-1. delegate self선언 123456789101112131415161718192021222324252627282930313233extension MyLocationViewController: CLLocationManagerDelegate &#123;func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) &#123; switch status &#123; case .authorizedWhenInUse, .authorizedAlways: print(\"Authorized\") default: print(\"Unauthorized\") &#125;&#125;func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) &#123; let current = locations.last! //라스트 값을 가져옴. if (abs(current.timestamp.timeIntervalSinceNow) &lt; 10) &#123; let coordinate = current.coordinate // Span 단위는 1도 // 경도 1도는 약 111킬로미터. 위도 1도는 위도에 따라 변함. // 적도 (약 111 Km) ~ 극지방 (0 Km) let span = MKCoordinateSpan(latitudeDelta: 0.002, longitudeDelta: 0.002) let region = MKCoordinateRegion(center: coordinate, span: span) mapView.setRegion(region, animated: true) addAnnotation(location: current) &#125;&#125;func addAnnotation(location: CLLocation) &#123; let annotation = MKPointAnnotation() annotation.title = \"MyLocation\" annotation.coordinate = location.coordinate mapView.addAnnotation(annotation) &#125; 3-2. didChangeAuthorization 권한 확인(1.의 checkAuthorizationStatus부분.) 3-3. didUpdateLocations 로케이션(위치)의 정보를 받는곳 3-4. addAnnotation는 위치 라벨(네임) 가져오기. 3-5. span값 넓힐 수록 가까이됨. 뷰디드로드에 ( mapView.showsUserLocation = true)로 지정 4. showsUserLocation 12mapView.showsUserLocation = truemapView.mapType = .satellite 4-1. 뷰디드로드에 showsUserLocation = true 5. 방향 추가 12345678910 //방향모니터값 가져오기 @IBAction func mornitoringHeading(_ sender: Any) &#123; guard CLLocationManager.headingAvailable() else &#123; return &#125; locationManager.startUpdatingHeading() &#125; @IBAction func stopMornitoring(_ sender: Any) &#123; locationManager.stopUpdatingHeading() &#125;&#125; 5-1. “방향모니터링”, “방향모니터링중단” Button의 모니터 방향값 가져오기. 12345//방향불러오는 함수 func locationManager(_ manager: CLLocationManager, didUpdateHeading newHeading: CLHeading) &#123; print(\"trueHeading :\", newHeading.trueHeading) // 진북(어디에서든 북쪽 고정) print(\"magneticHeading :\", newHeading.magneticHeading) // 자북 (자기장) &#125; 5-2. didUpdateHeading 이용 6.기타 시뮬레이터에서 해당값을 지정하면, 달리는 모션으로 지도를 볼 수 있음.","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"MapKit","slug":"MapKit","permalink":"https://qussk.github.io/tags/MapKit/"}]},{"title":"[Swift]HeaderView와 FooterView 이용예제","slug":"Swift-HeaderView와-FooterView-이용예제","date":"2020-06-20T18:17:38.000Z","updated":"2020-09-14T08:28:54.122Z","comments":false,"path":"2020/06/21/Swift-HeaderView와-FooterView-이용예제/","link":"2020/06/20/Swift-HeaderView와-FooterView-이용예제","permalink":"https://qussk.github.io/2020/06/21/Swift-HeaderView%EC%99%80-FooterView-%EC%9D%B4%EC%9A%A9%EC%98%88%EC%A0%9C/","excerpt":"","text":"오늘은 해더뷰와 푸터뷰 이용예제에 대해 알아보자 ! 구현사항 123[ 문제 ]셀 크기 &#x3D; (80, 80) &#x2F; 아이템과 라인 간격 &#x3D; 4 &#x2F; 인셋 &#x3D; (25, 5, 25, 5)헤더 높이 50, 푸터 높이 3 CollectionView와, 레이아웃 잡는 것, CollectionCell 크기 inset값 등은 생략 ! 맨 아래 전체코드로 확인하기 ! HeaderView적용 (with:CollectionView) 1. SectionHeaderView class만들기 12345678910111213141516171819202122232425262728293031323334353637import UIKitfinal class SectionHeaderView: UICollectionReusableView &#123; static let identifier = \"SectionHeaderView\" private let titleLabel = UILabel() required init?(coder aDecoder: NSCoder) &#123; fatalError(\"init(coder:) has not been implemented\") &#125; override init(frame: CGRect) &#123; super.init(frame: frame) setupView() &#125; private func setupView() &#123; titleLabel.textColor = .darkText titleLabel.textAlignment = .left titleLabel.font = UIFont.preferredFont(forTextStyle: .title1) addSubview(titleLabel) titleLabel.translatesAutoresizingMaskIntoConstraints = false NSLayoutConstraint.activate([ titleLabel.centerYAnchor.constraint(equalTo: self.centerYAnchor), titleLabel.centerXAnchor.constraint(equalTo: self.centerXAnchor) ]) &#125; // MARK: Configure func configure(title: String) &#123; titleLabel.text = title &#125;&#125; 1-1. 일단, 헤더뷰든 푸터뷰든 UICollectionReusableView를 만들어야한다. 헤더뷰에 대한 swift파일을 하나 만들어 class만들기. 1class SectionHeaderView: UICollectionReusableView &#123; 1-2. 헤더뷰의 identifier이름과, 헤더뷰에 들어갈 titleLable을 선언. 12static let identifier = \"SectionHeaderView\" private let titleLabel = UILabel() 1-3. override init 부분은 titleLable의 frame에 대한 함수호출. 1234override init(frame: CGRect) &#123; super.init(frame: frame) setupView() &#125; 2. layout HeaderView 에 대한 설정은 끝났고, 메인 viewController로 돌아와, 컬렉션뷰 레이아웃 잡는 위치(레이아웃을 리턴하는 곳. return layout )에 해더뷰의 레이아웃도 함께 지정해준다. 헤더뷰는 어쨌든 컬렉션뷰 위에 놓는 거니까… 2-1 헤더뷰 레이아웃 1layout.headerReferenceSize = CGSize(width: 50, height: 50) 2-2. 스크롤중 해당 해더뷰의 섹션값과 가까워질 때, 헤더뷰가 투명해지는 옵션 ! 1layout.sectionHeadersPinToVisibleBounds = true 2-3. 리턴 1return layout 3. register 지정 3-1. collectionView의 register를 지정했던 곳 아래에 register을 지정해준다. 12collectionView.register(SectionHeaderView.self, forSupplementaryViewOfKind: UICollectionView.elementKindSectionHeader, withReuseIdentifier: SectionHeaderView.identifier) 3-2. 첫번째, 해더뷰의 이름을 줄러준다. SectionHeaderView.self(1-2부분 참고.) 두번째, UICollectionView.elementKindSectionHeader, (UICollectionView에 elementKindSectionHeader을 둔다는 뜻. 아래 5-1부분 참고.) 세번째, withReuseIdentifier: SectionHeaderView.identifier. identifier 이름 넣기. 4. numberOfSections 지정. 4-1. 알다시피, 우리는 collectionView 위에 헤더뷰를 놓는 거니까, UICollectionViewDataSource 부분에 numberOfSections(섹션 갯수)함수를 불러 지정. (collectionView의 numberOfItemsInSection과 다르다 !!!😡 ) 1234567// MARK: - UICollectionViewDataSourceextension SupplementaryViewController: UICollectionViewDataSource &#123; func numberOfSections(in collectionView: UICollectionView) -&gt; Int &#123; sections.count &#125; 4-2. sections.count는 아래의 데이터 부분을 참고하자. 대충 이해가 가죠?? 5. header을 리턴… 집중! 5-1. UICollectionReusableView를 리턴하는 함수가 있다! viewForSupplementaryElementOfKind 헤더뷰와 푸터뷰를 리턴할 때 모두 사용. 1234567func collectionView(_ collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, at indexPath: IndexPath) -&gt; UICollectionReusableView &#123; let header = collectionView.dequeueReusableSupplementaryView(ofKind: kind, withReuseIdentifier: \"SectionHeaderView\", for: indexPath) as! SectionHeaderView header.configure(title: \"sections:\\(indexPath.section + 1)\") return header 5-2. cellforrowitem에서 하는 것처럼 비슷하게 타입캐스팅 해주면 된다. ofKind는 kind 넣어주고, withReuseIdentifier는 해더뷰의 Identifier이름. 5-3. header.configure(title: “sections:(indexPath.section + 1)”)은 indexPath.section만 할경우 섹션 0 부터 시작하므로, 1부터 시작하기 위해 +1해줬다. 그러면. ? 해더뷰에 대한 할일은 모두 했으니 빌드해보자., 짠… 아래로 내리면…? 2-2 에서 적용했던 layout.sectionHeadersPinToVisibleBounds = true 으로 투명해지는 모습까지 확인할 수 있다. 🤤 해더 뷰를 끝냈으니, 빨간색 점선의 FooterView도 적용해 보자! FooterView적용 (with:CollectionView) 사실, 과정은 headerview와 거의 동일하다 ㅋㅋ 위를 참고하며 보기 ! Class SectionFooterView 1234567891011121314151617181920212223242526272829303132333435363738394041424344import UIKitclass SectionFoorterView: UICollectionReusableView &#123; static let identifire = \"SectionFoorterView\" let foorterLable = UILabel() required init?(coder aDecoder: NSCoder) &#123; fatalError(\"init(coder:) has not been implemented\") &#125; override init(frame: CGRect) &#123; super.init(frame: frame) setupView() &#125; func setupView() &#123; foorterLable.backgroundColor = .systemGray foorterLable.textColor = .black foorterLable.textAlignment = .right // foorterLable.font = UIFont.boldSystemFont(ofSize: 17) addSubview(foorterLable) foorterLable.translatesAutoresizingMaskIntoConstraints = false foorterLable.topAnchor.constraint(equalTo: self.topAnchor).isActive = true foorterLable.leadingAnchor.constraint(equalTo: self.leadingAnchor).isActive = true foorterLable.bottomAnchor.constraint(equalTo: self.bottomAnchor).isActive = true foorterLable.trailingAnchor.constraint(equalTo: self.trailingAnchor).isActive = true &#125; func configure(title: String) &#123; foorterLable.text = title &#125; &#125;","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"CollectionView","slug":"CollectionView","permalink":"https://qussk.github.io/tags/CollectionView/"},{"name":"HeaderView","slug":"HeaderView","permalink":"https://qussk.github.io/tags/HeaderView/"},{"name":"FooterView","slug":"FooterView","permalink":"https://qussk.github.io/tags/FooterView/"}]},{"title":"[Swift]Slider 이용예제(with: CollectionView)","slug":"Swift-Slider-이용예제","date":"2020-06-18T10:29:55.000Z","updated":"2020-09-14T08:28:54.130Z","comments":false,"path":"2020/06/18/Swift-Slider-이용예제/","link":"2020/06/18/Swift-Slider-이용예제","permalink":"https://qussk.github.io/2020/06/18/Swift-Slider-%EC%9D%B4%EC%9A%A9%EC%98%88%EC%A0%9C/","excerpt":"","text":"1. Slider 만들기 흔히 이용하는 sliderBar를 만들어보자 ! [애플문서 바로가기&gt;&gt;] sliderBar에 대해 깊게 공부하고 싶다면 아래 링크의 애플문서를 참고하자 ! 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import UIKitfinal class BasicCodeViewController: UIViewController &#123; // MARK: LifeCycle override func viewDidLoad() &#123; super.viewDidLoad() setupSliders() setupNavigationItem() &#125; // MARK: Setup Views func setupSliders() &#123; // 셀 크기 조절 let sizeSlider = UISlider() sizeSlider.minimumValue = 10 sizeSlider.maximumValue = 200 sizeSlider.value = 50 // 셀 간격 조절 let spacingSlider = UISlider() spacingSlider.minimumValue = 0 spacingSlider.maximumValue = 50 spacingSlider.value = 10 spacingSlider.tag = 1 // 셀 외부여백 조절 let edgeSlider = UISlider() edgeSlider.minimumValue = 0 edgeSlider.maximumValue = 50 edgeSlider.value = 10 edgeSlider.tag = 2 let sliders = [sizeSlider, spacingSlider, edgeSlider] sliders.forEach &#123; $0.addTarget(self, action: #selector(editLayout), for: .valueChanged) &#125; //스택뷰 let stackView = UIStackView(arrangedSubviews: sliders) view.addSubview(stackView) stackView.axis = .vertical //가로.세로 stackView.alignment = .fill //정렬 stackView.spacing = 10 //슬라이더간의 간격 //스택뷰 오토레이아웃 stackView.translatesAutoresizingMaskIntoConstraints = false NSLayoutConstraint.activate([ stackView.centerXAnchor.constraint(equalTo: view.centerXAnchor), stackView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 10), stackView.widthAnchor.constraint(equalToConstant: 300) ]) controllerStackView = stackView &#125; 1-1. let sizeSlider = UISlider() 로 Slider를 만들어준다. 1-2. Slider의 minimumValue 는 최소값, maximumValue 최대값이다. 1-3. Slider의 현재값(value)을 지정해 놓을 수 있다. 1-4. 여러개가 필요한 경우 tag로 구분해준다. 1-5. addTarget을 해준다. 슬라이더에 따라 값 변경이 필요한 경우 .valueChanged를 이용한다. (여러개인 경우 forEach를 활용하여 코드 수를 줄이자!) 1-6. 아래 스택뷰는, slider의 위치를 stackView로 잡고, stackView의 오토레이아웃까지 잡아준 모습. 2. Slider value지정 1-5. 의 addTarget시 이용한 editLayout을 보자. .valueChanged값을 변경하는 것으로 지정한건데, '무엇을?'을 지정해주지 않았다. 12345678910111213141516//에디팅 레이아웃@objc private func editLayout(_ sender: UISlider) &#123; let layout = collectionView.collectionViewLayout as! UICollectionViewFlowLayout if sender.tag == 0 &#123; //셀크기 let size = CGFloat(sender.value) layout.itemSize = CGSize(width: size, height: size) &#125;else if sender.tag == 1 &#123; //셀간격 layout.minimumLineSpacing = CGFloat(sender.value) //value? layout.minimumInteritemSpacing = CGFloat(sender.value) &#125;else &#123; //외부여백 let v = CGFloat(sender.value) let inset = UIEdgeInsets(top: v, left: v, bottom: v, right: v) layout.sectionInset = inset &#125;&#125; 2-1. 먼저, Slider값에 따라 CollectionView의 layout값을 바꿔줄 것이기 때문에 layout을 불러온다. layout 123452-2. 조건문을 이용하여, 첫번째 Slider의 경우, 두번째 Slider의 경우, 세번째 Slider의 경우, 값변경을 어떻게 줄건지 선언한다. 2-3. tag &#x3D;&#x3D; 0의 경우, 셀 크기를 달리하는 영역이다. &#96;&#96;&#96;let size &#x3D; CGFloat(sender.value) 로 선언하고, 이 후 layout의 itemSize가 CGSize(width: size, height: size) value값에 따라 CGSize가 유동적으로 바뀌도록 한다. tag == 1 은 셀의 간격, tag == 2(else로 처리)는 외부 여백을 뜻한다. 2-4. sectionInset은 섹션 안에 여백을 얼마나 줄 것인가. 에 대한 문제. 그러면 ? 여기까지는 나온다. 그런데 Slider를 조절하려하면 팅긴다. 그리고 Cell은 어디갔지? 할 수 있는데 우리, 애초에 Cell을 안만들어 줬자냐, 😅🤪 !! Cell 만들러 고고 ! 3. Cell 만들고 layout잡기 셀을 호다닥 만든다. 1234567891011extension BasicCodeViewController: UICollectionViewDataSource &#123; func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123; return itemCount &#125; func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123; let cell = collectionView.dequeueReusableCell(withReuseIdentifier: \"Cell\", for: indexPath) cell.backgroundColor = [.red, .green, .blue, .magenta, .gray, .cyan ].randomElement() return cell &#125;&#125; 3-1. UICollectionViewDataSource에 numberOfItemsInSection와 cellForItemAt 코드 구성. 3-2. itemCount = 100 이다. 3-3. Cell의 backgroundColor는 베열중 랜덤으로 실행 되도록 .randomElement 이용. 12345678910111213141516171819202122232425func setupCollectionView() &#123;let layout = UICollectionViewFlowLayout() layout.itemSize = CGSize(width: 60, height: 60) // 기본값 (50, 50) layout.minimumInteritemSpacing = 10 // 기본값 10 layout.minimumLineSpacing = 20 // 기본값 10 layout.sectionInset = UIEdgeInsets(top: 5, left: 5, bottom: 5, right: 5) // .zero collectionView = UICollectionView(frame: view.frame, collectionViewLayout: layout) collectionView.backgroundColor = .systemBackground collectionView.dataSource = self collectionView.register(UICollectionViewCell.self, forCellWithReuseIdentifier: \"Cell\") view.addSubview(collectionView) //콜렉션뷰 오토레이아웃 collectionView.translatesAutoresizingMaskIntoConstraints.toggle() NSLayoutConstraint.activate([ collectionView.topAnchor.constraint(equalTo: controllerStackView.bottomAnchor, constant: 10), collectionView.leadingAnchor.constraint(equalTo: view.leadingAnchor), collectionView.bottomAnchor.constraint(equalTo: view.bottomAnchor), collectionView.trailingAnchor.constraint(equalTo: view.trailingAnchor), ])&#125; 3-4. CollercionView는 꼭 UICollectionViewFlowLayout을 지정해줘야만 한다. 3-5. CollercionView의 프레임은 위에 잡은 FlowLayout을 따르도록 한다. (collectionView = UICollectionView(frame: view.frame, collectionViewLayout: layout) 3-6. CollectionView의 register와 오토레이아웃도 잊지 않고 잡아준다. 그러면 ? ? 이렇게 나온다 ! 슬라이더 값을 다르게 주면 ? 이런식으로 조절가능 ! (셀크기를 제일 줄인 모습.) 4. Slider Color지정 그리고 애플문서를 참고해보니 silder에 custom Image나 여러 animation도 추가 할 수 있는 것 같다. 그 중 간단해 보이는 색을 지정해보도록 하자 !! 🤨 1234567let sliders = [sizeSlider, spacingSlider, edgeSlider] sliders.forEach &#123; //$0.minimumTrackTintColor = .brown //왼 //$0.maximumTrackTintColor = .yellow //오 //$0.thumbTintColor = .black //버튼 $0.addTarget(self, action: #selector(editLayout), for: .valueChanged) &#125; 4-1. slider의 addTaget을 잡아준, forEach에서 색을 추가한다. (주석 처리된 곳.) 4-2. minimumTrackTintColor 왼쪽, maximumTrackTintColor 오른쪽 , thumbTintColor 슬라이더 버튼 색을 담당한다. 추가된 모습… ㅋㅋ… 아무리 기본으로 했다지만, 색이 너무 안예쁘다… 5. (Bonus) NavigationBar에 scrollDirection추가하기. NavigationItem 달기. 123456func setupNavigationItem() &#123; let changDirection = UIBarButtonItem( barButtonSystemItem: .reply, target: self, action: #selector(changeCollectionViewDirection(_:)) ) navigationItem.rightBarButtonItems = [changDirection]&#125; scrollDirection UIScrollView는 스크롤 방향을 얻는 방법 scrollDirection은 스크롤 방향에 대한 문의. 123456@objc private func changeCollectionViewDirection(_ sender: Any) &#123; let layout = collectionView.collectionViewLayout as! UICollectionViewFlowLayout let current = layout.scrollDirection layout.scrollDirection = current == .horizontal ? .vertical : .horizontal &#125;&#125; current 버튼을 누를때마다, .horizontal 인경우, .vertical로 바뀌고, vertical은 horizontal로 체인지 됨. horizontal 로 변경된 모습 !!","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"CollectionView","slug":"CollectionView","permalink":"https://qussk.github.io/tags/CollectionView/"},{"name":"Slider","slug":"Slider","permalink":"https://qussk.github.io/tags/Slider/"}]},{"title":"[Swift]CollectionView 이해하기","slug":"Swift-CollectionView-이해하기","date":"2020-06-16T13:54:24.000Z","updated":"2020-09-14T08:28:54.116Z","comments":false,"path":"2020/06/16/Swift-CollectionView-이해하기/","link":"2020/06/16/Swift-CollectionView-이해하기","permalink":"https://qussk.github.io/2020/06/16/Swift-CollectionView-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/","excerpt":"","text":"collectionView와 layout 구조 collectionView 와 TableView 차이 Flow Layout 와 Custom Layout Collectionview 이해하기 0. Cell 만들기. 1234567891011121314151617181920212223242526272829import UIKitfinal class BasicStoryboardViewController: UIViewController &#123; @IBOutlet private weak var collectionView: UICollectionView! let parkImages = ParkManager.imageNames(of: .nationalPark)&#125;//MARK: -UICollectionViewDataSourceextension BasicStoryboardViewController: UICollectionViewDataSource &#123; func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123; return parkImages.count * 3 &#125; func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123; let cell = collectionView.dequeueReusableCell(withReuseIdentifier: \"BasicCell\", for: indexPath) if let imageView = cell.contentView.subviews.first as? UIImageView &#123; imageView.image = UIImage(named: parkImages[indexPath.item % parkImages.count]) cell.layer.cornerRadius = cell.frame.width / 2 &#125; cell.backgroundColor = .green return cell &#125;&#125; TableVikew와 동일하게 numberOfItemsInSection, cellForItemAt 이용. (TableView는 CellForRowAt이다.) 1. Cell등록 (SB와 연동) iteme 올리기 Cell의 identified 지정 2.Cell Size(Collection View Flow Layout) CellSize 변경 결과 3.Cell margin(CollectionView - Section Insets) top, bottom, left, right 에 margin 입력 결과 4. CollectionView(Layout) 방향 Vertical 은 가로, Horizontal은 세로. 결과 이해를 돕기위해 스토리보드를 사용했고, 기본적인 요소는 이정도 인 듯 하다. Code로 직접 CollectionView를 짜고자 한다면 아래 링크를 참고하자. [–&gt; Code로 직접 구현하기.]","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"CollectionView","slug":"CollectionView","permalink":"https://qussk.github.io/tags/CollectionView/"}]},{"title":"[Swift]TableView 목록 수정,삭제 기능 추가하기(Editing)","slug":"Swift-TableView-목록-수정-삭제-기능-추가하기-Editing","date":"2020-06-15T21:45:09.000Z","updated":"2020-09-14T08:28:54.131Z","comments":false,"path":"2020/06/16/Swift-TableView-목록-수정-삭제-기능-추가하기-Editing/","link":"2020/06/15/Swift-TableView-목록-수정-삭제-기능-추가하기-Editing","permalink":"https://qussk.github.io/2020/06/16/Swift-TableView-%EB%AA%A9%EB%A1%9D-%EC%88%98%EC%A0%95-%EC%82%AD%EC%A0%9C-%EA%B8%B0%EB%8A%A5-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0-Editing/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"[Swift}WebKit 사용하기","slug":"Swift-WebKit-사용하기-1","date":"2020-06-07T14:18:36.000Z","updated":"2020-09-14T08:28:54.137Z","comments":false,"path":"2020/06/07/Swift-WebKit-사용하기-1/","link":"2020/06/07/Swift-WebKit-사용하기-1","permalink":"https://qussk.github.io/2020/06/07/Swift-WebKit-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-1/","excerpt":"","text":"사용예제 1. Webkit 임포트, url 지정 12345678910111213141516171819import UIKitimport WebKitclass ViewController: UIViewController, WKUIDelegate &#123; var webView: WKWebView! override func loadView() &#123; let webConfiguration &#x3D; WKWebViewConfiguration() webView &#x3D; WKWebView(frame: .zero, configuration: webConfiguration) webView.uiDelegate &#x3D; self view &#x3D; webView &#125; override func viewDidLoad() &#123; super.viewDidLoad() let myURL &#x3D; URL(string:&quot;https:&#x2F;&#x2F;www.apple.com&quot;) let myRequest &#x3D; URLRequest(url: myURL!) webView.load(myRequest) &#125;&#125; let myURL = URL(string:“불러올 페이지 url주소”) myRequest는 myURL를 URLRequest로 변경한다. 웹뷰 로드. 일단 나는 요즘 1일1깡을 하기 위해 깡을 불러와봤다. 혹시 안되시는 분들은 권한설정도 확인해보자 (아래의 것이 수행되어야 웹킷을 사용할 수 있다.) 2. 권한설정 2-1. Webkit framework가져오기 (패키지 가져오는 것이라 생각 .h로 구성되어있음) 2-2. 사용자 인터넷연결 허용하기(info.plist에 들어가 권한설정.) Information Property List 에 (+)추가하여 “App Transport Security Settings” 항목 만든후 아래 하위 목록으로 “Allow Arbitrary Loads” 생성 - Value는 대문자 &quot;YES&quot;로 지정 이 후 webkit을 불러오는 건 쉬운데, 그것으로 끝나는게 아니라, 이게 시작이다 ㅋㅋ. 무슨말이냐 하면, 결국 webview를 사용자가 편리하게 이요하기 위해선, back버튼이라던가, 새로고침, 뷰크기설정등, 다양한 인터페이스를 제공하려면, WKUIDelegate, WKNavigationDelegate, WKScriptMessageHandler등을 통해 결국 조작을 해줘야한다는 것이다. (이에 대한 내용은, [Swift}WebKit 사용하기-2’에 다뤄볼 생각이다. ) 여기서 내가 원하는 것은 깡 자동재생 재생시 풀화면 중단 유튜브처럼 내리는 제스처 이용시 영상이 작은뷰로 생성되면서 아래로 내려감. 플로팅 버튼 생성(버튼 누르면 my캘린더에 +1깡씩 ) 나의 현재코드 1234567891011121314151617181920212223242526272829303132333435363738import UIKitimport WebKitclass WebViewController: UIViewController &#123; var webView: WKWebView! override func loadView() &#123; let webConfiguration = WKWebViewConfiguration() webView = WKWebView(frame: .zero, configuration: webConfiguration) webView.uiDelegate = self view = webView &#125; override func viewDidLoad() &#123; super.viewDidLoad() view.backgroundColor = .black loadUrl() &#125; func loadUrl() &#123; let myURL = URL(string:\"https://m.youtube.com/watch?v=xqFvYsy4wE4\") let myRequest = URLRequest(url: myURL!) webView.configuration.allowsInlineMediaPlayback = true // webView.allowsInlineMediaPlayback = YES webView.load(myRequest) &#125; &#125; ` 어제 밤을 새서 오늘 낮인데도 졸리다…","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"Webkit","slug":"Webkit","permalink":"https://qussk.github.io/tags/Webkit/"},{"name":"WKWebView","slug":"WKWebView","permalink":"https://qussk.github.io/tags/WKWebView/"}]},{"title":"[Swift]3D touch 이용예제","slug":"Swift-3D-touch-이용예제","date":"2020-06-03T12:51:14.000Z","updated":"2020-09-14T08:28:54.115Z","comments":false,"path":"2020/06/03/Swift-3D-touch-이용예제/","link":"2020/06/03/Swift-3D-touch-이용예제","permalink":"https://qussk.github.io/2020/06/03/Swift-3D-touch-%EC%9D%B4%EC%9A%A9%EC%98%88%EC%A0%9C/","excerpt":"","text":"[동영상 보기]","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"3D touch","slug":"3D-touch","permalink":"https://qussk.github.io/tags/3D-touch/"},{"name":"UIAction","slug":"UIAction","permalink":"https://qussk.github.io/tags/UIAction/"},{"name":"UIContextMenuInteraction","slug":"UIContextMenuInteraction","permalink":"https://qussk.github.io/tags/UIContextMenuInteraction/"}]},{"title":"[Swift]Storyboard사용하지 않고 Project 사용하기","slug":"Swift-Stortboard이용하지-않고-Xcode사용하기","date":"2020-06-02T20:42:22.000Z","updated":"2020-09-14T08:28:54.131Z","comments":false,"path":"2020/06/03/Swift-Stortboard이용하지-않고-Xcode사용하기/","link":"2020/06/02/Swift-Stortboard이용하지-않고-Xcode사용하기","permalink":"https://qussk.github.io/2020/06/03/Swift-Stortboard%EC%9D%B4%EC%9A%A9%ED%95%98%EC%A7%80-%EC%95%8A%EA%B3%A0-Xcode%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/","excerpt":"","text":"이제 슬슬 스토리보드 없는 환경에 익숙해져야한다. 스토리보드를 이용하지 않는 이유는 간단하다. 보다 수월한 협업 ios12이하는 SceneDelegate를 지원하지 않았던 환경을 참고. 스토리보드를 이용하지 않는 방법은 2가지가 있다. AppDelegate만 이용하기.(ios12이하는 AppDelegate만 있다.) 이 말은 즉슨, 취직하고 해당 회사에 AppDelegate만 있을 경우가 있다. :) 아래를 참고하자. 0. Project 만들기 1. Main Interface 에서 Main 지우기 2. info.plist 에서 Application Scene Menifest 모두 삭제. 3. MainStoryboard 지우기 4. SceneDelegate 지우기 5. AppDelegate의 UISceneSession Lifecycle 지우기 5. AppDelegate에 window 작업하기 SceneDelegate 이용하기 guard let _ (와일드카드) 표시된 곳, scene으로 바꾸기. rootview 지정. (위 사진은 navigationController가 있는 모습이고, 없다면, winfow?.rootviewController = ViewController() 만 해주면된다. 여기서, ViewController() 는 처음 시작하고 싶은 화면(콘트롤러로)으로 지정.","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"Xcode","slug":"Xcode","permalink":"https://qussk.github.io/tags/Xcode/"},{"name":"No Storyboard","slug":"No-Storyboard","permalink":"https://qussk.github.io/tags/No-Storyboard/"}]},{"title":"[Swift]UIImagePickerController 이해하기","slug":"Swift-UIImagePiker-이해하기","date":"2020-06-02T14:14:50.000Z","updated":"2020-09-14T08:28:54.133Z","comments":false,"path":"2020/06/02/Swift-UIImagePiker-이해하기/","link":"2020/06/02/Swift-UIImagePiker-이해하기","permalink":"https://qussk.github.io/2020/06/02/Swift-UIImagePiker-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/","excerpt":"","text":"사전작업 UIImagePickerController let imagePiker = UIImagePickerController() 로도 쓸 수 있지만, 뷰디드로드로 하기엔 delegate =.self 선언 할 것이 한개 밖에 없을 때. lazy를 이용하여 간편하게 코드를 짤 수도 있다. 아래 코으 참고.(delegate와 UIImagePickerController선언 함께 사용하기) 1234567891011import UIKitfinal class ViewController: UIViewController &#123; @IBOutlet private weak var imageView: UIImageView! private lazy var imagePicker: UIImagePickerController = &#123; let imagePiker = UIImagePickerController() imagePiker.delegate = self return imagePiker&#125;() 실습 들어가기 1. 앨범 1-1. 앨범 타입 지정 imagePicker.sourceType 1234567//1.앨범@IBAction private func pickImage(_ sender: Any) &#123; imagePicker.sourceType = .photoLibrary //포토라이브러리는 앨범선택하는 화면 보여줌. //imagePicker.sourceType = .savedPhotosAlbum //최근에 찍은 사진 위주로 보여줌. present(imagePicker, animated: true) &#125; 1-2. 앨범 DidCancel 및 didFinishPickingMediaWithInfo. UIImagePickerControllerDelegate 이용, 네비게이션 바 이용하는 경우, UINavigationControllerDelegate 함께 필요. imagePickerControllerDidCancel 와 didFinishPickingMediaWithInfo중 쓰임새에 따라 선택하여 사용. dismiss는 필수인데, picker.presentingViewController?.dismiss(animated: true) 나, dismiss(animated: true)중에서 택하여 사용 1234567891011121314151617181920212223//MARK:- UIImagePickerControllerDelegateextension ViewController: UIImagePickerControllerDelegate, UINavigationControllerDelegate &#123;//닫기만 할 때는 생략가능. 창 캔슬시 기록이나 설정 필요한 경우 사용.func imagePickerControllerDidCancel(_ picker: UIImagePickerController) &#123;// picker.presentingViewController?.dismiss(animated: true)// dismiss(animated: true)//사진이나 영상을 찍었을 때 이미지를 가져오는 함수 func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) &#123; let mediaType = info[.originalImage] as! NSString //NSString는 objc에서 사용. 기능 많은 String \"문자열\"임 // dismiss // picker.presentingViewController?.dismiss(animated: true) dismiss(animated: true) //위에꺼 하든 아래것 하든 둘중 하나 택 &#125;&#125; 그럼 이런 식으로 앨범 버튼을 누를 때, 사진첩에 접근함. Cancel 누르면 창 닫힘. 2. 카메라 2-1. 카메라 권한 허락, 카메라 클릭시 동영상 촬영기능 포함하기. 2-0. import 하기 (MobileCoreServices) 123456789101112131415161718192021222324252627282930313233//2.카메라@IBAction private func takePicture(_ sender: Any) &#123;//2-1. 카메라 사용할건지 허락guard UIImagePickerController.isSourceTypeAvailable(.camera) else &#123;return&#125;imagePicker.sourceType = .camera//2-2. 동영상 찍을 수 있도록 카메라 클릭시 photo, vidio 생김. print(imagePicker.mediaTypes) let mediaTypes = UIImagePickerController.availableMediaTypes(for: .camera) print(mediaTypes) imagePicker.mediaTypes = mediaTypes ?? [] imagePicker.mediaTypes = [\"public.image\",\"public.moview\"] //kUTTypeVideo - 비디오 (영상) //kUTTypeMovie - 무비 (영상 + 소리) //String대신에 키값을 대신하여 사용. imagePicker.mediaTypes = [kUTTypeImage, kUTTypeMovie] as [String]//2-3.전면 카메라/후면카메라 if UIImagePickerController.isFlashAvailable(for: .rear) &#123; imagePicker.cameraFlashMode = .auto &#125; //필수 present(imagePicker, animated: true)&#125; 2-2. info.plist에서 앱권한 설정. Information Property List 에 + 를 눌러 추가후, Pirvacy - Photo Librart Additions Description 지정. Value에는 사용 목적 쓰기. 앱 실행해 보면 디버그에 오류뜸. 동영상 촬영시 마이크에 접근하므로 마이크도 권한 설정함. Information Property List 에 Pirvacy - Microphone Usage Description 그럼 카메라 구현도 문제없이 실행된다 ! 5. 화살표 (맨 우측 버튼) 찍은 사진 라이브러리에 접근하여 편집. 5-1. 토글작업… 1234567//5. 화살표 @IBAction private func toggleAllowsEditing(_ sender: Any) &#123; print(\"\\n---------- [ toggleAllowsEditing ] ----------\\n\") //5-1. imagePicker.allowsEditing.toggle() &#125;&#125; 이미지나 영상을 찍었을때 가져오는 함수로 이동하여 아래코드 구현. (didFinishPickingMediaWithInfo) 123456789101112131415161718func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) &#123; let mediaType = info[.mediaType] as! NSString //NSString: objc에서 사용. 기능 많은String if UTTypeEqual(mediaType, kUTTypeImage) &#123; //사진 let originalImage = info[.originalImage] as! UIImage //5-2. 편집을 할 때만 있는거기 때문에 ?사용 let editedImage = info[.editedImage] as? UIImage //5-3. 최종이미지 let selectedImage = editedImage ?? originalImage //5-4.originalImage을 selectedImage로 변경. imageView.image = selectedImage/*originalImage*/ print(info) 이런식으로 사진 편집 가능하게 됨… 하지만 저장하면 멈춤… 5-2.info.plist에서 앱권한 설정. Information Property List 에 Privacy - Photo Library AddUsage Descriptrion을 추가하고 Value에 목적을 쓴다. (참고로 Key에 Control + 마우스 좌측 누르면 &quot;Raw Keys &amp; Values&quot;로 원래 이름? 값을 볼 수 있다. 체크해서, NSPhotoLibraryAddUsageDescriptrion ) 그럼 앱처음 켤때 이런 메세지 확인가능해짐. 3. 딜레이 촬영 앱 실행되자마자 촬영되게 끔~ 시간차 이용하여 촬영되도록 설정 1234567891011121314151617181920//3.딜레이촬영@IBAction private func takePictureWithDelay(_ sender: Any) &#123; guard UIImagePickerController.isSourceTypeAvailable(.camera) else &#123;return&#125; imagePicker.sourceType = .camera imagePicker.mediaTypes = [kUTTypeImage as String] present(imagePicker, animated: true) &#123; // present(imagePicker, animated: true, completion: )//completion : 프레젠트가 끝날 때 코드 //화면 띄우자마자 촬영 // self.imagePicker.takePicture() //2초뒤 촬영 DispatchQueue.main.asyncAfter(deadline: .now() + 2) &#123; self.imagePicker.takePicture() &#125; &#125;&#125; 빌드하고 촬영해보면 이런 식으로 나온다. 4. 동영상 촬영 4-1. 촬영 기능 설정. 123456789101112131415161718192021222324//4.동영상 촬영@IBAction private func recordingVideo(_ sender: Any) &#123; guard UIImagePickerController.isSourceTypeAvailable(.camera) else &#123;return&#125; imagePicker.sourceType = .camera //앨범에 사진 안나오고 동영상만나옴.//[kUTTypeImage,kUTTypeMovie as String] 이렇게 해야 이미지도 뜸 //그런데 왜인지 아래로 해두 된다.. imagePicker.mediaTypes = [kUTTypeMovie as String] // imagePicker.mediaTypes = [\"public.movie\"] imagePicker.cameraCaptureMode = .video // 처음시작을 video로 하고 싶은 경우 //imagePicker.cameraCaptureMode = .photo //처름시작을 photo로 하고 싶은 경우 //front전면 카메라 ,rear후면 카메라 imagePicker.cameraDevice = .rear present(imagePicker, animated: true) //imagePicker.startvideoCapture() // imagePicker.stopVideoCapture() imagePicker.videoMaximumDuration = 10 //초단위, 기본 10분. - 동영상 타이머 설정가능. imagePicker.videoQuality = .typeHigh //고화질 - 화질변경 가능.&#125; 4-2. 영상 불러오는 함수 추가. (조건문 활용) 123456789101112131415161718192021222324252627func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) &#123; let mediaType = info[.mediaType] as! NSString if UTTypeEqual(mediaType, kUTTypeImage) &#123; //사진 let originalImage = info[.originalImage] as! UIImage let editedImage = info[.editedImage] as? UIImage let selectedImage = editedImage ?? originalImage imageView.image = selectedImage print(info) //카메라로 찍은 경우만 저장 if picker.sourceType == .camera &#123; UIImageWriteToSavedPhotosAlbum(selectedImage, nil, nil, nil) &#125; &#125;else if UTTypeEqual(mediaType, kUTTypeMovie) &#123; //영상 if let mediaPath = (info[.mediaURL] as? NSURL)?.path, UIVideoAtPathIsCompatibleWithSavedPhotosAlbum(mediaPath) &#123; UISaveVideoAtPathToSavedPhotosAlbum(mediaPath, nil, nil, nil) &#125; &#125; //picker.presentingViewController?.dismiss(animated: true) dismiss(animated: true) //위에꺼 하든 아래것 하든 상관 없음 &#125; &#125; 동영상 버튼 누르게 되면 된다. [전체코드] import MobileCoreServices import UIKit final class ViewController: UIViewController { @IBOutlet private weak var imageView: UIImageView! // let picker = UIImagePickerController() private lazy var imagePicker: UIImagePickerController = { let imagePiker = UIImagePickerController() imagePiker.delegate = self return imagePiker }() // MARK: Action //1.앨범 @IBAction private func pickImage(_ sender: Any) { print(&quot;\\n---------- [ pickImage ] ----------\\n&quot;) imagePicker.sourceType = .photoLibrary //포토라이브러리는 앨범선택하는 화면 보여줌. //. imagePicker.sourceType = .savedPhotosAlbum //최근에 찍은 사진 위주로 보여줌. // imagePicker.mediaTypes = [kUTTypeMovie] present(imagePicker, animated: true) } //2.카메라 @IBAction private func takePicture(_ sender: Any) { print(&quot;\\n---------- [ takePicture ] ----------\\n&quot;) //카메라 사용할건지 허락 guard UIImagePickerController.isSourceTypeAvailable(.camera) else {return} imagePicker.sourceType = .camera //동영상 찍을 수 있도록 생김. print(imagePicker.mediaTypes) let mediaTypes = UIImagePickerController.availableMediaTypes(for: .camera) print(mediaTypes) imagePicker.mediaTypes = mediaTypes ?? [] imagePicker.mediaTypes = [&quot;public.image&quot;,&quot;public.moview&quot;] //kUTTypeVideo - 비디오 (영상) //kUTTypeMovie - 무비 (영상 + 소리) //String대신에 키값을 대신하여 사용. imagePicker.mediaTypes = [kUTTypeImage, kUTTypeMovie] as [String] //2-1.전면 카메라/후면카메라 if UIImagePickerController.isFlashAvailable(for: .rear) { imagePicker.cameraFlashMode = .auto } present(imagePicker, animated: true) } //3.딜레이촬영 @IBAction private func takePictureWithDelay(_ sender: Any) { guard UIImagePickerController.isSourceTypeAvailable(.camera) else {return} imagePicker.sourceType = .camera imagePicker.mediaTypes = [kUTTypeImage as String] present(imagePicker, animated: true) { // present(imagePicker, animated: true, completion: )//completion : 프레젠트가 끝날 때 코드 //화면 띄우자마자 촬영 // self.imagePicker.takePicture() //2초뒤 촬영 DispatchQueue.main.asyncAfter(deadline: .now() + 2) { self.imagePicker.takePicture() } print(&quot;\\n---------- [ takePictureWithDelay ] ----------\\n&quot;) } } //4.동영상 촬영 @IBAction private func recordingVideo(_ sender: Any) { print(&quot;\\n---------- [ recordingVideo ] ----------\\n&quot;) guard UIImagePickerController.isSourceTypeAvailable(.camera) else {return} imagePicker.sourceType = .camera //앨범에 사진 안나오고 동영상만나옴.//[kUTTypeImage,kUTTypeMovie as String] 이렇게 해야 이미지도 뜸 imagePicker.mediaTypes = [kUTTypeMovie as String] // imagePicker.mediaTypes = [&quot;public.movie&quot;] imagePicker.cameraCaptureMode = .video // 처음시작을 video로 하고 싶은 경우 // imagePicker.cameraCaptureMode = .photo //처름시작을 photo로 하고 싶은 경우 //front전면 카메라 ,rear후면 카메라 imagePicker.cameraDevice = .rear present(imagePicker, animated: true) //imagePicker.startvideoCapture() // imagePicker.stopVideoCapture() imagePicker.videoMaximumDuration = 10 //초단위, 기본 10분 imagePicker.videoQuality = .typeHigh //고화질 } //5.화살표 @IBAction private func toggleAllowsEditing(_ sender: Any) { print(&quot;\\n---------- [ toggleAllowsEditing ] ----------\\n&quot;) //2-2. imagePicker.allowsEditing.toggle() } } //MARK:- UIImagePickerControllerDelegate extension ViewController: UIImagePickerControllerDelegate, UINavigationControllerDelegate { //네비게이션안에 생성되어있으므로, 네비컨트롤러딜리게이트도 필요. //imagePickerControllerDidCancel : 의 경우 dismiss직접구현 필요함. //imagePickerControllerDidCancel를 하지 않으면 아주 잘닫힘.. 구현 필요없는 경우엔 생략 // func imagePickerControllerDidCancel(_ picker: UIImagePickerController) { // picker.presentingViewController?.dismiss(animated: true) // //dismiss(animated: true) //닫기만할때는 굳이 구현 필요없으나, 캔슬시 기록이나 설정 필요한 경우 사용. //이미지나 영상을 찍었을때 가져오는 함수 //didFinishPickingMediaWithInfo: 어떤 것을 픽했는지 알려주는.//피킹한것을 끝냈다. func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) { let mediaType = info[.mediaType] as! NSString //NSString: objc에서 사용. 기능 많은String if UTTypeEqual(mediaType, kUTTypeImage) { //사진 let originalImage = info[.originalImage] as! UIImage //2-3. 편집을 할 때만 있는거기 때문에 ?사용 let editedImage = info[.editedImage] as? UIImage //2-4. 최종이미지 let selectedImage = editedImage ?? originalImage //2-5.originalImage을 selectedImage로 변경. imageView.image = selectedImage/*originalImage*/ print(info) //카메라로 찍은 경우만 저장 if picker.sourceType == .camera { UIImageWriteToSavedPhotosAlbum(selectedImage, nil, nil, nil) } }else if UTTypeEqual(mediaType, kUTTypeMovie) { //영상 if let mediaPath = (info[.mediaURL] as? NSURL)?.path, UIVideoAtPathIsCompatibleWithSavedPhotosAlbum(mediaPath) { UISaveVideoAtPathToSavedPhotosAlbum(mediaPath, nil, nil, nil) } } //picker.presentingViewController?.dismiss(animated: true) dismiss(animated: true) //위에꺼 하든 아래것 하든 상관 없음 } }","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"ImagePicker","slug":"ImagePicker","permalink":"https://qussk.github.io/tags/ImagePicker/"},{"name":"UIImagePickerController","slug":"UIImagePickerController","permalink":"https://qussk.github.io/tags/UIImagePickerController/"}]},{"title":"[Swift]CustomTableViewCell만들기","slug":"Swift-Custom-TableView만들기","date":"2020-05-28T20:44:57.000Z","updated":"2020-09-14T08:28:54.120Z","comments":false,"path":"2020/05/29/Swift-Custom-TableView만들기/","link":"2020/05/28/Swift-Custom-TableView만들기","permalink":"https://qussk.github.io/2020/05/29/Swift-Custom-TableView%EB%A7%8C%EB%93%A4%EA%B8%B0/","excerpt":"","text":"cellForRowAt의 기본방식을 이용하지 않고, cellForRowAt의 let cell: UITableViewCell 로 커스텀하여 접근. TableViewCustom 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import UIKitfinal class TableViewCustomCell: UIViewController &#123; override var description: String &#123; \"TableView - CustomCell\" &#125; let tableView = UITableView() override func viewDidLoad() &#123; super.viewDidLoad() tableView.frame = view.frame tableView.dataSource = self tableView.delegate = self tableView.rowHeight = 80 view.addSubview(tableView) tableView.register(UITableViewCell.self, forCellReuseIdentifier: \"Default\") tableView.register(CustomCell.self, forCellReuseIdentifier: \"Custom\") &#125;&#125;// MARK: - UITableViewDataSourceextension TableViewCustomCell: UITableViewDataSource &#123; func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return 20 &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell: UITableViewCell if indexPath.row.isMultiple(of: 2) &#123; //만약 나누기2로 떨어지면, cell = tableView.dequeueReusableCell(withIdentifier: \"Custom\", for: indexPath) //myLable접근이 안됨.. 되게 하려면?.. (cell as! CustomCell).myLabel.text = \"ABCDE\" &#125; else &#123; cell = tableView.dequeueReusableCell(withIdentifier: \"Default\", for: indexPath) &#125; cell.textLabel?.text = \"\\(indexPath.row * 1000)\" cell.imageView?.image = UIImage(named: \"bear\") //레이아웃이 필요한 곳이 아니기 떄문에, 딜리게이트에서 따로 잡아야함. print(tableView.rowHeight) --&gt; 44.0 //프린트 찍어보면 높이가 기본인 44로 나옴. 위에 80으로 지정했음에도...-&gt;시뮬에서는 80으로 보이지만.. //그래서 1.딜리게이트에서 직접 작업해주거나, 2.CustomCell에서 직접 레이아웃잡아야함. (cell as? CustomCell)?.myLabel.frame = CGRect( x: cell.frame.width - 120, y: 15, width: 100, height: cell.frame.height - 30 ) return cell &#125;&#125;//1. 딜리게이트 작업 // MARK: - UITableViewDelegateextension TableViewCustomCell: UITableViewDelegate &#123; // cellForRowAt -&gt; willDisplayCell -&gt; layoutSubviews func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) &#123; guard let customCell = cell as? CustomCell else &#123; return &#125; customCell.myLabel.frame = CGRect( x: cell.frame.width - 120, y: 15, width: 100, height: cell.frame.height - 30 ) &#125;&#125; Custom Cell 12345678910111213141516171819202122232425import UIKitclass CustomCell: UITableViewCell &#123; let myLabel = UILabel() override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) &#123; super.init(style: style, reuseIdentifier: reuseIdentifier) // 커스텀 뷰를 올릴 때는 contentView 위에 추가 myLabel.textColor = .black myLabel.backgroundColor = .yellow contentView.addSubview(myLabel) &#125; // 스토리보드 생성할 때 required init?(coder aDecoder: NSCoder) &#123; fatalError(\"init(coder:) has not been implemented\") &#125;//2. (여기에 넣음)&#125; 상속받은 애가 _required_할 때 반드시 해야하는 init함수. 스토리보드로 만들게 될 경우, init 메서드가 위의 _override init_이 아닌, required init?으로 오게 됨. _required_는 이미 부모 것을 받아서 쓰는 것이기 때문에 override할 필요없음(이미 되어 있음) 2.CustomCell의 레이아웃으로 조정할 경우. 1234567891011// 레이아웃 조정 시override func layoutSubviews() &#123; super.layoutSubviews() //프레임 이용 myLabel.frame = CGRect( x: frame.width - 120, y: 15, width: 100, height: frame.height - 30 )&#125; 결과 값 바뀜.","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"TableView","slug":"TableView","permalink":"https://qussk.github.io/tags/TableView/"}]},{"title":"[Swift]UITableView 이해하기.md","slug":"Swift-UITableView-이해하기","date":"2020-05-27T13:28:04.000Z","updated":"2020-09-14T08:28:54.134Z","comments":false,"path":"2020/05/27/Swift-UITableView-이해하기/","link":"2020/05/27/Swift-UITableView-이해하기","permalink":"https://qussk.github.io/2020/05/27/Swift-UITableView-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/","excerpt":"","text":"UITableView 종류 Tableview는 크게 2가지로 나뉜다. 기본 나열방식인 Plain 과 그룹핑으로 표현되는 Group. Group Table View의 경우 Padding과 Header ~ TableCell ~ Footer과 Padding순으로 잘 기억해야한다. UITableView를 사용하기 이전에 준비해야할 것. UITableViewDataSource UITableView를 사용하기 위해 UITableViewDataSource에 대한 권한 설정은 필수다. (class에 이용하여 할당해줘야함. ) viewController","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"TableView","slug":"TableView","permalink":"https://qussk.github.io/tags/TableView/"},{"name":"UITableView","slug":"UITableView","permalink":"https://qussk.github.io/tags/UITableView/"}]},{"title":"[Swift]Fram과 AutoLayout을 이용한 다양한 방법들","slug":"Swift-Fram과-AutoLayout을-이용한-다양한-방법들","date":"2020-05-21T16:08:20.000Z","updated":"2020-09-14T08:28:54.122Z","comments":false,"path":"2020/05/22/Swift-Fram과-AutoLayout을-이용한-다양한-방법들/","link":"2020/05/21/Swift-Fram과-AutoLayout을-이용한-다양한-방법들","permalink":"https://qussk.github.io/2020/05/22/Swift-Fram%EA%B3%BC-AutoLayout%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%8B%A4%EC%96%91%ED%95%9C-%EB%B0%A9%EB%B2%95%EB%93%A4/","excerpt":"","text":"frame을 이용한 방법. 1234567891011121314151617181920212223242526272829303132333435363738394041import UIKitclass greenViewController: UIViewController &#123; let greenView = UIView() let touchButton = UIButton() override func viewDidLoad() &#123; super.viewDidLoad() //greenView greenView.frame = CGRect(x: 50, y: 100, width: 80, height: 80) greenView.backgroundColor = .green view.addSubview(greenView) //touchButton touchButton.frame = CGRect(x: 140 , y: 20, width: 100, height: 50) touchButton.backgroundColor = .black touchButton.setTitle(\"touch\", for: .normal) touchButton.addTarget(self, action: #selector(touch(_:)), for: .touchUpInside) view.addSubview(touchButton) &#125; //버튼 후 frame 변경 @objc func touch(_ sender: UIButton) &#123; UIView.animate(withDuration: 2) &#123; if self.greenView.layer.cornerRadius == 0 &#123; self.greenView.frame = CGRect(x: 50, y: 300, width: 200, height: 200) self.greenView.layer.cornerRadius = 100 &#125; else &#123; self.greenView.frame = CGRect(x: 50, y: 100, width: 80, height: 80) self.greenView.layer.cornerRadius = 0 &#125; &#125; &#125;&#125; frame을 이용했다면, 오토 레이아웃을 잡을 필요는 없습니다! Auto Layouts 3가지 방법(Constraint. Priority,active toggle ) [Constraint]","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"AutoLayout","slug":"AutoLayout","permalink":"https://qussk.github.io/tags/AutoLayout/"},{"name":"Frame","slug":"Frame","permalink":"https://qussk.github.io/tags/Frame/"},{"name":"Animate","slug":"Animate","permalink":"https://qussk.github.io/tags/Animate/"},{"name":"UIView","slug":"UIView","permalink":"https://qussk.github.io/tags/UIView/"}]},{"title":"[Swift]TextField 글자수 제한하기","slug":"Swift-TextField-글자수-제한하기","date":"2020-05-21T15:33:59.000Z","updated":"2020-09-14T08:28:54.132Z","comments":false,"path":"2020/05/22/Swift-TextField-글자수-제한하기/","link":"2020/05/21/Swift-TextField-글자수-제한하기","permalink":"https://qussk.github.io/2020/05/22/Swift-TextField-%EA%B8%80%EC%9E%90%EC%88%98-%EC%A0%9C%ED%95%9C%ED%95%98%EA%B8%B0/","excerpt":"","text":"TextFieldDelegate 사용시 텍스트필드에 글자수 제한두기 아래의 코드만 붙여넣기하면 된다. 🤷🏻‍♀️ 123456//텍스트필드 글자수 제한func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -&gt; Bool &#123; guard let text = textField.text else &#123; return true &#125; let newLength = text.count + string.count - range.length return newLength &lt;= 16&#125; newLength &lt;= 16 의 16은 16자까지 제한 둔다는 뜻.","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"TextField","slug":"TextField","permalink":"https://qussk.github.io/tags/TextField/"},{"name":"TextFieldDelegate","slug":"TextFieldDelegate","permalink":"https://qussk.github.io/tags/TextFieldDelegate/"},{"name":"로그인화면","slug":"로그인화면","permalink":"https://qussk.github.io/tags/%EB%A1%9C%EA%B7%B8%EC%9D%B8%ED%99%94%EB%A9%B4/"}]},{"title":"[Swift]TextField에 밑줄 긋기","slug":"Swift-textField에-밑줄-긋기","date":"2020-05-21T14:58:14.000Z","updated":"2020-09-14T08:28:54.139Z","comments":false,"path":"2020/05/21/Swift-textField에-밑줄-긋기/","link":"2020/05/21/Swift-textField에-밑줄-긋기","permalink":"https://qussk.github.io/2020/05/21/Swift-textField%EC%97%90-%EB%B0%91%EC%A4%84-%EA%B8%8B%EA%B8%B0/","excerpt":"","text":"오늘은 텍스트 필드에 밑줄을 긋는 법을 알아보고자 합니다! 스토리 보드에서 지원하는 텍스트필드 디자인은 총 4가지가 있는데 이곳에는 TextField의 underLine은 제외 되어 있으니 이는 코드로 직접 구현해내는 방법 밖엔 없습니다. 😉 아래의 코드를 참고하여 붙여넣어줍니다. 12345678910111213141516171819202122232425override func viewDidLayoutSubviews() &#123;passwordUnderline()&#125;//텍스트필드 밑줄func passwordUnderline() &#123; passwordTextfield.borderStyle = .none let border = CALayer()border.frame = CGRect(x: 0, y: passwordTextfield.frame.size.height-1, width: passwordTextfield.frame.width, height: 1) border.backgroundColor = UIColor.gray.cgColor passwordTextfield.layer.addSublayer((border)) emailTextfield.borderStyle = .none let border1 = CALayer() border1.frame = CGRect(x: 0, y: emailTextfield.frame.size.height-1, width: emailTextfield.frame.width, height: 1) border1.backgroundColor = UIColor.gray.cgColor emailTextfield.layer.addSublayer((border1)) &#125;``` 해당 코드를 viewWillAppear에서 사용하여도 관계없지만, 만약 코드로 오토레이아웃을 잡았다면 ```viewDidLayoutSubviews 이곳에서 오버라이딩하여 사용해야합니다. 이에 대한 내용은 아래 링크를 참고 ! [https://g-y-e-o-m.tistory.com/64] 혹시 안되는 분들은 TextFieldDelegate를 했는지 확인! class에 UITextFieldDelegate부르기. 1class ViewController: UIViewController,UITextFieldDelegate &#123; viewDidLoad에 해당 textField를 self로 지정 12emailTextfield.delegate = selfpasswordTextfield.delegate = self 완성된 모습 확인 👏🏻👏🏻👏🏻","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"TextField","slug":"TextField","permalink":"https://qussk.github.io/tags/TextField/"},{"name":"TextFieldDelegate","slug":"TextFieldDelegate","permalink":"https://qussk.github.io/tags/TextFieldDelegate/"},{"name":"로그인화면","slug":"로그인화면","permalink":"https://qussk.github.io/tags/%EB%A1%9C%EA%B7%B8%EC%9D%B8%ED%99%94%EB%A9%B4/"}]},{"title":"Array","slug":"POST/Swift-Array","date":"2020-05-20T22:13:52.000Z","updated":"2020-09-23T13:20:52.044Z","comments":false,"path":"2020/05/21/POST/Swift-Array/","link":"2020/05/20/POST/Swift-Array","permalink":"https://qussk.github.io/2020/05/21/POST/Swift-Array/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243Array Array = [“A”,”b”,”C”,”D”,”E\"]//0번째 값지우기 (print: “A”)Let arrless = Array.remove(at:0) arrless //print: \"b”,”C”,”D”,”E// 모두지우기arrless.removeall() //인덱스값 모를 경우if let indexC = arrless.firstindex(at: “C”) &#123;Array.remove(at : indexC) &#125; Array.shuffle // 모두섞기Array.sort() //정렬하기Array.shuffled //반환타입() 또다른 배열을 낳음(자신이 변경되지는 않고 바꾼값을 반환하는 것)- 스트링,보이드 고를 수 있음arrless[2…] //인덱스2부터 끝까지arrless[2…] = [“Q”,”W”,”Z”] //인덱스 2부터 해당배열 삽입for tuple(기본제공) in Array.enumrated()&#123;Print(“ \\(tuple.0) = \\(tuple.1)”)(1…10).Reversed() //내림차순//값 반환할 떄. “ “ 한칸씩 띄어서 한줄로 출력For num in (1…10).Reversed() &#123;print(num, herminator : “ “) &#125;","categories":[{"name":"post","slug":"post","permalink":"https://qussk.github.io/categories/post/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"Array","slug":"Array","permalink":"https://qussk.github.io/tags/Array/"}]},{"title":"[Swift]TextField 키보드에 가려짐 문제해결","slug":"Swift-TextField-키보드에-가려짐-문제해결","date":"2020-05-19T10:56:51.000Z","updated":"2020-09-14T08:28:54.132Z","comments":false,"path":"2020/05/19/Swift-TextField-키보드에-가려짐-문제해결/","link":"2020/05/19/Swift-TextField-키보드에-가려짐-문제해결","permalink":"https://qussk.github.io/2020/05/19/Swift-TextField-%ED%82%A4%EB%B3%B4%EB%93%9C%EC%97%90-%EA%B0%80%EB%A0%A4%EC%A7%90-%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/","excerpt":"","text":"문제직면 텍스트필드를 이용하다보면 위와 같은 문제에 자주 직면하게 될 것이다. 텍스트 필드를 키보드 높이보다 위에 두면 문제는 간단히 해결되겠지만, 나도 남들처럼 예쁘게 UI자고 싶은데… (왜 나만안돼 나만… ㅠㅠ) 이라면 아래를 참고하자. 우린 아름다운 UI를 포기할 수 없으니까!! 1-1. 뷰 만들기. 텍스트 필드를 하나하나 올리는 방법도 있겠지만, 필자는 view로 좀더 손쉽게 올려보고자 한다. 올려야할 영역을 모두 view에 넣는다. 좌측 목록을 활용하면, view가 상위목록으로, 이 외에 것들은 모두 view의 하위목록으로 쉽게 옮길 수 있다. 그리고 view 아울렛 연결로 마무리. 1-2. 키보드에 따라 뷰 올렸다 내리기. (NotificationCenter addObserver) 일단 옵저버를 등록해줘야하는데, 화면이 켜졌을 때 이를 적용해야하기 때문에, 뷰디드로드에 놓거나, viewWillAppear에 넣어야한다. 필자는 viewWillAppear에 넣는 방법을 택했다. 그리고 viewWillAppear가 지저분해지는 것을 막고자 함수를 이용하여 더 깔끔하게 처리했다. (그리고 viewWillAppear는 반드시 override를 해줄것.) 123456789override func viewWillAppear(_ animated: Bool) &#123; addKeyboardNotification()&#125;//옵저버 등록 private func addKeyboardNotification() &#123; NotificationCenter.default.addObserver(self,selector: #selector(keyboardWillShow(_:)),name: UIResponder.keyboardWillShowNotification,object: nil) NotificationCenter.default.addObserver(self,selector: #selector(keyboardWillHide(_:)),name: UIResponder.keyboardWillHideNotification,object: nil) &#125; 2)keyboardWillShowNotification,keyboardWillHideNotification는 고정갑싱다. 3) #selector해준 값은 keyboardWillShow, keyboardWillHide이고 키보드를 올리고 내리는 함수이다. 123456//1-2. 올리기, 내리기.@objc private func keyboardWillShow(_ notification: Notification) &#123; loginView.frame.origin.y = 250 &#125;@objc private func keyboardWillHide(_ notification: Notification) &#123; loginView.frame.origin.y = 450 &#125; 위의 수치는 본인의 UI에 맞춰 조절할 수 있다 (꼭 정수가 아닌, -값이 될 수도 있다.) 그래서 이 수치에 맞춰서 하게되면 ? 설정해준 값에 맞춰 view가 올라가는 모습을 확인할 수 있다. 구분을 쉽게하기 위해 view의 백그라운드를 노란색으로 줬다. 이해를 돕기위한 영상 참고 [https://www.youtube.com/watch?v=–belgLUl0U&amp;lc=UgxTbtgIjq8c8tcAPLZ4AaABAg] 🎃","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"TextField","slug":"TextField","permalink":"https://qussk.github.io/tags/TextField/"},{"name":"로그인화면","slug":"로그인화면","permalink":"https://qussk.github.io/tags/%EB%A1%9C%EA%B7%B8%EC%9D%B8%ED%99%94%EB%A9%B4/"},{"name":"keyboard","slug":"keyboard","permalink":"https://qussk.github.io/tags/keyboard/"}]},{"title":"[Swift]스토리보드에서 AutoLayout이해하기","slug":"Swift-스토리보드에서-AytoLayoutㅇ이해하기","date":"2020-05-15T20:22:12.000Z","updated":"2020-09-14T08:28:54.142Z","comments":false,"path":"2020/05/16/Swift-스토리보드에서-AytoLayoutㅇ이해하기/","link":"2020/05/15/Swift-스토리보드에서-AytoLayoutㅇ이해하기","permalink":"https://qussk.github.io/2020/05/16/Swift-%EC%8A%A4%ED%86%A0%EB%A6%AC%EB%B3%B4%EB%93%9C%EC%97%90%EC%84%9C-AytoLayout%E3%85%87%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/","excerpt":"","text":"Laying out a user interface 애플에서 지원하는 레이아웃에 대한 접근 방식은 총 3가지가 있다. 1234[유저 인터페이스 구성을 위한 3가지 주요 접근 방식]Frame 기반의 프로그래밍 방식Autoresizing masksAuto Layout 첫번째 Frame 기반의 프로그래밍 방식은 코드를 이용한 방식이다. (Frame 기반의 프로그래밍 방식은 다음 포스트에서 할 계획이다.) 두번째 Autoresizing masks은 기본적으로 제공되는 레이아웃이라고 생각하면 되는데(만약 내가 작성한 코드나 직접 Auto Layout을 사용하게될 경우에는 translatesAutoresizingMaskIntoConstraints 값을 false로 지정해야만 한다.) Autoresizing masks에 대한 자세한 이해가 필요하다면, 아래의 링크에서 확인하길 바란다. https://www.thecodedself.com/autoresizing-masks/ 그리고 세번째인 Auto Layout 은 스토리보드 상에서 레이아웃을 잡는 방식이다. 오늘은 스토리보드 상에서 레이아웃을 잡을 수 있는 기능인 오토레이아웃에 대해서 알아볼 것인데, 들어가기 전에 가장 기본이 되는 Autoresizing의 구조를 한 번 훑고 지나가자. Autoresizing 기본구조 스토리보드에서 UIView를 만들면 우측 사이즈 인스펙터 탭에 Autoresizing가 보이는 것을 시각적으로 확인할 수 있다. 대충 이런 느낌인데, 빨간색 선이 곧 View의 저 좌측 꼭지점 부분을 가리킨다고 보면 된다. (서로 매칭하면서 생각하면 쉽다.) 이런식으로… (그림과 함께 보면 더 쉽다…) 주의할 점은 꼭 필요한 부분만 빨간색 선이 나오도록 클릭해주는 것이다…(남발하면 작동안됨… 컴퓨터가 어디를 기준으로 줘야하는지 모르는 상태가 되어버리니까… 기준은 명확하게 !) 그리고 만약 이런 식으로 오른쪽에 기준을 준 뒤, 검정색 부분의 꼭지점을 잡고 왼쪽으로 드래그하면, 빨간색 부분인 오른쪽이 고정된 채로 노란 뷰가 줄어 듦을 알 수 있다. 이와 같이 여러 방법으로 움직여보면 Autoresizing 어떤 방식으로 작동하는지 금방 알 수 있다. 그리고 UIView의 인스팩터 탭에서는 Autoresizing뿐만아니라, 현재 뷰의 x축,y축,width(넓이),height(높이)에 대한 정보도 볼 수 있으니 참고하자! 이제 Autoresizing에 대해 어느 정도 훑었으니, 본격적으로 Auto Layout 으로 들어가자. Auto Layout 이란? Auto Layout 은 뷰에 주어진 제약조건에 따라 뷰의 크기와 위치를 동적으로 계산해 배치하는 것으로, 외부 또는 내부의 변화에 동적으로 반응하여 유저 인터페이스를 구성한다. 역시 말로 하면 잘모르겠으니 직접 보도록하자. Auto Layout 활용 Auto Layout tools 오토레이아웃에 접근하기 위한 tools이다. 왼쪽부터, 12345Update Frames : 제약조건과 맞지 않는 뷰 위치 갱신.Align : 정렬에 관한 제약사항 설정 Pin : 간격, 크기, 비율 등에 대한 제약 조건 설정 Resolve Autolayout Lssues : 오토레이아웃 관련 문제 해결 Emned In : 컨테이너 뷰 &#x2F; 뷰컨트롤러 추가 일단 가장 많이 접하게 되는 것은 Pin부분이다. 일단 예제를 통해 익혀보자. [Auto Layout 잡기] 값으로 직접 Layout잡기 1-1. UIView를 하나 만들고, Pin을 클릭후 레이아웃의 왼쪽과 위쪽 값을 지정한다. 예제로 20씩 주자. (참고로 Auto Layout을 잡을 때는, Constrain to margins에 체크를 해제하도록한다. ) 그리고 ** Add 2 Constraints를 클릭하여 내용을 적용한다. ??적용하게 되면 빨간줄이 뜰것이다… ?? 빨간줄은 일단 ‘레이아웃에 문제있음’ 정도로 이해하면 될 것 같다. 값이 비어있거나, 값이 맞지 않는 경우(해당 값이 보여진다.)에 빨간줄로 표현된다. 오토 레이아웃을 잡는 다는 것은, 이 것을 파란색 줄로 바꾸는 작업 이라고 생각하면 쉽다. (노란색 줄도 놉…) 그래서 현재의 상태는 레이아웃이 비어있는 값이 존재하므로, 비어있는 값을 마저 채워 줘야한다! 아래를 보자. 1-2. 오른쪽과 아래값 지정하기. 1-1과 마찬가지로 오른쪽과 아래 값을 20씩주고 add를 적용하면, view의 레이아웃이 정상적으로 잡힌 것을 볼 수 있다. (모두 파란줄!!!) 이 처럼 해당 view에 대한 값을 '완전하고도 명확하게, 지정해주어야 뷰가 어떤 상황에서든 움직이지않고, 안전한 인터페이스를 제공할 수 있게 된다. 1-3. width와 height로 레이아웃 잡기. 1-2처럼 모든 테두리에 값을 지정하는 방법도 있지만, 해당 view의 넓이와 높이의 값을 알고 있다면, width와 height로도 지정해 줄 수 있다. 이런 식으로… width은 300, height는 500을 줬다. 적용된 모습. Add Missing Constraints으로 Layout 잡기 다른 방법도 한가지 있는데, 위처럼 레이아웃을 일일히 지정할 필요 없이 먼저 UI를 짠 후, 그 값에 맞춰 모두 레이아웃이 잡히는 기능을 한다. 예를 들면, 2-1. 뷰를 선택후 아래 세모 모양(Resolve Autolayout Lssues)을 선택 후 ‘Add Missing Constraints’ 클릭 그러면? 모두 정상적인 파란줄의 레이아웃으로 잘 잡히게 된다. 2-2. 재지정?(바꾸고 싶엉!) 만약 뷰를 움직이고, 움직인 뒤의 UI로 레이아웃을 재지정 하고 싶은 경우. 다시 뷰를 선택후 아래 세모 모양(Resolve Autolayout Lssues)을 선택하면 ‘Update Constranit Constants’ 를 확인 할 수 있다. 현재 뷰가 이동한 자리로 레이아웃을 다시 업데이트 해준다는 뜻이다. 클릭하면? 지울 필요없이 자동적으로 레이아웃이 재설정 되는 모습. 하지만, 사실? 눈대중으로 하는 것이 그렇게 명확하진 않아서? 보통 일일히 지정하는 법을 선호한다. (어디까지나 명확하고 정확한 UI를 위해) Align Tool 으로 잡기 Align Tool 중, 제일 자주 사용하는 것이 아래 2개 “Horizontally in Container”, &quot;Verically in Container&quot;인데, 이는 center값을 기준으로 둔 선의 중앙값으로 이를 배치하겠다는 뜻이 된다. 클릭해보면 손 쉽게, 중앙 값으로, 혹은 중앙값을 기준으로 변경되는 모습을 확인 할 수 있다. [Auto Layout 값 수정] 아마 레이아웃을 처음 접해보았다면 뭔가 아주많이? 꼬였을 것이다. 빨간줄 범벅 특히, 값을 변경하고 싶은데 값이 적용은 안되고, 줄만 줄줄히 늘어나는 현상… 1-1. Pin은 어디까지나 새로 만들어지는 레이아웃에 대해서 제공되는 것이니, 값을 수정하고 싶다면 따로 우측 인스펙터 부분에서 이를 변경 해야한다. 1-2. 변경할 레이아웃을 선택하고 Edit를 클릭하여 값을 변경하면 뷰 컨트롤러에 적용되는 모습을 확인할 수 있다. 그리고 아예 없애거나, 지우고 싶다면? [Auto Layout 취소, 지우기] 1-1.레이아웃 선을 선택해서 키보드의 지움 버튼(&lt;-)으로 지우거나, 우측 인스펙터 부분을 클릭 후 지움(&lt;-)해주면 지워진다. 애플의 이런 심플함은 가끔 경이롭기까지 하다… 1-2. 레이아웃을 모두 지우는 것도 지원한다. 뷰를 선택후 아래 세모 모양(Resolve Autolayout Lssues)을 클릭하면, Clear Constraints를 확인 할 수 있다. 누르면? 뷰에 해당하는 모든 레이아웃이 지워진다. [Auto Layout Attributes] 레이아웃을 짤때 속성을 기억해주면 좋다. 레이아웃의 지도와 같은 것! [Anatomy of a Constraint] 이것도 구조를 이해하는 것이 좋다. (코드짤 때 도움) [Safe Area와 View의 차이] ⬆︎ Sadfe Area는 파란색 영역에 해당한다. (기기에서의 시계, 베터리, 하위 영역을 제외한 직사각형 영역) ⬆︎ View의 영역 (기기의 모든 전체영역) 기준을 어디에 두느냐에 따라 레이아웃의 값도 달라지니 꼭 참고하여야할 부분이다. Pin에서도 지정할 수있도록 지원되어 있다. //iphone8 (20.0,0,0) //iphineX (44,0,34,0) [Frame과 Auto Layout] 이미지를 살펴보면 Auto Layout이 지원되는 방식을 알 수 있다. Frame과 Auto Layout 모두 x,y축을 기본값으로 하지만, 왼쪽 이미지인 Frame은 좌표를 중점으로 두고 있다면, Auto Layout은 view사이의 상대적인 값에 중점을 두는 모습을 볼 수 있다. 그래서, 레이아웃 값을 지정할때, 첫번째 뷰를 먼저 잡고, 이와 가장 근접해 있는 뷰&gt;근접 뷰&gt; 근접 뷰&gt; 근접 뷰&gt;…이런 방식으로 레이아웃을 잡아가는 게 좋다. 실전 예제 [Auto Layou] 아래의 것을 오토레이 아웃을 이용하여 잡기 1-1. 일단 view를 2개 얹고 시작. 오토레이아웃을 이해했다면, 위 화면 정도는 금방 구현해낼 것이다. 하지만, 여기서 문제가 있다. 화면을 아래와 같이 돌리게 되면 ? 이런 식으로 레이아웃이 깨지는 현상을 볼 수 있다. 이것도 기기의 비율에 맞춰 나올 수 있도록 하려면 ? 1-2 . Equal Width, Equal Height 활용하기. 레이아웃에 대한 비율을 맞추려면, control키를 누른채 드래그 하여 buleView에서 redView를 잇고 놓으면 위와 같은 목록이 뜬다.여기서 Equal Width, Equal Height 을 통해 이전 뷰에 대한 비율 맞추기가 가능하다! 그리고 클릭에서 끝나는게 아니라 우측 탭에서 &quot;Proportional Width(Height) to view&quot;를 확인할 수 있는 데, 꼭 Edit을 눌러서 비율을 '1’로 맞추도록한다. 1:1 비율로 해야하니깐(수치를 다르게 하면서 확인해보도록) 그러면 ? 가로방향으로 시뮬을 돌려도 레이아웃이 깨지지 않는 모습을 확인할 수 있다. 실전 예제 [frame] frame 방식도 위의 실전예제와 동일한 예제로 구현해보자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import UIKitclass safeViewController: UIViewController &#123; let view1 = UIView() let view2 = UIView() //super.view.adgeAreaInsets override func viewDidLoad() &#123; super.viewDidLoad() view1.backgroundColor = .red view.addSubview(view1) view2.backgroundColor = .blue view.addSubview(view2) &#125; override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) print(\"view.viewWillAppear\") &#125; override func viewWillLayoutSubviews() &#123; //뷰의 크기가 바뀌었을때, 위치를 바꿔주는 역할. (이곳에 쓰는게 정확. super.viewWillLayoutSubviews() let margin: CGFloat = 20 let padding: CGFloat = 10 let safeLayoutInset = view.safeAreaInsets let horizontalInset = safeLayoutInset.left + safeLayoutInset.right let yOffset = safeLayoutInset.top + margin let viewWidth = (view.frame.width - padding - horizontalInset) / 2 - margin view1.frame = CGRect(x: safeLayoutInset.left + margin, y: yOffset, width: viewWidth, height: view.bounds.height - yOffset - (safeLayoutInset.bottom + margin)) view2.frame = CGRect( origin : CGPoint(x: view1.frame.maxX + padding, y: yOffset), size: view1.bounds.size) //frame넣든, bounds넣든 관계없음. &#125; override func viewSafeAreaInsetsDidChange() &#123; //세이프에어리얼과 인셋을 바꿔주는 시점을 알려주는 역할. //safeArea(세이프 영역) super.viewSafeAreaInsetsDidChange() print(view.safeAreaInsets) &#125; override func viewDidAppear(_ animated: Bool) &#123; super.viewDidAppear(animated) print(\"viewDisAppear\") &#125; &#125; 위 코드는 스토리보드 방식이 아닌, frame 방식을 이용하여 화면을 구현한 것이다. frame을 이용했다면, 레이아웃을 굳이 잡지 않아도 된다. 다만, 사실 코드로 레이아웃을 잡는 방법은 아주 다양하고 , 레이아웃의 순번을 통해 UI를 잡거나 하는, (프레임만으로는 표현할 수 없다.) 법을 사용해야할 수도 있다. 그래서 frame 외, 오토레이아웃 외에도 코드로 레이아웃을 잡는 방법은 아래를 참고하자 [링크 준비중] (심화부분일 수 있는데 익순해지면 간단해진다.) 어쨌든 이번 포스트에서는 오토레이아웃이지만, 생각보다 손을 많이 대줘야하는?? 오토레이 아웃ㅋㅋ이지만, 완전하고 안전성있는 UI를 위한 방법이니 꼭 참고하여 앱을 만들자 ! 🙀","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"AutoLayout","slug":"AutoLayout","permalink":"https://qussk.github.io/tags/AutoLayout/"},{"name":"UIView","slug":"UIView","permalink":"https://qussk.github.io/tags/UIView/"}]},{"title":"[Swift]UserDefault로 데이터 저장하기","slug":"Swift-UserDefault로-데이터-저장하기","date":"2020-05-13T17:31:10.000Z","updated":"2020-09-14T08:28:54.136Z","comments":false,"path":"2020/05/14/Swift-UserDefault로-데이터-저장하기/","link":"2020/05/13/Swift-UserDefault로-데이터-저장하기","permalink":"https://qussk.github.io/2020/05/14/Swift-UserDefault%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%80%EC%9E%A5%ED%95%98%EA%B8%B0/","excerpt":"","text":"UserDefault 이해하기 쉽게 말하면, 앱상의 작은 저장공간이라고 생각하면 된다. 앱을 종료하여도, 사용자의 데이터가 다시 리셋되지 않도록 기억해주는 장치. 예제로 쉽게 이해해보도록 하자! UserDefault 활용하기 구현 목표 123451. 스위치를 On으로 하면 강아지사진, Off는 고양이사진. (Bool을 활용하면된다.)2. 레이블도 스위치에 따라 함께 변경. &quot;Dog&quot; : &quot;Cat&quot;3. 텍스트필드는 save버튼 누른 다음의 뷰화면(프로필 화면)에 name으로 변경될 것.4. 사진(이미지),레이블(Dog&#x2F;Cat),텍스트필드(data) 모두 마찬가지.5. 변경내용을 모두 제자리로 돌리는 Setup버튼 구현. 1. UI짜기, 구조설정 1-1. @IBOutlet 및 @IBAction 연결. 123456789101112131415@IBOutlet var animalPhoto: UIImageView! //imageSwich@IBOutlet var animalLable: UILabel! //Dog@IBOutlet var animalSwitch: UISwitch! //스위치 아울렛@IBOutlet var animalTextField: UITextField! //텍스트필드(name) //스위치 액션 @IBAction func isSwitch(_ sender: UISwitch) &#123; &#125; //저장버튼 @IBAction func saveButton(_ button : UIButton) &#123; //셋업버튼 @IBAction func setButton(_ button: UIButton) &#123; &#125; IBOutlet과 IBAction을 구분하여 연결지어 준다. 이때, Switch는 아울렛과 액션 모두 연결해야한다. (아울렛일때와 액션일때의 기능 분리.) 1-2. Key 값 설정. 123456struct Key &#123; static let photo &#x3D; &quot;imageSwich&quot; static let photoLable &#x3D; &quot;Dog&quot; static let name &#x3D; &quot;name&quot; static let isOn &#x3D; &quot;inOn&quot;&#125; 데이터를 불러오기 쉽게 Key값으로 변수를 설정한다. 2. UserDefault 선언과 Switch값 설정하기. 2-1. userDefaults를 상수로 지정. 1let userDefaults &#x3D; UserDefaults.standard userDefaults를 쓰기위해 UserDefaults.standard의 고정값이 필요하다. 자주 쓰기 위해 상수로 선언하여 활용한다. 2-2. Switch 설정하기. 먼저, viewDidLoad에 스위치에 대한 상시값(isOn)을 넣는다. 12let isOn = userDefaults.bool(forKey: Key.photo)configureData(isOn: isOn) 스위치는 on/off 딱 두 타입 뿐이므로, true/false로 구분되기 때문에 userDefaults중에서도 Bool타입으로 지정한다. (userDefaults를 지정할때 해당하는 것에 맞는 타입으로 꼭 선택해야한다.) forKey는 Key값을 활용하여 넣는다. 위의 configureData는 Switch가 on상태일 때의 값을 지정한 함수이름이다. (아래 코드 참고) 12345func configureData(isOn: Bool) &#123;let animal = isOn ? \"dog\" : \"cat\"animalPhoto.image = UIImage(named: animal)animalLable.text = animal &#125; 해당 스위치의 액션버튼에 userDefaults.set 적용하기 12345@IBAction func isSwitch(_ sender: UISwitch) &#123; configureData(isOn: sender.isOn) userDefaults.set(sender.isOn, forKey: Key.photo) &#125; set은 저장할때 사용한다. 3. UserDefault 적용. 3-1. 저장하기 버튼에 UserDefault 적용. 12345678@IBAction func saveButton(_ button : UIButton) &#123; let animal = animalSwitch.isOn ? \"dog\" : \"cat\" let userDefaults = UserDefaults.standard // userDefaults.set(animalLable.text, forKey: Key.photoLable) //아래의 photo와 중복되므로 생략해도됨. userDefaults.set(animal, forKey: Key.photo) userDefaults.set(animalSwitch.isOn, forKey: Key.isOn) userDefaults.set(animalTextField.text, forKey: Key.name) IBAtion타입을 Any?에서 button으로 바꿔준다. (_ button : UIButton) animalSwitch.isOn ? “dog” : &quot;cat&quot;을 적용할 수 있는 변수 animal 선언. (func configureData 에서 써준건 해당 함수에서만 쓸 수 있으니까… 재선언) 값에 맞게 모두 set을 적용한다. 이미지 = animal, (Key.photo) / 스위치 = animalSwitch.isOn(Key.isOn)/ 텍스트필드 = animalTextField.text(Key.name) 3-2. 셋업 버튼에 UserDefault 적용. 1234567891011121314151617//셋업버튼@IBAction func setButton(_ button: UIButton) &#123; let userDefaults = UserDefaults.standard let animal = animalSwitch.isOn ? \"dog\" : \"cat\" let isPhoto = userDefaults.bool(forKey: Key.photo) let isanimalSwitch = userDefaults.bool(forKey: Key.isOn) let isPhotoLable = userDefaults.bool(forKey: Key.photoLable) let isAnimalTextfield = (userDefaults.object(forKey: Key.name) as? Data) ?? Data() animalPhoto.image = UIImage(named: animal) animalSwitch.setOn(isanimalSwitch, animated: true) animalTextField.text = \"\\(Key.name)\"&#125; 셋업버튼에 대한 새로운 이름의 상수로 선언후 (Save한 값으로 되돌릴 수 있는 작업) 값 선언. 타입을 지정할 수 없는 경우 object 선언하여 타입캐스팅이용함. (아래 참고) 1let isAnimalTextfield &#x3D; (userDefaults.object(forKey: Key.name) as? Data) ?? Data() 위를 늘려쓰면 아래와 같은 느낌. (예시임,) 123let ob = userDefaults.object(forKey: Key.today)let tempDate = ob as? Datelet tempTodat = tempDate ?? Date() 데이터에 해당하는 값 매칭. (고정값임((외우자)) image는 UIimage Switch는 setOn Textfield는 text (해당없지만)Date는 setDate 그러면 일단 여기까지는 완성이 된다. (이미지가 안뜬다면, Assets.xcassets에 image를 추가하였는지 확인!.. 파일이름은 강아지: dog, 고양이: cat) Save도 정상적으로 되나 확인해볼까? 하는데, 키보드가 안내려가는 상황 발생! ( cm + k 하면 내려가지만 언제나 앱이라는 가정하에 진행해야하니까…!!!) 4. Textfield Delegate 이번에는 딜리게이트를 이용하여 키보드에 대한 설정을 바꿔보도록 한다. 딜리게이트는, ‘(너가 기본적으로 제공해주는 것보다)내가 알아서 설정해서 쓸게,!’ 라는 걸 선언하는 것이다. 4-1. Delegate 선언 1class animalDefaultViewController: UIViewController, UITextFieldDelegate &#123; 클래스에 UITextFieldDelegate를 추가한다. 4-2. 셀프 선언 1234override func viewDidLoad() &#123;super.viewDidLoad()animalTextField.delegate = self 딜리게이트 설정이 필요한 해당 텍스트필드(animalTextField)와 delegate를 불러와 self를 viewDidLoad에 선언한다. 4-2. return 시 키보드 닫음 설정. 123456//리턴시 키보드 닫음func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool &#123; textField.resignFirstResponder() return true&#125; 크게 구현할 내용은 없고, 키보드에 [Return]을 누르게 되면 키보드가 닫힐 수 있도록 설정한다. 그러면… 텍스트필드를 입력하고 리턴을 누르면 키보드가 내려간다 !! 이제 이것저것 설정하고 Save 버튼을 누르면? …! 화면이 넘어가지 않는다… 😸 5.화면전환 이미 스토리보드로 시작한거… segue로 화면전환을 할까? 하다가 역시 깔끔한게 좋아서 코드로 화면전환을 해보자 !! 원래 코드로 시작하면, 끝까지 코드로만 하고, 스토리보드로 시작하면, 끝까지 스코리보드로만 하는 게 정석인 듯 싶지만… 겸하는 것도 어찌됐든 가능하다. 일단, Save버튼을 누른후 화면이 전환이 되는 구성이기 때문에 Save버튼으로 이동한다. 5-1. 화면전환 메서드 12345678910111213animalTextField.text ?? \"\"let story = UIStoryboard(name: \"Main\", bundle: nil)guard let vc = story.instantiateViewController(identifier: \"animalViewController\") as? animalViewController else &#123;return&#125;//값전달vc.profileName = \"\\(animalTextField.text!)\"vc.animalName = \"\\(animalLable.text!)\"vc.profileImage = UIImage(named: animal)!//화면전환 스타일 vc.modalPresentationStyle = .fullScreenpresent(vc, animated: true) let story = UIStoryboard(name: “Main”, bundle: nil) 스토리 보드를 가져온다. &quot;Main&quot;은 거의 고정값이므로 외운다.(맨앞에 M은 대문자 필수!) vc에 스토리보드의 instantiateViewController을 불러온 후, identifier이름을 붙여넣는다. (identifier: “animalViewController”). animalViewController은 두 번째 뷰컨 이름(목적지뷰)이다. as? animalViewController else {return} 역시 같은 이름으로 붙여넣는다. (identifier 이름은 보통 뷰컨트롤러의 이름과 동일하게 짓는다.) vc.에 화면전환시 값이 전달될 곳으로 매칭한다. 두번째 뷰에는 이미지-이미지, 텍스트필드 - 레이블1, 레이블 - 레이블2 로 총 3가지만 받아오면 된다. (이미지의 경우 UIImage(named: )!의 형식임을 외우자.) vc.modalPresentationStyle = .fullScreen로 프리젠트 스타일을 설정하고, present(vc, animated: true)를 불러온다. (필수) 그러면 ? 화면은 전환이 되나, 데이터가 이동되지 않은 모습을 볼 수 있다 Why? 전달된 값을 받는 작업을 수행하지 않았기 때문에… 5-2. 값 받기 일단, 두 번째 뷰 컨트롤러(animalViewController)로 이동한다. 이건 초간단하니 간단하게. 아울렛 연결 123@IBOutlet var profilePhoto: UIImageView!@IBOutlet var profileLable: UILabel!@IBOutlet var profileNameLable: UILabel! 변수 만들기 123var profileName = \"\" var animalName = \"\" var profileImage = UIImage() viewDidLoad에 값 설정. 123profileNameLable.text = profileName profileLable.text = animalName profilePhoto.image = profileImage 두번째 화면으로 넘어갔을 때 바로 값을 불러와야하기때문에 viewDidLoad에 값을 설정한다. 이 부분은. 5-1 의 4)부분을 참고하여 매칭하면 된다. 그러고 빌드를 하면? 이런 식으로 모두 값을 받아오는 모습을 볼 수 있다. 사진 아래에 [&lt;&lt;정보변경하기]라는 버튼을 달아줬다. 이전화면으로 돌아가는 게 없어서 불편해서… 화면 닫힘. (이전 화면으로) 12345@IBAction func editButton(_ sender: Any) &#123; dismiss(animated: true) &#123; &#125;&#125; @IBAction 으로 이은후 dismiss만 해주면 끝. 끝 !! 앱을 종료하여도, 가장 마지막으로 값으로 Save한 시점에 계속 저장되어있는 모습을 볼 수 있다. 그리고 setUp버튼은 Save한 값과 다르게 설정하다가 setUp을 누르면 Save한 값으로 돌아가는 용도이다. 직접해서 확인해보면 될 듯… ㅎㅎ 이것으로 마무리 한다! 👐🏻 👾 👐🏻 [전체코드 ] 전체 코드를 보며 흐름을 참고하자! 첫번 째 뷰컨(animalDefaultViewController) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import UIKitclass animalDefaultViewController: UIViewController, UITextFieldDelegate &#123; struct Key &#123; static let photo = \"imageSwich\" static let photoLable = \"Dog\" static let name = \"name\" static let isOn = \"inOn\" &#125; @IBOutlet var animalPhoto: UIImageView! //imageSwich @IBOutlet var animalLable: UILabel! //Dog @IBOutlet var animalSwitch: UISwitch! //스위치 아울렛 @IBOutlet var animalTextField: UITextField! let userDefaults = UserDefaults.standard override func viewDidLoad() &#123; super.viewDidLoad() animalTextField.delegate = self let isOn = userDefaults.bool(forKey: Key.photo) configureData(isOn: isOn) &#125; @IBAction func isSwitch(_ sender: UISwitch) &#123; let userDefaults = UserDefaults.standard configureData(isOn: sender.isOn) userDefaults.set(sender.isOn, forKey: Key.photo) &#125; func configureData(isOn: Bool) &#123; let animal = isOn ? \"dog\" : \"cat\" animalPhoto.image = UIImage(named: animal) animalLable.text = animal &#125; //저장버튼 @IBAction func saveButton(_ button : UIButton) &#123; let animal = animalSwitch.isOn ? \"dog\" : \"cat\" let userDefaults = UserDefaults.standard// userDefaults.set(animalLable.text, forKey: Key.photoLable) userDefaults.set(animal, forKey: Key.photo) userDefaults.set(animalSwitch.isOn, forKey: Key.isOn) userDefaults.set(animalTextField.text, forKey: Key.name) animalTextField.text ?? \"\" let story = UIStoryboard(name: \"Main\", bundle: nil) guard let vc = story.instantiateViewController(identifier: \"animalViewController\") as? animalViewController else &#123;return&#125; vc.profileName = \"\\(animalTextField.text!)\" vc.animalName = \"\\(animalLable.text!)\" vc.profileImage = UIImage(named: animal)! vc.modalPresentationStyle = .fullScreen present(vc, animated: true) &#125; //리턴시 키보드 닫음 func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool &#123; textField.resignFirstResponder() return true &#125; //셋업버튼 @IBAction func setButton(_ button: UIButton) &#123; let userDefaults = UserDefaults.standard let animal = animalSwitch.isOn ? \"dog\" : \"cat\" let isPhoto = userDefaults.bool(forKey: Key.photo) let isanimalSwitch = userDefaults.bool(forKey: Key.isOn) let isPhotoLable = userDefaults.bool(forKey: Key.photoLable) let isAnimalTextfield = (userDefaults.object(forKey: Key.name) as? Data) ?? Data() animalPhoto.image = UIImage(named: animal) animalSwitch.setOn(isanimalSwitch, animated: true) animalTextField.text = \"\\(Key.name)\" &#125; &#125; 두 번째 뷰컨(animalViewController) 12345678910111213141516171819202122232425262728293031323334import UIKitclass animalViewController: UIViewController &#123; var profileName = \"\" var animalName = \"\" var profileImage = UIImage() override func viewDidLoad() &#123; super.viewDidLoad() profileNameLable.text = profileName profileLable.text = animalName profilePhoto.image = profileImage &#125; @IBOutlet var profilePhoto: UIImageView! @IBOutlet var profileLable: UILabel! @IBOutlet var profileNameLable: UILabel! @IBAction func editButton(_ sender: Any) &#123; dismiss(animated: true) &#123; &#125; &#125; &#125;","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"TextField","slug":"TextField","permalink":"https://qussk.github.io/tags/TextField/"},{"name":"TextFieldDelegate","slug":"TextFieldDelegate","permalink":"https://qussk.github.io/tags/TextFieldDelegate/"},{"name":"UserDefault","slug":"UserDefault","permalink":"https://qussk.github.io/tags/UserDefault/"},{"name":"화면전환","slug":"화면전환","permalink":"https://qussk.github.io/tags/%ED%99%94%EB%A9%B4%EC%A0%84%ED%99%98/"},{"name":"ImageView","slug":"ImageView","permalink":"https://qussk.github.io/tags/ImageView/"}]},{"title":"[라이브러리]SideMenu사용하기","slug":"라이브러리-SiedMenu사용법","date":"2020-05-12T21:45:50.000Z","updated":"2020-09-14T08:28:54.149Z","comments":false,"path":"2020/05/13/라이브러리-SiedMenu사용법/","link":"2020/05/12/라이브러리-SiedMenu사용법","permalink":"https://qussk.github.io/2020/05/13/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-SiedMenu%EC%82%AC%EC%9A%A9%EB%B2%95/","excerpt":"","text":"앱에서 자주 사용되는 ‘사이드메뉴 바’ 가 있다. 일명 '햄버거메뉴’라고도 한다. 코드로 직접구현해도 되겠지만, 쉽게 라이브러리를 통해 구현도 가능하니 방법을 알아보자. 1. 설치하기 1-1. 사이트 이동하기. 아래 링크를 클릭하여 해당 사이트로 이동. [https://github.com/jonkykong/SideMenu] 1-2. 터미널에 cocoapods install하기 설치 1$ sudo gem install cocoapods 해당 경로로 가서 cocoapods init ~ install 1pod init 1pod install 1-3. 버전에 맞춰 Podfile 설치 최신버전 1pod &#39;SideMenu&#39; (만약 swift 버전이 이전 버전일 경우 사이트의 Installation 부분 참조하여 설치!) 2. 사용하기 2-1. 사이드메뉴로 할 컬트롤러의 class 이름을 &quot;SideMenuNavigationController&quot;로 지정한다. (podfile에 SideMenu라이브러리가 정상적으로 설치가 되었다면, 아래 이미지의 해당 메뉴를 확인 할 수 있을 것이다. ) 2-2. 해당 부분의 on은 왼쪽으로, off는 오른쪽 팝업이라는 의미다. 이렇게 선택해서 사용하면 된다. 적용된 모습. png 😺 잘모르겠다면, 글쓴이가 직접 쓴 사용방법이 있으니, 해당 사이트의 Usage 구간을 참고하도록 하자.","categories":[{"name":"Library","slug":"Library","permalink":"https://qussk.github.io/categories/Library/"}],"tags":[{"name":"라이브러리","slug":"라이브러리","permalink":"https://qussk.github.io/tags/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/"},{"name":"SideMenu","slug":"SideMenu","permalink":"https://qussk.github.io/tags/SideMenu/"}]},{"title":"[Swift]스토리보드에서 Segue이해하기","slug":"Swift-스토리보드에서-Segue이해하기","date":"2020-05-08T11:30:08.000Z","updated":"2020-09-14T08:28:54.142Z","comments":false,"path":"2020/05/08/Swift-스토리보드에서-Segue이해하기/","link":"2020/05/08/Swift-스토리보드에서-Segue이해하기","permalink":"https://qussk.github.io/2020/05/08/Swift-%EC%8A%A4%ED%86%A0%EB%A6%AC%EB%B3%B4%EB%93%9C%EC%97%90%EC%84%9C-Segue%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/","excerpt":"","text":"앱개발하다보면 필수적으로 [화면전환]에 대한 문제를 맞딱드리게 된다… 그래서 막상 코드로 구현하다 보면… 생각보다(?:0) 어렵다… 쉬운듯 어렵고, 심플한듯 복잡한… 사용할 땐 화면에 대한 생각전혀 해보지 못하고 슉슉 넘겨댔는데… 구현하는 건 왜케 어려워… 할 수도 있다. 실제로 나도 그랬으니까. 그리고 그게 풀리지 않을때는 구글링해보다가… 어라 ? 모야모야 스토리보드에서 쉽게 화면전환 할 수 있잖아~~~?? 라고 생각하고 그게 나와 세그웨이의 첫만남… 세그웨이를 ㅍㅍ검색하시는 분들도 있겠지… 나야나 근데 막상 세그웨이 글 봐도 원하는게 안돼서 그냥 코드로 했었음ㅋㅋ…ㅠㅠ 그래서 나와 비슷한 경험을 하시는(?) 분들을 위해 세그웨이에 대한 정보를 정말 간단하게 정리해보았다. 세그웨이 이해 한쪽 방향으로만 흐르는 [화면전환]으로, 출발지와 목적지의 특성을 갖는다. 대충 이렇게 생각하면 쉬울 것 같다. (이게 다니까…) 세그웨이의 특징 스토리 보드로 쉽게 구현이 가능하다. 소스코드를 이용해서 화면 전환을 처리를 하려면 대상이 되는 뷰 컨트롤러의 정보를 읽어와 직접 인스턴스화 한 후에 화면을 전환해야 하지만, 세그웨이를 이용하면 뷰 컨트롤러에 대한 정보가 없어도 된다. (세그웨이가 스토리보드상의 연결 정보를 이용하여 대상 뷰 컨트롤러의 인스턴스를 자동으로 만들어 주기 때문) 세그웨이의 장단점 장점 구현이 쉽다. 화면과 화면을 연결하기 위해 아무런 소스 코드도 필요로 하지 않는다 단점 일괄적으로 적용되는 것이라 특정 상황에 대응하기 어렵다. 알다시피, 모든 개념에는 좋고 안좋고 보다, 각자의 상황에 알맞게 사용하는 게 중요하다는 점을 꼭 기억하자 ! 세그웨이 종류 세그웨이의 종류는 2가지가 있다. &quot;액션 세그웨이(Action Segue == Trigger Segue)&quot;와 &quot;메뉴얼 세그웨이(Manual Segue)&quot;가 있는데, 쉽게 구분하자면 아래를 보자. 액션 세그웨이(Action Segue : 버튼(출발지) - 뷰컨트롤러(목적지) 메뉴얼 세그웨이(Manual Segue) : 뷰컨트롤러(출발지) ~ 액션 세그웨이는 버튼의 터치 이벤트가 세그웨이로 실행으로 바로 연결되므로, 소스 코드를 추가하지 않아도 화면 전환 기능을 구현하지만, 매뉴얼 세그웨이는 UIKit 프레임워크에 정의된 performSegue(withIdentifier : sender) 메소드를 사용하기 때문에 원활한 사용을 위해 별도의 Identifier를 지정해줘야한다. ( 이것에 대한 내용은 이후 구현 포스팅에서 참고하자) 1. 세그웨이 활용 일단 글만보면 이해가 안되므로 아래 이미지를 보자. (예시는 액션세그웨이로 진행하였다.) 1-1. 이미지와 같이 뷰컨트롤러를 2개 만들고 A ViewController에 Button을 하나 추가한다. 1-2. 스토리보드상의 Button을 control을 누른 채 다음으로 보여줄 화면(목적지화면)으로 드래그 하여 커서를 놓는다. 1-3. 그럼 검정색 작은 메뉴얼이 뜨는데 여기서 show로 해줄지, PresentModally로 해줄지 선택한다. (show는 단순화면 전환시, PresentModally 화면전환시 부가 기능 추가) 1-4. 생성된 sege줄을 클릭하면 (위 이미지)1-3에 대한 변경이 가능하니 참고하자. 1-5. PresentModally로 선택시 present Stly 변경이 가능하다. (Automatic은 일반 present 스타일로 위에서 아래로 나오는 카드형. FullScreen은 풀화면형.) 위를 적용시 빌드를 하면, 버튼을 누를 때 목적지화면으로 전환되는 모습을 볼 수 있다. 다만, 그 화면에서는 이제 아무것도 할 수가 없다. 왜냐하면 정말 뷰만 이어 놓았기 때문에… (뒤로갈 수 있는 버튼도 없고, 네비게이션 바가 있는 것도 아니고…) 2. Exit 그래서 당황한 나머지? 이런 실수를 할 수 있다. &quot;1.에서 한 방법처럼 또 show!로 세그웨이 연결해주면 되지 !!! &quot; 하고 아래의 이미지와 같이 행동했다면… 아주 이상한 경험을 할 수 있다. 그러니까, 12A -&gt; B B &lt;- A 의 형태로 화면전환이 되는 것이 아니라, 1A -&gt; B -&gt; A -&gt; B -&gt; A -&gt; B -&gt; A -&gt; B -&gt; A -&gt; B ...(무한) 이런 형태로 화면이 계속 생성되서… 이런 몹쓸 형태의 구조가 된다. 세그웨이는 목적지가 되는 뷰 컨트롤러의 인스턴스를 자동으로 생성하기때문에, 역방향의 세그웨이를 다시 생성한다는 것은 이미 존재하는 뷰 컨트롤러의 인스턴스를 또 다시 만들어 낸다는 의미이다. 그러면 동일한 뷰 컨트롤러가 중복되는 것. 이러면 앱을 사용할 수 없다. (오류가 날 수 있음) 그래서 우리는 [화면복귀]라는 개념을 알아야한다. 화면 복귀하는 법은 아주 간단하다. unwindow개념을 사용하면 된다. 새로운 화면으로 전환하는 것을 Wind 라고 한다면 Unwind는 Wind 작업을 해제한다는 의미라고 볼 수 있다. 2-1. unwind 코드 불러오기. 2-2. unwind에 복귀할 화면(ViewController)으로 고쳐쓰기. 1234@IBAction func unwindToAViewController(_ unwindSegue: UIStoryboardSegue) &#123; let sourceViewController &#x3D; unwindSegue.source &#125; A -&gt; B AViewController에서 BViewController로 이동하는 화면이었다면, B에서 다시 A로 복귀해야하므로, AViewController에 해당 코드를 입력함. 2-3. Exit 달기. BViewController에서 버튼을 드래그 하고 &quot;도크(노란색)&quot;버튼 에서 맨뒤에 있는 Exit단추에 놓아주면 2-2에서 만들었던 목록이 아래에 뜨고 돌아갈 화면의 ViewController이름을 선택하면 된다. 해당화면(BViewController)에서 버튼을 누르면 다시 이전화면(AViewController)으로 복귀할 수 있도록 … 그럼 ? present가 계속 생성되는 것이 아닌, 이전화면으로 깔끔하게 돌아가는 모습을 볼 수 있다. 👏🏻👏🏻👏🏻 🤠 세그웨이에 대한 자세한 활용은 다음 포스트에 남길 계획이다.","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"화면전환","slug":"화면전환","permalink":"https://qussk.github.io/tags/%ED%99%94%EB%A9%B4%EC%A0%84%ED%99%98/"},{"name":"Segue","slug":"Segue","permalink":"https://qussk.github.io/tags/Segue/"},{"name":"present","slug":"present","permalink":"https://qussk.github.io/tags/present/"}]},{"title":"[Swift] Segue(세그웨이)를 이용한 화면전환","slug":"Swift-Segue-세그웨이-를-이용한-화면전환","date":"2020-05-08T11:28:59.000Z","updated":"2020-09-14T08:28:54.130Z","comments":false,"path":"2020/05/08/Swift-Segue-세그웨이-를-이용한-화면전환/","link":"2020/05/08/Swift-Segue-세그웨이-를-이용한-화면전환","permalink":"https://qussk.github.io/2020/05/08/Swift-Segue-%EC%84%B8%EA%B7%B8%EC%9B%A8%EC%9D%B4-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%99%94%EB%A9%B4%EC%A0%84%ED%99%98/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"[Swift]화면전환 구현하기","slug":"Swift-화면전환-구현하기","date":"2020-05-06T16:52:03.000Z","updated":"2020-09-14T08:28:54.145Z","comments":false,"path":"2020/05/07/Swift-화면전환-구현하기/","link":"2020/05/06/Swift-화면전환-구현하기","permalink":"https://qussk.github.io/2020/05/07/Swift-%ED%99%94%EB%A9%B4%EC%A0%84%ED%99%98-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/","excerpt":"","text":"하… 힘들 쓰… 뭐했다고 힘들지? 착각인가? 어쨌든 오늘은 레이블과 화면전환을 이용해 데이터를 전달하는 용도로 만들어 보고자 한다. 먼저 첫 화면을 만든다. 1. 화면구성 (프레임짜기) 1-1. 레이블2개, 버튼 1개 만들기 1234567891011121314151617181920212223242526272829303132333435363738394041import UIKitclass endViewController: UIViewController &#123; let editButton = UIButton() let namelabel = UILabel() let emaillabel = UILabel() override func viewDidLoad() &#123; super.viewDidLoad() namelabel.frame = CGRect(x: 70, y: 50, width: view.frame.width - 140, height: 50) namelabel.backgroundColor = .black namelabel.textAlignment = .center namelabel.text = \"이름\" namelabel.textColor = .white namelabel.font = UIFont.systemFont(ofSize: 30) view.addSubview(namelabel) emaillabel.frame = CGRect(x: 70, y: 120, width: view.frame.width - 140, height: 50) emaillabel.backgroundColor = .black emaillabel.textAlignment = .center emaillabel.text = \"email주소\" emaillabel.textColor = .white emaillabel.font = UIFont.systemFont(ofSize: 30) view.addSubview(emaillabel) editButton.frame = CGRect(x: 70, y: 220, width: view.frame.width - 140, height: 50) editButton.setTitle(\"정보변경하기\", for: .normal) editButton.backgroundColor = .darkGray view.addSubview(editButton) editButton.addTarget(self, action: #selector(editbutton(_:)), for: .touchUpInside) &#125; @objc func editbutton(_ sender: UIButton) &#123; &#125; Lable과 Button에서 기억해야할 것 Lable은 text고 , Button은 setTitle이다. Lable Font size가 은근히 안외워 진다. emaillabel.font = UIFont.systemFont(ofSize: 30) CGrect의 view.frame.width는 기기의 비율을 기준으로 하기 때문에 어떤 기기에서든 동일한 비율값으로 정의된다. (많이 사용될 것 같다.) 해당 변수를 전체에서 사용하고자 하면 변수를 바깥으로 뺴줘야한다. 12345class endViewController: UIViewController &#123;let editButton = UIButton() let namelabel = UILabel() let emaillabel = UILabel() 이 외에는 다 외웠음 ㅎㅎ 위의 코드로 메인화면이 완성되었다면, 아래의 화면을 확인 할 수 있을 것이다. 이후에 할 작업은 “정보변경하기(editbutton)” 버튼을 눌렀을 때 이동할 화면을 만들어 준다. 2. 전환될 화면 만들기 버튼을 누르면 화면이 전환되는 방식으로 구현할 것이기 때문에 viewcontrollerr가 하나 더 필요하다. viewcontrollerr를 하나 더 만들고 1-1과 마찬가지로 프레임을 짠다. 2-1. [닫기], [저장] 버튼을 만들어준다. 먼저 내가 구현할 화면은 present(ios13이상)타입의 화면이다. present는 화면이 아래서 위로 올라오는 방식인데, 이 경우 값전달이 안되는 게 기본값이다. (apple기본앱중 알람을 참고하면 된다.) 그냥 손으로 내려서 끌 수 있는 간편한 창같은 것인데… 화면전환으로 간편하게 값 전달을 하고싶다면 fullscreen타입으로 하면된다. 그럼에도 굳이 present화면으로 값전달을 하고 싶은 경우라면… 그건 다음 post에 올리기로 하고… 나는 닫기 버튼과 저장버튼을 만들기로 정했다. 1234567891011121314151617181920212223242526272829303132333435363738import UIKitclass startViewController: UIViewController &#123; let nameTextField = UITextField() let emailTextField = UITextField() override func viewDidLoad() &#123; super.viewDidLoad() view.backgroundColor = .black let buttonX = UIButton() buttonX.frame = CGRect(x: 0, y: 0, width: 50, height: 50) buttonX.setTitle(\"닫기\", for: .normal) buttonX.setTitleColor(.orange, for: .normal) buttonX.backgroundColor = .black view.addSubview(buttonX) buttonX.addTarget(self, action: #selector(buttonOwn(_:)), for: .touchUpInside) let buttonC = UIButton() buttonC.frame = CGRect(x: 323, y: 0, width: 50, height: 50) buttonC.setTitle(\"저장\", for: .normal) buttonC.backgroundColor = .black buttonC.setTitleColor(.orange, for: .normal) view.addSubview(buttonC) buttonC.addTarget(self, action: #selector(buttonTwo(_:)), for: .touchUpInside) @objc private func buttonOwn(_ sender: UIButton)&#123; //닫기버튼 dismiss(animated: true) &#125; @objc func buttonTwo(_ sender: UIButton)&#123; //저장버튼 &#125; 2-2. 텍스트필드를 2개 만든다. (nameLabel과 emailLable에 전달될 nameTextfield, emailTextfield을 만든다.) 1234567891011121314151617181920212223242526nameTextField.frame = CGRect(x: 15, y: 250, width: view.frame.width - 30, height: 44)nameTextField.backgroundColor = .whitenameTextField.borderStyle = .roundedRectnameTextField.keyboardType = .emailAddressview.addSubview(nameTextField) nameTextField.addTarget(self, action: #selector(textFieldN(_:)), for: .editingDidEndOnExit)emailTextField.frame = CGRect(x: 15, y: 300, width: view.frame.width - 30, height: 44) emailTextField.backgroundColor = .white emailTextField.borderStyle = .roundedRect emailTextField.keyboardType = .emailAddress view.addSubview(emailTextField) emailTextField.addTarget(self, action: #selector(textFieldE(_:)), for: .editingDidEndOnExit)&#125;@objc func textFieldN(_ sender: UITextField)&#123; &#125; @objc func textFieldE(_ sender: UITextField)&#123; &#125; TextField에서 기억해야할 것 borderStyle과 keyboardType을 지정해줘야한다. .으로 찍으면 종류가 많이 나온다. &quot;addTarget&quot;에 “for: .editingDidEndOnExit” 은 키보드에서 리턴키를 눌렀을 때 닫아주는 소스다. (아래 TextField사이클 참고) 12345키보드가 뜰때 - DIdBegin입력시 - Changed리턴시 텍스트필드 내려감 - textfieldDidEndOnExit리턴 이후에 뜸.(필연적으로..) PrimaryActionTriggered종료시 - DidEnd 때에 따라 필요 기능이 있을 때에는 아래의 방식으로 구현하면 된다. 12345 @IBAction func DidEnd(_ sender: UITextField) &#123;print(\"5. DidEnd\") print(sender.text) //print(seder.text)할떄, 타입이 Any이면 오류남. Any -&gt; UITextField로 바꿔줘야 print가능. 위 코드대로 모두 짰다면 두 번째 화면이 완성된 모습을 볼 수 있다. 이제 첫번째 화면과 두번 째 화면을 연결지을 일만 남았다. 3. 화면전환하기 첫번째 화면(endViewController)에서 “정보변경하기” 버튼을 누르면 두 번째 화면(startViewController)으로 전환되는 모션이다. ViewController 이름을 반대로 지었다ㅜ 헷깔림 주의 3-1. 버튼을 누르면 두번째 화면으로 이동 버튼을 누르면 이동될 수 있도록 버튼 아래에 해당 코드를 넣는다. 123456@objc func editbutton(_ sender: UIButton) &#123; let nextVC = startViewController() nextVC.modalPresentationStyle = .automatic present(nextVC, animated: true) //아규먼트 nextVC를 넣어주고&#125; nextVC에 startViewController()을 호출하고, 모달을 단다.“nextVC.modalPresentationStyle = .automatic” 여기서 automatic은 기본값(present타입)이다. 만약 풀 스크린을 하고 싶다면 .찍고 fullScreen으로 하면된다. 아규먼트 지정까지하면, 버튼을 누를 때 두번째 화면으로 이동하는 것을 볼 수 있다. 앞서 말했다시피, present타입으로 하면 화면을 내려서 껐을때, 텍스트필드에 적은 데이터가 전달이 안된다. 이를 용이하게 하기 위해, 그리고 present의 화면을 버튼을 이용해서 이전화면을 돌아가기 위해, 우리는 2-1에 [닫기], [저장] 을 만들었다 !! 좀더 완성도 높은 기능을 위해 아래를 참고하자. 3-2. [닫기] 버튼을 누르면 이전화면, [저장]버튼을 누르면 데이터 전달. 닫기동작 코드는 아주쉽다. dismiss만 달아주면 된다. 123@objc private func buttonOwn(_ sender: UIButton)&#123; //닫기버튼 dismiss(animated: true)&#125; 저장버튼도 누르면 화면이 꺼질 수 있다록 dismiss을 달아준다. 다만, [저장]은 데이터를 전달해야하기 때문에 아래와 같은 코드를 더 추가한다. 123456789@objc func buttonTwo(_ sender: UIButton)&#123; //저장버튼 if let vc = self.presentingViewController as? endViewController &#123; vc.namelabel.text = nameTextField.text vc.emaillabel.text = emailTextField.text &#125; dismiss(animated: true) &#125; presentingViewController을 이용해 endViewController을 타입캐스팅 한다. 그리고 버튼을 누르면 텍스트필드의 입력값이 vc(뷰컨)의 해당 Label로 이동되도록 한다. 12vc.namelabel.text &#x3D; nameTextField.textvc.emaillabel.text &#x3D; emailTextField.text 그러면 textField에 값을 입력후 [저장]을 누르면, 아래와 같이 데이터가 전달되는 것을 볼 수 있다. 4.데이터 영구적으로 남기기. 조금 아쉬운건(?) 기껏 레이블을 바꾸어 놓고 정보변경하기 창으로 가면 다시 입력값이 초기화 되어 있다는 것이다. 보안이 중요한 로그인화면에서는 유용하지만, 개인정보창이나 프로필같은 화면에서는 사용자가 본인의 입력값을 확인할 수 있도록 입력한 데이터를 영구히 보여줘야하는 경우도 있다. 보통 데이터라면 데이터를 수집하는 방식을 선택하겠지만, 굳이 수집이 필요하지 않은 데이터라면 사용자의 화면상으로만 영구적으로 저장될 수 있도록 구현해도 좋을 것이다. 일단은 많은 방법이 있겠지만, 그중에서도 간단하게… 입력값이 초기화 되지않고, 사용자가 수정하지 않는 이상 보존되어있는 방식으로 구현해보자. (단, 앱을 종료하면 데이터는 다시 초기화 된다. ) 앱 종료시에도 저장되는 기능은 다음 포스팅인 'UserDefaults’에서 다루기로 하고 일단은 간단하게만 !! 4-1. [정보변경하기]를 눌러도 이전값이 보존되도록 구현 뷰디드로드에 아래와 같은 고정값을 넣는다. 12345if let vc = self.presentingViewController as? endViewController &#123; self.nameTextField.text = vc.namelabel.text self.emailTextField.text = vc.emaillabel.text &#125; 방법은 3-2와 비슷하다. 3-2처럼 레이블에 정보를 전달한 것처럼, 받은 정보를 다시 텍스트 필드로 전달하는 방식을 택하면 된다. 약간 복붙 느낌으로…ㅋ… 그래서 , 뷰디드 로드에 동일하게 &quot;if let vc = self.presentingViewController as? endViewController {&quot;을 불러(연결해)주고, endViewController 의 Label text를 가져와서 해당 TextField에 넣어주면 된다. 그러면 ?? [정보변경하기] 버튼을 누르면 이전에 입력된 값을 그대로 불러오는 모습을 볼 수 있다. 👏🏻 👏🏻. 👏🏻 👏🏻 👏🏻 잘하고 있는 건진 모르겠다만… ㅎ 수집해야할 데이터가 아니고 화면상으로만 간단하게 보여줄 용도라면 레이블을 복사해오는 방식을 택하는 것도 나쁘지 않다… 하지만 앱을 종료하면 사라지는 현실이… 이 부분은 나중에 UserDefaults에서 따로 다루기로 !! (링크는 현재 준비중…) 이것으로 또 하나 끝… 🥒","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"TextField","slug":"TextField","permalink":"https://qussk.github.io/tags/TextField/"},{"name":"present","slug":"present","permalink":"https://qussk.github.io/tags/present/"},{"name":"Button","slug":"Button","permalink":"https://qussk.github.io/tags/Button/"},{"name":"개발일기","slug":"개발일기","permalink":"https://qussk.github.io/tags/%EA%B0%9C%EB%B0%9C%EC%9D%BC%EA%B8%B0/"},{"name":"Label","slug":"Label","permalink":"https://qussk.github.io/tags/Label/"}]},{"title":"[Swift]주문화면 구현하기 -2","slug":"Swift-주문화면-구현하기-2","date":"2020-05-06T15:16:40.000Z","updated":"2020-09-14T08:28:54.143Z","comments":false,"path":"2020/05/07/Swift-주문화면-구현하기-2/","link":"2020/05/06/Swift-주문화면-구현하기-2","permalink":"https://qussk.github.io/2020/05/07/Swift-%EC%A3%BC%EB%AC%B8%ED%99%94%EB%A9%B4-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-2/","excerpt":"","text":"주문화면 구현하기 -2 123456주문 버튼 터치 시 각 아이템에 대한 수량 증가(완료)각 아이템별 주문 수량 증가에 따른 결제금액 증가(완료)결제 진행 시 소지금액에서 결제금액만큼 차감 및 주문수량 초기화(보류중)소지금액이 결제금액보다 적은 경우 결제 불가 메시지 Alert 띄우기초기화 버튼은 주문수량, 결제금액, 소지금액을 모두 초기화초기화 버튼 이외에 한 번 올린 주문수량을 내리는 기능은 없음 현재 1~2는 완료되었고 3은 초기화까지만 완료된 상태다. 결제금액 차감은 결제버튼을 누르면 발생하는 Aler에 따라 실행되어야 하므로 일단 보류해 놓았다. [주문화면 구현하기 -2 참조하기] 현재까지 이상이 없다면 아래의 내용을 계속 진행하자. 4. AlertController 활용 4-1. 버튼에 Alert 달기. 일단 버튼 아래에 let alertController을 살포시 얹는다… 12345678910111213141516@objc func buyButtonClicked(_ sender: UIButton) &#123;let alertController &#x3D; UIAlertController(title: &quot;알림&quot;,message: &quot;결제금액은 모두\\(buyPay)원 입니다.&quot;, preferredStyle: .alert) let alert1Action &#x3D; UIAlertAction(title: &quot;취소&quot;, style: .cancel) &#123; _ in &#125; let alert2Action &#x3D; UIAlertAction(title: &quot;확인&quot;, style: .destructive) &#123; _ in &#125; alertController.addAction(alert1Action) alertController.addAction(alert2Action) present(alertController, animated: true) &#125; &#125; 결제하기 버튼을 누르면 &quot;결제금액은 모두(결제금액)원 입니다.&quot;로 메세지가 나오도록 하고, preferredStyle: 을 .alert로 지정하여 해당 alert을 가운데로 팝업되도록 한다. UIAlertAction으로 “확인(destructive)”, &quot;취소(cancel)&quot;기능을 넣는다. 4-2. 결제하기 누른후 alert에서 &quot;확인&quot;을 누르면 최종적으로 결제가 진행되고, 소지금액 차감. 이전 포스트에서 잠시 보류해 놓았던 3-2를 이곳에 구현한다. 1234567891011121314151617181920let alertController = UIAlertController(title: \"알림\",message: \"결제금액은 모두\\(buyPay)원 입니다.\", preferredStyle: .alert) let alert1Action = UIAlertAction(title: \"취소\", style: .cancel) &#123; _ in &#125; //소지금 - 결제금액 계산 let alert2Action = UIAlertAction(title: \"확인\", style: .destructive) &#123; _ in self.sojiPay = self.sojiPay - self.buyPay self.sojiCost.text! = \"\\(self.sojiPay)원\" &#125; alertController.addAction(alert1Action) alertController.addAction(alert2Action) present(alertController, animated: true) &#125; &#125; &quot;확인&quot;을 누르면 실행되어야 하기 때문에 “확인” UIAlertAction아래에 넣어준다. 소지금액 = 소지금액 - 결제금액 12 - 소지금액레이블.text역시 소지금액값으로 바뀔수 있도록 써준다.&#96;&#96;&#96;self.sojiCost.text! &#x3D; &quot;\\(self.sojiPay)원&quot; 그러면 확인을 누르면 결제가 정상적으로 진행이 되는 모습을 볼 수 있다. 결제 진행 시 소지금액에서 결제금액만큼 차감 및 주문수량 초기화도 모두 마쳤다. 5. Alert에 조건달기 하지만 이것으로 끝이 아니다. 구현사항을 보면, 소지금액은 70000원으로 정해져있고, 결제금액이 소지금액을 초과할 경우 결제가 진행되지 못하도록 Alert을 차단해야한다. 이때, 조건문이 필요하고 코드는 아래와 같은 코드가 된다. 5-1. 소지금액이 결제금액보다 적은 경우 결제 불가 메시지 Alert 띄우기 1234567891011121314151617181920212223242526272829303132@objc func buyButtonClicked(_ sender: UIButton) &#123; if sojiPay &lt;= buyPay &#123; let alertController = UIAlertController(title: \"알림\",message: \"소지금액이 부족합니다\", preferredStyle: .alert) let alert3Action = UIAlertAction(title: \"확인\", style: .cancel) &#123; _ in &#125; alertController.addAction(alert3Action) present(alertController, animated: true) &#125; else &#123; let alertController = UIAlertController(title: \"알림\",message: \"결제금액은 모두\\(buyPay)원 입니다.\", preferredStyle: .alert) let alert1Action = UIAlertAction(title: \"취소\", style: .cancel) &#123; _ in &#125; //소지금 - 결제금액 계산 let alert2Action = UIAlertAction(title: \"확인\", style: .destructive) &#123; _ in self.sojiPay = self.sojiPay - self.buyPay self.sojiCost.text! = \"\\(self.sojiPay)원\" &#125; alertController.addAction(alert1Action) alertController.addAction(alert2Action) present(alertController, animated: true) &#125; &#125; if sojiPay &lt;= buyPay { 의 경우 아래의 Alert이 실행되도록한다. 잊지 말아야하는 부분은 present(alertController, animated: true)도 꼭 달아줘야한다… 사실 시험때 구현은 다 해놓고 present을 실수로 안넣어서… Alert이 작동이 안됐다… 계속 왜 안되는 거야? 하면서 다른곳에서 이유를 찾다가 시간낭비했다… ㅠㅠ… 몬가 변수쪽이 잘못됐다고 생각했던 것… 어쨌든, 이것으로 4.소지금액이 결제금액보다 적은 경우 결제 불가 메시지 Alert 띄우기역시 완료가 되었다. 아래의 5.초기화 버튼은 주문수량, 결제금액, 소지금액을 모두 초기화는 3-1에서 구현이 완료되었고, 6.초기화 버튼 이외에 한 번 올린 주문수량을 내리는 기능은 없음이것도 크게 구현하지 않는 내용이기 때문에 자동으로 클리어된 부분. 셀프체크리스트를 통해 정확하게 구현됐는지 확인한다. 123456789✓ UI 구현 : 스토리보드와 코드를 이용해 정확한 UI 구현✓ 주문하기 기능 : 특정 아이템의 수량이 1씩 증가하며, 결제금액에 반영✓ 결제하기 기능- 소지금에서 결제금액이 정확히 차감. 소지금은 -가 될 수 없음- 소지금이 결제금액보다 작을때, 같을 때, 클 때 각각의 상황 모두 체크✓ 초기화하기 기능 : 소지금, 결제금액, 주문수량의 정보가 모두 정확히 0으로 초기화✓ AlertController 동작- 결제 성공 : &quot;총 결제금액은 ****원입니다.&quot;. 버튼 종류는 확인, 취소 버튼 2개- 결제 실패 : &quot;소지금액이 부족합니다&quot;메시지. 버튼 종류는 확인 버튼 하나 이상이 없다면 이것으로 마침! :princess:","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"화면전환","slug":"화면전환","permalink":"https://qussk.github.io/tags/%ED%99%94%EB%A9%B4%EC%A0%84%ED%99%98/"},{"name":"Alert","slug":"Alert","permalink":"https://qussk.github.io/tags/Alert/"}]},{"title":"[Swift]주문화면 구현하기 -1","slug":"Swift-주문화면-구현하기-1","date":"2020-05-06T13:39:41.000Z","updated":"2020-09-14T08:28:54.143Z","comments":false,"path":"2020/05/06/Swift-주문화면-구현하기-1/","link":"2020/05/06/Swift-주문화면-구현하기-1","permalink":"https://qussk.github.io/2020/05/06/Swift-%EC%A3%BC%EB%AC%B8%ED%99%94%EB%A9%B4-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-1/","excerpt":"","text":"주문화면 구현하기 -1 첫번째 테스트로 보았던 주문화면 구현과정을 써보고자 한다. (스토리보드 영역은 제외, ) 구현사항은 아래와 같다. 구현사항 123456주문 버튼 터치 시 각 아이템에 대한 수량 증가각 아이템별 주문 수량 증가에 따른 결제금액 증가결제 진행 시 소지금액에서 결제금액만큼 차감 및 주문수량 초기화소지금액이 결제금액보다 적은 경우 결제 불가 메시지 Alert 띄우기초기화 버튼은 주문수량, 결제금액, 소지금액을 모두 초기화초기화 버튼 이외에 한 번 올린 주문수량을 내리는 기능은 없음 0. frame짜기 구현하기 이전에 먼저 code로 프레임을 짜는 영역이 있어 프레임부터 만든다. 0-1. 레이블 프레임을 view에 만들기 1234567891011121314151617&#x2F;&#x2F;소지금 Label let sojiLabel &#x3D; UILabel() sojiLabel.frame &#x3D; CGRect(x: 30 , y: 330, width: UI.labelWidth, height: UI.containerHeight) sojiLabel.textAlignment &#x3D; .center sojiLabel.backgroundColor &#x3D; .green sojiLabel.textColor &#x3D; .black sojiLabel.text &#x3D; &quot;소지금&quot; view.addSubview(sojiLabel) let sojiCost &#x3D; UILabel() sojiCost.frame &#x3D; CGRect(x: 120 , y: 330, width: UI.labelWidth+54, height: UI.containerHeight) sojiCost.textAlignment &#x3D; .right sojiCost.backgroundColor &#x3D; .green sojiCost.textColor &#x3D; .black sojiCost.text &#x3D; &quot;70000원&quot; view.addSubview(sojiCost) &quot;sojiLabel.frame&quot;의 width: UI.labelWidth 부분은 구조체를 따로 만들어 해당값을 복사하는 방식으로 만들었다. 12345struct UI &#123; static let containerHeight: CGFloat = 40 static let displayLabelWidth: CGFloat = 140 static let labelWidth: CGFloat = 80&#125; 0-2. 위와 동일한 방법으로 버튼도 만든다. 12345678910111213141516171819202122//초기화버튼 let setupButton = UIButton() setupButton.frame = CGRect(x: 265, y: 330, width: UI.labelWidth, height: UI.containerHeight) setupButton.backgroundColor = .black setupButton.setTitleColor(.orange, for: .normal) setupButton.setTitle(\"초기화\", for: .normal) view.addSubview(setupButton) setupButton.addTarget(self, action: #selector(setupButtonClicked), for: .touchUpInside) //결제하기 버튼 let buyButton = UIButton() buyButton.frame = CGRect(x: 265, y: 370, width: UI.labelWidth, height: UI.containerHeight) buyButton.backgroundColor = .black buyButton.setTitle(\"결제하기\", for: .normal) buyButton.setTitleColor(.orange, for: .normal) view.addSubview(buyButton) buyButton.addTarget(self, action: #selector(buyButtonClicked), for: .touchUpInside) &#125; 다른 점이 있다면, 레이블은 addTaget이 필요없지만, Button은 필요하다(textField도 동일). Lable은 타겟해서 딱히 할게 없기 때문이다… 버튼 타입은 .touchUpInside로 해준다. (버튼을 눌렀을때 동작) 그럼 이정도는 나온다. 1. 변수만들기 1-1. 변수가 필요한 Label은 아웃렛으로 연결한다. 123@IBOutlet var jangCountLabel: UILabel!@IBOutlet var bongCountLabel: UILabel!@IBOutlet var tangCountLabel: UILabel! 1-2. 초기값이 필요한 변수를 파악하고, 초기값을 넣는다. 1234//짜장,짬뽕,탕수육 가격let jangCost = 5000let bongCost = 6000let tangCost = 12000 1-3. 값이 바뀔만한 변수는 didset으로 설정한다. 1234567891011121314151617&#x2F;&#x2F;각 수량 변수 didset으로 담기var jangCount: Int &#x3D; 0&#123; didSet &#123; jangCountLabel.text &#x3D; &quot;\\(jangCount)&quot; &#125;&#125;var bongCount: Int &#x3D; 0 &#123; didSet &#123; bongCountLabel.text &#x3D; &quot;\\(bongCount)&quot; &#125;&#125;var tangCount: Int &#x3D; 0 &#123; didSet &#123; tangCountLabel.text &#x3D; &quot;\\(tangCount)&quot; &#125;&#125; 주문 버튼 터치 시 레이블에 대한 수량 증가가 필요하므로, &quot;jangCountLabel.text&quot;값이 &quot;(jangCount)&quot;로 바뀌게 한다. 1234567(참고)jangCount: 짜장면 수량bongCount: 짬뽕 수량tangCount: 탕수육 수량 jangCountLabel.text: 짜장면 수량 레이블.textbongCountLabel.text: 짬뽕 수량 레이블.texttangCountLabel.text: 탕수육 수량 레이블.text 1234567891011121314//소지금액 변수var sojiPay: Int = 70000 &#123; didSet &#123; sojiCost.text = \"\\(sojiPay)원\" &#125;&#125;//결제금액 변수 var buyPay: Int = 0 &#123;didSet &#123; buyCost.text = \"\\(buyPay)원\" &#125;&#125; *소지금액(sojePay)*과 *결제금액(buyPay)*에 대한 변수도 지정한다. 소지금액은 70000원의 초기값으로 설정하고, 결제금액은 메뉴의 수량에 따라 변동하므로. 1-4. 주문버튼을 누르면 수량이 증가하도록 만든다. 123456789101112//주문 버튼 3개 @IBAction func jangOder(_ sender: Any) &#123; jangCount += 1 &#125; @IBAction func bongOder(_ sender: Any) &#123; bongCount += 1 &#125; @IBAction func tangOder(_ sender: Any) &#123; tangCount += 1 &#125; &#125; 버튼을 누르고 증가한 카운트가 레이블에 적용될 수 있도록. 그럼 1.주문 버튼 터치 시 각 아이템에 대한 수량 증가는 이걸로 완료됐다. 2. 계산메소드 만들기. 각 아이템별 주문 수량 증가에 따른 결제금액 증가가 필요하다. 2-1. 수량에 따라 짜장면+짬뽕+탕수육의 가격을 모두 더해줄 함수 필요. 12345//현재 결제금액을 계산하는 메소드func calcPrice() -&gt; Int &#123; return (jangCount * jangCost) + (bongCount * bongCost) + (tangCount * tangCost) &#125; &quot;calcPrice()&quot;는 (짜장면 x 수량) + (짬뽕 x 수량) + (탕수육 x 수량) 이것은 결제금액레이블에 에 담겨야할 값이기도 하다. 또, 이 함수가 어느 메뉴의 수량이 올라갈 때마다 계산될 수 있도록 이전에(1-3) 써놓은 변수의 didset에 넣어준다. 그러면 다음과 같이 입력된다. 123456789101112131415161718192021//각 수량 변수 didset으로 담기var jangCount: Int = 0&#123; didSet &#123; jangCountLabel.text = \"\\(jangCount)\" buyPay = calcPrice() //결제금액 = 현재 결제금액을 계산하는 메소드() &#125;&#125;var bongCount: Int = 0 &#123; didSet &#123; bongCountLabel.text = \"\\(bongCount)\" buyPay = calcPrice() &#125;&#125;var tangCount: Int = 0 &#123; didSet &#123; tangCountLabel.text = \"\\(tangCount)\" buyPay = calcPrice() &#125;&#125; 수량이 증가할 때마다, 결제금액(buyPay)이 현재 결제금액(calcPrice())을 계산하는 메소드를 호출한다. 그러면 2.각 아이템별 주문 수량 증가에 따른 결제금액 증가는 완료되었다. 3. 전달값 초기화와 결제금액 차감 구현 결제 진행 시 소지금액에서 결제금액만큼 차감 및 주문수량 초기화가 필요하다. 3-1.먼저 초기화부터 보자면, 초기화버튼을 눌렀을 때, 실행될 수 있도록 초기화Button아래에 변수를 재지정해준다. 12345678@objc func setupButtonClicked(_ sender: UIButton) &#123; jangCount = 0 //수량 bongCount = 0 //수량 tangCount = 0 //수량 buyPay = 0 //결제금액 sojiPay = 70000 //소지금액&#125; 초기화버튼을 누르면 수량과, 결제금액, 소지금액 모두 초기값으로 진행되는 코드. 3-2. 소지금 - 결제금액 계산(차감되는 것) 소지금은 70000원으로 고정되어있지만 결제금액은 수량에 따라 변동되는 값이고, 최종적으로 결제를 하게 되면 소지금에서 결제금액이 빠져나가야 하는 방식이다. 그러면, 소지금 = 소지금 - 결제금액 일텐데, 결제금액 차감부분은 alert에서 해당기능을 넣어야 하는 사항이기 때문에, 뒤의 포스프의 alert 부분을 참고하자. alert 먼저 만든후 확인/취소에 따라 결제금액이 차감되어야하기 때문.","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"화면전환","slug":"화면전환","permalink":"https://qussk.github.io/tags/%ED%99%94%EB%A9%B4%EC%A0%84%ED%99%98/"},{"name":"frame","slug":"frame","permalink":"https://qussk.github.io/tags/frame/"},{"name":"Lable","slug":"Lable","permalink":"https://qussk.github.io/tags/Lable/"},{"name":"Button","slug":"Button","permalink":"https://qussk.github.io/tags/Button/"}]},{"title":"[Swift]주문화면 구현하기-feedback","slug":"Swift-주문화면-구현하기-feedback","date":"2020-05-05T23:26:27.000Z","updated":"2020-09-14T08:28:54.144Z","comments":false,"path":"2020/05/06/Swift-주문화면-구현하기-feedback/","link":"2020/05/05/Swift-주문화면-구현하기-feedback","permalink":"https://qussk.github.io/2020/05/06/Swift-%EC%A3%BC%EB%AC%B8%ED%99%94%EB%A9%B4-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-feedback/","excerpt":"","text":"간단한 주문화면 구현하기 fastcampus에서 첫 테스트를 봤다. 시험은 전반적으로 배운 내용이었기 때문에 크게 어렵지 않았지만, 실수한 부분도 많았고, 시간부족으로 미완성한 기능도 있었다. 끝나고는 다른 사람코드로 지혜(?)도 얻고, 강사님 코드를 보고 또 반성하게 되는… 그런 계기도 됐다. 그래서 다시 피드백 및 복습겸 올려본다. 일단 테스트 내용은 아래와 같다. [구현사항] 123456* 주문 버튼 터치 시 각 아이템에 대한 수량 증가* 각 아이템별 주문 수량 증가에 따른 결제금액 증가* 결제 진행 시 소지금액에서 결제금액만큼 차감 및 주문수량 초기화* 소지금액이 결제금액보다 적은 경우 결제 불가 메시지 Alert 띄우기* 초기화 버튼은 주문수량, 결제금액, 소지금액을 모두 초기화* 초기화 버튼 이외에 한 번 올린 주문수량을 내리는 기능은 없음 [실행예시] 짜장면 주문 버튼 클릭 짜장면 수량 : 1 증가 결제금액 : 5000원 탕수육 주문 버튼 클릭 탕수육 수량 : 1 증가 결제금액 : 17000원 (5000 + 12000원) 결제 버튼 클릭 취소, 확인 버튼을 가진 AlertController 띄우기 (메시지 - 총 결제금액은 17000원입니다.) 확인 버튼 클릭 시 70,000원에서 17,000원 차감해 소지금액을 53,000원으로 변경하고 각 메뉴아이템 주문 수량과 결제금액을 0으로 초기화 결제액이 소지금을 초과할 경우, 자동으로 결제를 취소하고 Alert을 이용해 “소지금이 부족합니다” 오류메시지 띄우기 초기화 버튼 클릭 각 아이템 수량 및 결제금액 0원으로 초기화, 소지금 70,000원으로 초기화 [나의 첫번째 code.레포트] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199import UIKitclass ViewController: UIViewController &#123; var countIndex1: Int = 0 //수량1 var countIndex2: Int = 0 //수량2 var countIndex3: Int = 0 //수량3 var countCost: Int = 0 var 소지금 : Int = 70000 var Backup: Int = 0 //초기화 var count: Int = 0 //결제금액 let buycostLable = UILabel() let sojecostLable = UILabel() @IBOutlet var MenuLable: UILabel! @IBOutlet var costLable: UILabel! @IBOutlet var aeLable: UILabel! @IBOutlet var jangLable: UILabel! @IBOutlet var jangcostLable: UILabel! @IBOutlet var jangsLable: UILabel! @IBOutlet var bongLable: UILabel! @IBOutlet var bongcostLable: UILabel! @IBOutlet var bongsLable: UILabel! @IBOutlet var tangLable: UILabel! @IBOutlet var tangcostLable: UILabel! @IBOutlet var tangsLable: UILabel! override func viewDidLoad() &#123; super.viewDidLoad() //view.frame.width let sojeLable = UILabel() sojeLable.frame = CGRect(x: 30, y: 300, width: 70, height: 30) sojeLable.backgroundColor = .green sojeLable.textAlignment = .center sojeLable.text = \"소지금\" sojeLable.textColor = .black sojeLable.font = UIFont.systemFont(ofSize: 17) view.addSubview(sojeLable) sojecostLable.frame = CGRect(x: 120, y: 300, width: 120, height: 30) sojecostLable.backgroundColor = .green sojecostLable.textAlignment = .right sojecostLable.text = \"\\(소지금)원\" sojecostLable.textColor = .black sojecostLable.font = UIFont.systemFont(ofSize: 17) view.addSubview(sojecostLable) let buyLable = UILabel() buyLable.frame = CGRect(x: 30, y: 350, width: 70, height: 30) buyLable.backgroundColor = .orange buyLable.textAlignment = .center buyLable.text = \"결제금액\" buyLable.textColor = .black buyLable.font = UIFont.systemFont(ofSize: 17) view.addSubview(buyLable) buycostLable.frame = CGRect(x: 120, y: 350, width: 120, height: 30) buycostLable.backgroundColor = .orange buycostLable.textAlignment = .right buycostLable.text = \"\\(count)원\" buycostLable.textColor = .black buycostLable.font = UIFont.systemFont(ofSize: 17) view.addSubview(buycostLable) let setBottun = UIButton() setBottun.frame = CGRect(x: 280, y: 300, width: 70, height: 30) setBottun.setTitle(\"초기화\", for: .normal) setBottun.setTitleColor(.orange, for: .normal) setBottun.backgroundColor = .black view.addSubview(setBottun) setBottun.addTarget(self, action: #selector(buttonOne(_:)), for: .touchUpInside) // setBottun.addTarget(self, action: #selector(buttonOne(_:)), for: .touchUpInside) let buyBottun = UIButton() buyBottun.frame = CGRect(x: 280, y: 350, width: 70, height: 30) buyBottun.setTitle(\"결제하기\", for: .normal) buyBottun.setTitleColor(.orange, for: .normal) buyBottun.backgroundColor = .black view.addSubview(buyBottun) buyBottun.addTarget(self, action: #selector(buttonTwo(_:)), for: .touchUpInside) &#125; //초기화 @objc func buttonOne(_ sender: UIButton) &#123; self.소지금 = 70000 self.count = 0 self.sojecostLable.text = \"\\(소지금)원\" initCost() &#125; private func initCost() &#123; //짜장 짬뽕 탕수육 갯수 초기화 self.countIndex1 = 0 self.countIndex2 = 0 self.countIndex3 = 0 // 모두 더한 값도 초기화 self.countCost = 0 self.buycostLable.text = \"0\" self.jangsLable.text = \"0\" self.bongsLable.text = \"0\" self.tangsLable.text = \"0\" &#125; //결제하기 알렛 @objc func buttonTwo(_ sender: UIButton) &#123; if 소지금 &lt; countCost &#123; let alertController = UIAlertController(title: \"알림\",message: \"소지금액이 부족합니다\", preferredStyle: .alert) let alert3Action = UIAlertAction(title: \"확인\", style: .cancel) &#123; _ in &#125; alertController.addAction(alert3Action) present(alertController, animated: true) &#125; else &#123; let alertController = UIAlertController(title: \"알림\",message: \"결제금액은 모두\\(buycostLable.text!)원 입니다.\", preferredStyle: .alert) let alert1Action = UIAlertAction(title: \"취소\", style: .cancel) &#123; _ in &#125; let alert2Action = UIAlertAction(title: \"확인\", style: .destructive) &#123; _ in self.소지금 = self.소지금 - self.countCost self.sojecostLable.text = \"\\(self.소지금)원\" self.initCost() &#125; alertController.addAction(alert1Action) alertController.addAction(alert2Action) present(alertController, animated: true) &#125; &#125; //주문1 @IBAction func oder1Button(_ sender: Any) &#123; countIndex1 += 1 jangsLable?.text = \"\\(countIndex1)\" countCost += 5000 buycostLable.text = \"\\(countCost)원\" &#125; //주문2 @IBAction func oder2button(_ sender: Any) &#123; countIndex2 += 1 bongsLable?.text = \"\\(countIndex2)\" countCost += 6000 buycostLable.text = \"\\(countCost)원\" &#125; //주문3 @IBAction func oder3button(_ sender: Any) &#123; countIndex3 += 1 tangsLable?.text = \"\\(countIndex3)\" countCost += 12000 buycostLable.text = \"\\(countCost)원\" &#125; &#125; 첫 번째 방식(기존) 대한 특징. 나는 변수(전달할 값)를 먼저 설정한다. 123456789var countIndex1: Int = 0 //수량1 var countIndex2: Int = 0 //수량2 var countIndex3: Int = 0 //수량3 var countCost: Int = 0 var 소지금 : Int = 70000 var Backup: Int = 0 //초기화 var count: Int = 0 //결제금액 이런식으로 초기값을 지정하거나 타입을 지정한다. 옵셔널일 경우도 생각해서 함수에 넣는 것보다 여기에 보통 ?을 넣는다. 모든(?) 아울렛을 다 연결한다. ㅋㅋㅋ 123456789101112131415161718@IBOutlet var MenuLable: UILabel! @IBOutlet var costLable: UILabel! @IBOutlet var aeLable: UILabel! @IBOutlet var jangLable: UILabel! @IBOutlet var jangcostLable: UILabel! @IBOutlet var jangsLable: UILabel! @IBOutlet var bongLable: UILabel! @IBOutlet var bongcostLable: UILabel! @IBOutlet var bongsLable: UILabel! @IBOutlet var tangLable: UILabel! @IBOutlet var tangcostLable: UILabel! @IBOutlet var tangsLable: UILabel! 솔직히 조금 혼란스러웠다. 스토리 보드로 짤때 레이블이나 뭐 화면에 얹는 것은 다 연결해야하는 건줄 알고 이제껏 다 연결해왔었는데… 나중에 복습하면서 굳이? 아울렛연결하지 않아도 시뮬에서 보이는 것이다… 필요한것만 연결해도 되는 거였나, (그래서 이것도 정리좀 하려고 가장 무관해보이는 아울렛을 몇개 지우고 로직도 깨끗하게하고 시뮬켜봤는데 …이상하게도 또 백지화면이여서… 당황하면서 control+z…로 다시 무마했다.) 왜 이러는지 모르겠다… 어쨌든 이후코드에는 다 연결하지 않았는데도 화면에 다 보였다… 결제금액 레이블에 들어가는 숫자들을 ‘countCost’라는 함수안에 다 넣었다. 12345678910111213141516171819202122232425262728//주문1 @IBAction func oder1Button(_ sender: Any) &#123; countIndex1 += 1 jangsLable?.text = \"\\(countIndex1)\" countCost += 5000 buycostLable.text = \"\\(countCost)원\" &#125; //주문2 @IBAction func oder2button(_ sender: Any) &#123; countIndex2 += 1 bongsLable?.text = \"\\(countIndex2)\" countCost += 6000 buycostLable.text = \"\\(countCost)원\" &#125; //주문3 @IBAction func oder3button(_ sender: Any) &#123; countIndex3 += 1 tangsLable?.text = \"\\(countIndex3)\" countCost += 12000 buycostLable.text = \"\\(countCost)원\" &#125; 버튼 함수에 일일히 수량과 가격에 대한 계산을 해놓았다. 이 결과값을 ‘countCost’라는 변수에 모두 담는 방식이다. coment… 솔직히 코드에 맞다, 틀리다를 강요할 수는 없는 부분이다. 하지만 기존의 방식에서 벗어나 좀 더 함수를 활용해볼 수 없을까? 의문이 들기는 했다… 그래서 아래의 코드로 함수를 추가해 보았다. [나의 두 번째 code.레포트] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192import UIKitclass addViewController: UIViewController &#123; struct UI &#123; static let containerHeight: CGFloat = 40 static let displayLabelWidth: CGFloat = 140 static let labelWidth: CGFloat = 80 &#125; @IBOutlet var jangCountLabel: UILabel! @IBOutlet var bongCountLabel: UILabel! @IBOutlet var tangCountLabel: UILabel! //짜장,짬뽕,탕수육 가격 let jangCost = 5000 let bongCost = 6000 let tangCost = 12000 //각 수량 변수 didset으로 담기 var jangCount: Int = 0&#123; didSet &#123; jangCountLabel.text = \"\\(jangCount)\" buyPay = calcPrice() //결제금액 = 현재 결제금액을 계산하는 메소드() &#125; &#125; var bongCount: Int = 0 &#123; didSet &#123; bongCountLabel.text = \"\\(bongCount)\" buyPay = calcPrice() &#125; &#125; var tangCount: Int = 0 &#123; didSet &#123; tangCountLabel.text = \"\\(tangCount)\" buyPay = calcPrice() &#125; &#125; //현재 결제금액을 계산하는 메소드 func calcPrice() -&gt; Int &#123; return (jangCount * jangCost) + (bongCount * bongCost) + (tangCount * tangCost) &#125; //소지금액 변수 var sojiPay: Int = 70000 &#123; didSet &#123; sojiCost.text = \"\\(sojiPay)원\" &#125; &#125; //결제금액 변수 var buyPay: Int = 0 &#123; didSet &#123; buyCost.text = \"\\(buyPay)원\" &#125; &#125; let sojiCost = UILabel() var buyCost = UILabel() override func viewDidLoad() &#123; super.viewDidLoad() //소지금 Label let sojiLabel = UILabel() sojiLabel.frame = CGRect(x: 30 , y: 330, width: UI.labelWidth, height: UI.containerHeight) sojiLabel.textAlignment = .center sojiLabel.backgroundColor = .green sojiLabel.textColor = .black sojiLabel.text = \"소지금\" view.addSubview(sojiLabel) sojiCost.frame = CGRect(x: 120 , y: 330, width: UI.labelWidth+54, height: UI.containerHeight) sojiCost.textAlignment = .right sojiCost.backgroundColor = .green sojiCost.textColor = .black sojiCost.text = \"70000원\" view.addSubview(sojiCost) //결제금액 Lable let buyLabel = UILabel() buyLabel.frame = CGRect(x: 30 , y: 370, width: UI.labelWidth, height: UI.containerHeight) buyLabel.textAlignment = .center buyLabel.backgroundColor = .orange buyLabel.textColor = .black buyLabel.text = \"결제금액\" view.addSubview(buyLabel) buyCost.frame = CGRect(x: 120, y: 370, width: UI.labelWidth+54, height: UI.containerHeight) buyCost.textAlignment = .right buyCost.backgroundColor = .orange buyCost.textColor = .black buyCost.text = \"0원\" view.addSubview(buyCost) //초기화버튼 let setupButton = UIButton() setupButton.frame = CGRect(x: 265, y: 330, width: UI.labelWidth, height: UI.containerHeight) setupButton.backgroundColor = .black setupButton.setTitleColor(.orange, for: .normal) setupButton.setTitle(\"초기화\", for: .normal) view.addSubview(setupButton) setupButton.addTarget(self, action: #selector(setupButtonClicked), for: .touchUpInside) //결제하기 버튼 let buyButton = UIButton() buyButton.frame = CGRect(x: 265, y: 370, width: UI.labelWidth, height: UI.containerHeight) buyButton.backgroundColor = .black buyButton.setTitle(\"결제하기\", for: .normal) buyButton.setTitleColor(.orange, for: .normal) view.addSubview(buyButton) buyButton.addTarget(self, action: #selector(buyButtonClicked), for: .touchUpInside) &#125; //초기화버튼 @objc func setupButtonClicked(_ sender: UIButton) &#123; jangCount = 0 bongCount = 0 tangCount = 0 buyPay = 0 sojiPay = 70000 &#125; //결제하기 버튼 @objc func buyButtonClicked(_ sender: UIButton) &#123; if sojiPay &lt;= buyPay &#123; let alertController = UIAlertController(title: \"알림\",message: \"소지금액이 부족합니다\", preferredStyle: .alert) let alert3Action = UIAlertAction(title: \"확인\", style: .cancel) &#123; _ in &#125; alertController.addAction(alert3Action) present(alertController, animated: true) &#125; else &#123; let alertController = UIAlertController(title: \"알림\",message: \"결제금액은 모두\\(buyPay)원 입니다.\", preferredStyle: .alert) let alert1Action = UIAlertAction(title: \"취소\", style: .cancel) &#123; _ in &#125; //소지금 - 결제금액 계산 let alert2Action = UIAlertAction(title: \"확인\", style: .destructive) &#123; _ in self.sojiPay = self.sojiPay - self.buyPay self.sojiCost.text! = \"\\(self.sojiPay)원\" &#125; alertController.addAction(alert1Action) alertController.addAction(alert2Action) present(alertController, animated: true) &#125; &#125; //주문 버튼 3개 @IBAction func jangOder(_ sender: Any) &#123; jangCount += 1 &#125; @IBAction func bongOder(_ sender: Any) &#123; bongCount += 1 &#125; @IBAction func tangOder(_ sender: Any) &#123; tangCount += 1 &#125; &#125; 두 번째 방식에 대한 특징 1.구조체의 활용 1234struct UI &#123; static let containerHeight: CGFloat = 40 static let displayLabelWidth: CGFloat = 140 static let labelWidth: CGFloat = 80 struct를 이용하여 frame을 짜는데에 번거로움을 줄였다. 사실 버튼 디자인이 각각 다르기보다 깔끔한 UI를 위해 통일하는 경우가 많기 때문에 반복될만한 frame값이 있다면 UI를 미리 통일시키는 것도 나쁘지 않다. 12let sojiLabel = UILabel() sojiLabel.frame = CGRect(x: 30 , y: 330, width: UI.labelWidth, height: UI.containerHeight) 이런식으로, 코드 하나하나에 frame값을 넣어줬고, 변경할때는 다같이 또 일일히 건드려야했던 것을 UI를 통해, UI.labelWidth 이나 UI.containerHeight의 값을 복사하여 불러오면 코드를 좀더 간편하게 쓸 수 있었다. 2.didset의 활용 didset은 값이 바뀔때 한번 실행해주는 역할을 한다. 그래서 값이 바뀔만한 것들은 모두 이런식으로 짜준다. 123456789101112131415161718192021//각 수량 변수 didset으로 담기 var jangCount: Int = 0&#123; didSet &#123; jangCountLabel.text = \"\\(jangCount)\" buyPay = calcPrice() //결제금액 = 현재 결제금액을 계산하는 메소드() &#125; &#125; var bongCount: Int = 0 &#123; didSet &#123; bongCountLabel.text = \"\\(bongCount)\" buyPay = calcPrice() &#125; &#125; var tangCount: Int = 0 &#123; didSet &#123; tangCountLabel.text = \"\\(tangCount)\" buyPay = calcPrice() &#125; &#125; 123456789101112131415//소지금액 변수 var sojiPay: Int = 70000 &#123; didSet &#123; sojiCost.text = \"\\(sojiPay)원\" &#125; &#125; //결제금액 변수 var buyPay: Int = 0 &#123; didSet &#123; buyCost.text = \"\\(buyPay)원\" &#125; &#125; 첫번째 방식에서는 버튼 함수에 계산금액 값을 지정하고 수량에 따라 +(더하기)가 되서 countCost에 값을 모두 넣는 방식이고), 두번째 방식은 변수에 didset으로 계산식을 놓아 그때그때 실행한다. 1.text에 대한 변수지정, 2. 결제금액과 계산값에 대한 변수호출. 참고로 buyPay = calcPrice()는 아래의 계산식은 아래와 같다. 12345//현재 결제금액을 계산하는 메소드 func calcPrice() -&gt; Int &#123; return (jangCount * jangCost) + (bongCount * bongCost) + (tangCount * tangCost) &#125; 두번째가 훨씬 친절한 느낌이 드는 것 같기도하다. 애초에 didset으로 놓으니, 예상치못하게 기능을 바꾸어야하는 순간이 올때, 첫번째처럼 했더라면 해당 함수를 찾아 긴긴 코드를 읽어야 했겠지만… 두번째는 일일히 찾지 않고 didset을 보면 확실히 알기 때문이다. 장기적으로 좋은 것 같다. 역시 공유하려면 '나만아는 코드’(여기서 벗어나야 한다…ㅜㅜ)보단 지도가 될 수 있는’객관적인 코드’가 중요하니까. viewDidLoad 간소화 사실 다루고 싶은 부분이었는데, 하지를 못했다, ~~방법은 아는데…~~아무래도 다음 포스트에서 해야할 듯하다… coment… 요즘 수업을 듣고, 공부하면서 가장 힘든 부분은 독학해왔던 기존방식을 버리고 새로운 방식을 습득해야하는 것에 있다. 강사님의 코드는 어렵고. 옆친구는 어쩐지 나와 다른방식으로 풀고 있고, 나는 어쩐지 너무 단순하게 코드를 짜는 것 같아. 스트레스가 좀 쌓인다. 이 부분에 대해서 억울한 면이 있지만, 이게 아마추어와 프로의 차이라고 말한다면 할말은 없어진다. 프로의 길을 가기위해 기존의 방식을 내려 놓아야한다면 놓아야지. 그것은 변함없는 사실일 테니까… 아래에는 강사님 코드를 붙여놓았다. 어렵지만, 코드를 보았을 때, 참 합리적이라는 생각이 들었다. 아직은 공부하는 단계니까 문법에 좀 더 익숙해지면, 나도 합리적으로 코드를 짤 수 있겠지… 강사님의 코드가 눈에 익숙해지도록 복습 또, 복습하고 더욱 노력해야겠다… 답지code.(강사님 코드) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208import UIKitfinal class ViewController: UIViewController &#123; struct UI &#123; static let containerHeight: CGFloat = 40 static let displayLabelWidth: CGFloat = 140 static let labelWidth: CGFloat = 80 &#125; // MARK: IBOutlets @IBOutlet weak var 짜장면amountLabel: UILabel! @IBOutlet weak var 짬뽕amountLabel: UILabel! @IBOutlet weak var 탕수육amountLabel: UILabel! // MARK: Properties enum MenuItem: Int &#123; case 짜장면, 짬뽕, 탕수육 &#125; var 주문수량dict: [MenuItem: Int] = [ MenuItem.짜장면: 0, MenuItem.짬뽕: 0, MenuItem.탕수육: 0 ] let menuItemCostArr = [5_000, 6_000, 12_000] let 소지금displayLabel = UILabel() var 소지금 = 70_000 &#123; didSet &#123; 소지금displayLabel.text = \"\\(소지금)원\" &#125; &#125; let 결제금액displayLabel = UILabel() var 결제금액 = 0 &#123; didSet &#123; 결제금액displayLabel.text = \"\\(결제금액)원\" &#125; &#125; // MARK: View Life Cycle override func viewDidLoad() &#123; super.viewDidLoad() setupAdditionalViews() initializeData() &#125; // MARK: Setup Views func setupAdditionalViews() &#123; setup소지금views() setup결제금액views() &#125; func setup소지금views() &#123; // 컨테이너 let 소지금containerView = UIView() 소지금containerView.frame = CGRect( x: 20, y: 350, width: view.frame.width - 40, height: UI.containerHeight ) view.addSubview(소지금containerView) // 콘텐츠 let 소지금label = UILabel() 소지금label.frame = CGRect( x: 0, y: 0, width: UI.labelWidth, height: UI.containerHeight ) 소지금label.text = \"소지금\" 소지금label.textAlignment = .center 소지금label.backgroundColor = .green 소지금label.font = UIFont.preferredFont(forTextStyle: .title3) 소지금containerView.addSubview(소지금label) 소지금displayLabel.frame = CGRect( x: 소지금label.frame.maxX + 10, y: 0, width: UI.displayLabelWidth, height: UI.containerHeight ) 소지금displayLabel.backgroundColor = .green 소지금displayLabel.textAlignment = .right 소지금displayLabel.font = UIFont.preferredFont(forTextStyle: .title3) 소지금containerView.addSubview(소지금displayLabel) let 초기화button = UIButton() 초기화button.frame = CGRect( x: 소지금displayLabel.frame.maxX + 20, y: 0, width: UI.labelWidth, height: UI.containerHeight ) 초기화button.backgroundColor = .black 초기화button.setTitle(\"초기화\", for: .normal) 초기화button.setTitleColor(.white, for: .normal) 초기화button.addTarget(self, action: #selector(initializeData), for: .touchUpInside) 소지금containerView.addSubview(초기화button) &#125; func setup결제금액views() &#123; let 소지금maxYOffset = 소지금displayLabel.superview!.frame.maxY // 컨테이너 let 결제금액containerView = UIView() 결제금액containerView.frame = CGRect( x: 20, y: 소지금maxYOffset + 10, width: view.frame.width - 40, height: UI.containerHeight ) view.addSubview(결제금액containerView) // 콘텐츠 let 결제금액label = UILabel() 결제금액label.frame = CGRect( x: 0, y: 0, width: UI.labelWidth, height: UI.containerHeight ) 결제금액label.text = \"결제금액\" 결제금액label.textAlignment = .center 결제금액label.backgroundColor = .orange 결제금액label.font = UIFont.preferredFont(forTextStyle: .title3) 결제금액containerView.addSubview(결제금액label) 결제금액displayLabel.frame = CGRect( x: 결제금액label.frame.maxX + 10, y: 0, width: UI.displayLabelWidth, height: UI.containerHeight ) 결제금액displayLabel.textAlignment = .right 결제금액displayLabel.backgroundColor = .orange 결제금액displayLabel.font = UIFont.preferredFont(forTextStyle: .title3) 결제금액containerView.addSubview(결제금액displayLabel) let 결제button = UIButton() 결제button.frame = CGRect( x: 결제금액displayLabel.frame.maxX + 20, y: 0, width: UI.labelWidth, height: UI.containerHeight ) 결제button.backgroundColor = .black 결제button.setTitle(\"결제\", for: .normal) 결제button.setTitleColor(.white, for: .normal) 결제button.addTarget(self, action: #selector(didTapPaymentButton(_:)), for: .touchUpInside) 결제금액containerView.addSubview(결제button) &#125; // MARK: - Action // 주문 @IBAction func didTapOrderButton(_ sender: UIButton) &#123; guard let item = MenuItem(rawValue: sender.tag), let amount = 주문수량dict[item] else &#123; return &#125; 결제금액 += menuItemCostArr[sender.tag] 주문수량dict[item] = amount + 1 let labels = [짜장면amountLabel, 짬뽕amountLabel, 탕수육amountLabel] labels[sender.tag]?.text = \"\\(amount + 1)\" &#125; // 결제 @objc func didTapPaymentButton(_ sender: UIButton) &#123; if 소지금 &gt;= 결제금액 &#123; showAlert( title: \"결제하기\", message: \"총 결제금액은 \\(결제금액)원입니다.\", actions: [ UIAlertAction(title: \"확인\", style: .default) &#123; _ in let temp = self.소지금 - self.결제금액 self.initializeData() self.소지금 = temp &#125;, UIAlertAction(title: \"취소\", style: .cancel) ] ) &#125; else &#123; showAlert( title: \"소지금이 부족합니다\", actions: [UIAlertAction(title: \"확인\", style: .default)] ) &#125; &#125; // Alert func showAlert(title: String, message: String? = nil, actions: [UIAlertAction]) &#123; let alertController = UIAlertController( title: title, message: message, preferredStyle: .alert ) for action in actions &#123; alertController.addAction(action) &#125; present(alertController, animated: true) &#125; // 초기화 @objc func initializeData() &#123; 소지금 = 70_000 결제금액 = 0 짜장면amountLabel.text = \"0\" 짬뽕amountLabel.text = \"0\" 탕수육amountLabel.text = \"0\" for key in 주문수량dict.keys &#123; 주문수량dict[key] = 0 &#125; &#125;&#125;","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"feedback","slug":"feedback","permalink":"https://qussk.github.io/tags/feedback/"},{"name":"개발일기","slug":"개발일기","permalink":"https://qussk.github.io/tags/%EA%B0%9C%EB%B0%9C%EC%9D%BC%EA%B8%B0/"}]},{"title":"손쉬운 단축키 모음","slug":"손쉬운-단축키-모음","date":"2020-04-30T13:16:52.000Z","updated":"2020-09-14T08:28:54.151Z","comments":false,"path":"2020/04/30/손쉬운-단축키-모음/","link":"2020/04/30/손쉬운-단축키-모음","permalink":"https://qussk.github.io/2020/04/30/%EC%86%90%EC%89%AC%EC%9A%B4-%EB%8B%A8%EC%B6%95%ED%82%A4-%EB%AA%A8%EC%9D%8C/","excerpt":"","text":"단축키 모음 General command + shift + n = 새폴더 만들기 shift + command + e = 폴더에서 iTerm2 열기 option + esc = 텍스트 말하기 shift + command + . = 히든파일 보이기 option + command + h = 작업창 이외에 숨기기 command + h : 창 뒤로 보내기 Xcode [실행 관련] command + b : 빌드업 command + s : 프로젝트 저장 command + r : 시뮬레이터 실행 [화면 관련] command + ` : 같은 프로그램 내 화면이동 command + shift + [ or ] : 탭이동 option + command + 0 : Utilities 여닫 command + 0 : Navigator 닫기 command + 1, 2, 3, 4… : Navigator 열기 shift + command + y : Debug 여닫 command + option + enter : 현재창 이중분할 option + 파일선택 : 선택파일 화면분할 command + enter : 현재창 단일창 [코드 관련] option + 좌우 방향키 : 한단어씩 이동 option + 상하 방향키 : 이동문단의 끝 command + 방향키 : 방향의 끝으로 이동 command + ] or tab: 코드 밀어내기 command + [ or shift + tab : 코드 당겨오기 control + i : 코드 자동정렬 control + command + e : 같은 이름의 변수를 한번에 수정 shift + command + o : 프로젝트 내 검색 command + e : 저장 command + g : 저장한것 찾기 command + l : 입력 line 으로 이동 command + option + 좌우 방형키 : 함수 접기 command + control + spacebar : 이모티콘 option + 프로퍼티 or 메서드 클릭 : 간단설명 command + control + 프로퍼티 or 메서드 클릭 : 선언지점으로 이동 Simulator command + k : 키보드 보이기 command + 좌우 방향키 : 화면 회전 command + 상하 방향키 : 볼륨키 option + command : 이중 터치(줌 인 아웃) command + shift + h : 홈키 command + shift + h * 2: 백그라운드 앱보기 command + s : 스크린샷","categories":[{"name":"기타","slug":"기타","permalink":"https://qussk.github.io/categories/%EA%B8%B0%ED%83%80/"}],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"https://qussk.github.io/tags/Xcode/"},{"name":"Simulator","slug":"Simulator","permalink":"https://qussk.github.io/tags/Simulator/"},{"name":"General","slug":"General","permalink":"https://qussk.github.io/tags/General/"}]},{"title":"[Xcode] Xcode테마 다운로드와 적용하기","slug":"Xcode-Xcode테마-다운로드와-적용하기","date":"2020-04-30T12:28:48.000Z","updated":"2020-09-14T08:28:54.146Z","comments":false,"path":"2020/04/30/Xcode-Xcode테마-다운로드와-적용하기/","link":"2020/04/30/Xcode-Xcode테마-다운로드와-적용하기","permalink":"https://qussk.github.io/2020/04/30/Xcode-Xcode%ED%85%8C%EB%A7%88-%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C%EC%99%80-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/","excerpt":"","text":"Xcode테마 다운로드와 적용하기 Xcode에서 cm + , 단축키를 이용하면 아래의 설정창을 확인할 수 있다. Xcode에서 'font &amp; Color’에 대한 다양한 에디터 테마를 지원하지만, 좀더 확장된 디자인을 원할 땐 git에서 다운받아 사용하자 ! [사용하기] GitHub 테마(Theme) 다운로드 및 설치 사이트가기 : https://github.com/hdoria/xcode-themes 50여종의 테마를 확인한다. 터미널에 아래의 코드를 순서대로 입력 1git clone https:&#x2F;&#x2F;github.com&#x2F;hdoria&#x2F;xcode-themes.git 1cd xcode-themes 1.&#x2F;install.sh 입력을 모두 마쳤다면, Xcode를 완전 종료했다가 다시 실행한다. (50가지 이상의 테마가 설치된 것을 확인할 수 있다.) cm + , 로 테마가 받아졌는지 확인하고 선택하여 적용한다. :full_moon_with_face:","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"Xcode","slug":"Xcode","permalink":"https://qussk.github.io/tags/Xcode/"}]},{"title":"[Xcode]Simulator에서 Keyboard가 안보일 때","slug":"Xcode-Simulator에서-Keyboard가-안보일-때","date":"2020-04-29T21:28:59.000Z","updated":"2020-09-14T08:28:54.145Z","comments":false,"path":"2020/04/30/Xcode-Simulator에서-Keyboard가-안보일-때/","link":"2020/04/29/Xcode-Simulator에서-Keyboard가-안보일-때","permalink":"https://qussk.github.io/2020/04/30/Xcode-Simulator%EC%97%90%EC%84%9C-Keyboard%EA%B0%80-%EC%95%88%EB%B3%B4%EC%9D%BC-%EB%95%8C/","excerpt":"","text":"Simulator에서 Keyboard가 안보일 때… 최근에 Xcode 이전 버전을 설치했는데… 갑자기 Simulator에 키보드가 안나와서 당황하고 한참 해맸다… 시뮬레이터에서 설정해야하는데 Xcode에서 계속 키보드 검색 ㅋㅋㅋㅋ… 어쩐지안나오더라, 한 번 설정해 놓으면 또 까먹게 되서 올린다… 8ㅅ8 (Simulator - i/O - Keyborad - ConnectHardware Keyboard) 해당경로로 들어가서 ConnectHardware Keyboard를 체크해제 해주면 된다. 이번에 알게된 건데, 그냥 단축키로 열었다 닫았다 해도된다. Cm + K , Cm +sif + K 이렇게… Xcode는 정말 자주 업데이트되는 것 같다… ㅎ ㅏ","categories":[{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"}],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"https://qussk.github.io/tags/Xcode/"},{"name":"Keyborad","slug":"Keyborad","permalink":"https://qussk.github.io/tags/Keyborad/"},{"name":"Simulator","slug":"Simulator","permalink":"https://qussk.github.io/tags/Simulator/"}]},{"title":"[라이브러리]IQkeyboardManager - 키보드에 닫기(Done)버튼 생성하기","slug":"라이브러리-IQkeyboardManager-키보드에-닫기-Done-버튼-생성하기","date":"2020-04-29T20:59:30.000Z","updated":"2020-09-14T08:28:54.148Z","comments":false,"path":"2020/04/30/라이브러리-IQkeyboardManager-키보드에-닫기-Done-버튼-생성하기/","link":"2020/04/29/라이브러리-IQkeyboardManager-키보드에-닫기-Done-버튼-생성하기","permalink":"https://qussk.github.io/2020/04/30/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-IQkeyboardManager-%ED%82%A4%EB%B3%B4%EB%93%9C%EC%97%90-%EB%8B%AB%EA%B8%B0-Done-%EB%B2%84%ED%8A%BC-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0/","excerpt":"","text":"IQkeyboardManager - 키보드에 닫기(Done)버튼 생성 why? IQkeyboardManager 앱에서 텍스트필드를 사용하려면 키보드에 대한 메소드를 구현해야하는데… 생각보다 초심자가 하기에는 어렵다. 리턴 누를때 닫히는 메소드, 화면을 눌러야 닫히는 메소드 등을 구현해야하거나, 깊게는 TextFieldDelegate까지 가야할 수도 있는데… 그런거 필요 없고 앱 사용에 큰 무리가 없는 정도로만? 구현하고 싶다! 한다면, 사실 키보드에 ‘닫기’ 버튼 하나만 달아주면 해결되는 일이다… 아래를 참고하자 ! [사용하기] 이것을 Text Field Delegate를 사용하지 않고, 라이브러리로 간단하게 ? 해결해보고자 한다. 1. 사이트가기 https://github.com/hackiftekhar/IQKeyboardManager 해당 페이지에 가면 사용법을 알려주는 동영상도 지원되고, 설명도 친절하게 되어있어 참고하면 된다. 어려우면 이 글을 쭉 참고…! 2. cocoapods 에 설치 Installation 로 이동하여, 본인의 Swift, Xcode 버전에 맞는 것을 선택한다. Swift 5.1, 5.0, 4.2, 4.0, 3.2, 3.0 (Xcode 11) 보통 이것이라고 생각하고 아래 코드를 cocoapods Podfile에 넣는다. (이 외의 버전이라면 해당사이트에 pod으로 시작하는 다른 것을 선택!) 1pod 'IQKeyboardManagerSwift' 3. 해당 프로젝트에 적용하기 AppDelegate로 이동하여 import한다. 1import IQKeyboardManagerSwift 아래의 코드를 붙여넣는다. 12IQKeyboardManager.shared.enable = true return true 어딘지 모르겠으면 3.풀화면 참조 ‘ㅅ’ 풀화면 123456789101112131415161718import UIKitimport IQKeyboardManagerSwift@UIApplicationMainclass AppDelegate: UIResponder, UIApplicationDelegate &#123;​ func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123; // Override point for customization after application launch.//아래 코드를 이곳에 붙여넣으면 된다. IQKeyboardManager.shared.enable = true return true &#125; [완료하기] Keyborad 오른쪽 상단에 Done버튼이 생성된 모습 참 쉽다! @_@","categories":[{"name":"Library","slug":"Library","permalink":"https://qussk.github.io/categories/Library/"}],"tags":[{"name":"Keyborad","slug":"Keyborad","permalink":"https://qussk.github.io/tags/Keyborad/"},{"name":"라이브러리","slug":"라이브러리","permalink":"https://qussk.github.io/tags/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/"},{"name":"IQkeyboardManager","slug":"IQkeyboardManager","permalink":"https://qussk.github.io/tags/IQkeyboardManager/"}]},{"title":"MarkDown문법정리","slug":"MarkDown문법정리","date":"2020-04-29T20:47:38.000Z","updated":"2020-09-14T08:28:54.111Z","comments":false,"path":"2020/04/30/MarkDown문법정리/","link":"2020/04/29/MarkDown문법정리","permalink":"https://qussk.github.io/2020/04/30/MarkDown%EB%AC%B8%EB%B2%95%EC%A0%95%EB%A6%AC/","excerpt":"","text":"MarkDown 문법정리 제목스타일 헤딩1 헤딩2 헤딩3 헤딩4 1234# 헤딩1## 헤딩2### 헤딩3#### 헤딩4 항목(List)만들기 항목으로만 입력. Item 1 Item 2 Item 2a Item 2b 123456* Item 1 * Item 2 * Item 2a * Item 2b (&quot;*&quot;로 구분하면 됨. *안에 *를 추가하면 하위 항목으로 새로 추가됨) 순차적으로 정렬 Item 1 Item 2 Item 3 Item 3a Item 3b 12345671. Item 1 1. Item 2 1. Item 3 1. Item 3a 1. Item 3b (&#39;1&#39;숫자 붙히면 순차적으로 정렬됨. 위와 동일하게 1.안에 1.추가하면 하위 항목으로 추가됨.) 문장입력 문장 입력시 공백을주지 않으면, 앞문장과 뒷문장이 서로 붙음. 이에 스페이스바를 두 번 이상 누를 경우 위 문장과 분리되어 다음줄에 입력됨 &lt;br&gt; 도 동일하게 이용가능 취소선 취소선 이미지 등록(Image) 첫번째 1![이미지 이름]+(url링크) 두번째 1![text](image태그 url붙여넣기) 하이퍼링크(Links) GitHub 코드 블록(Code Blocks) 123function test() &#123; console.log(\"hello world!\"); &#125; 1234javascript function test() &#123; console.log(&quot;hello world!&quot;); &#125; 인용 상자(Blockquotes) As Grace Hopper said: I’ve always been more interested. in the future than in the past. 1234As Grace Hopper said: &gt; I’ve always been more interested. &gt; in the future than in the past. 강조 (Emphasis) 이탤릭체 This text will be italic This will also be italic 12*This text will be italic* _This will also be italic_ 굵게 This text will be bold This will also be bold 12**This text will be bold** __This will also be bold__ 부분 강조 You can combine them 1*You **can** combine them* 테이블 TABLES First Header Second Header Content cell 1 Content cell 2 Content column 1 Content column 2 1234First Header | Second Header ------------ | ------------- Content cell 1 | Content cell 2 Content column 1 | Content column 2 체크 박스(Task Lists) this is a complete item this is an incomplete item @mentions, #refs, links, formatting, and tags supported list syntax required (any unordered or ordered list supported) 1234- [x] this is a complete item - [ ] this is an incomplete item - [x] @mentions, #refs, [links](), **formatting**, and &lt;del&gt;tags&lt;&#x2F;del&gt; supported - [x] list syntax required (any unordered or ordered list supported) 인라인 코드(Inline code) 문단 중간에 Code를 넣을 수 있습니다. 예를 들어 printf(&quot;hello world!&quot;); 이런 식으로 들어갑니다. 수평선(hr) 123--- *** ___ 탈출 문자 (Backslash Escapes) ＼literal asterisks＼ literal asterisks ＼＼Text＼＼ ＼Tom＼ 1234＼*literal asterisks＼* *literal asterisks* __＼*＼*Text＼*＼*__ _＼_Tom＼__ 이모지(EMOJI) - 아이콘 emoji로 이동&gt;&gt;&gt; GitHub supports emoji! :+1: :sparkles: :camel: :tada: :rocket: :metal: :octocat: 123GitHub supports emoji! :+1: :sparkles: :camel: :tada: :rocket: :metal: :octocat: 배지(badge) 만들기 shields.io 로 접속 license 로 이동 / 본인이 직접 만들어도 됨 APM: /apm/l/:packageName.svg AUR license: /aur/license/:packageName.svg 1&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;img.shields.io&#x2F;badge&#x2F;license-mit-orange&quot;&gt;","categories":[{"name":"기타","slug":"기타","permalink":"https://qussk.github.io/categories/%EA%B8%B0%ED%83%80/"}],"tags":[{"name":"MaskDown","slug":"MaskDown","permalink":"https://qussk.github.io/tags/MaskDown/"}]},{"title":"post","slug":"post","date":"2020-04-29T20:46:42.000Z","updated":"2020-09-14T08:28:54.146Z","comments":false,"path":"2020/04/30/post/","link":"2020/04/29/post","permalink":"https://qussk.github.io/2020/04/30/post/","excerpt":"","text":"I miss my farther Sometimes I want to hit my head hard…","categories":[],"tags":[{"name":"Anything","slug":"Anything","permalink":"https://qussk.github.io/tags/Anything/"}]},{"title":"My Hexo","slug":"My-Hexo","date":"2020-04-25T21:29:15.000Z","updated":"2020-10-14T01:47:07.044Z","comments":true,"path":"2020/04/26/My-Hexo/","link":"","permalink":"https://qussk.github.io/2020/04/26/My-Hexo/","excerpt":"","text":"","categories":[],"tags":[]}],"categories":[{"name":"post","slug":"post","permalink":"https://qussk.github.io/categories/post/"},{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/categories/ios/"},{"name":"error","slug":"error","permalink":"https://qussk.github.io/categories/error/"},{"name":"Library","slug":"Library","permalink":"https://qussk.github.io/categories/Library/"},{"name":"기타","slug":"기타","permalink":"https://qussk.github.io/categories/%EA%B8%B0%ED%83%80/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://qussk.github.io/tags/Swift/"},{"name":"Codable","slug":"Codable","permalink":"https://qussk.github.io/tags/Codable/"},{"name":"Decod","slug":"Decod","permalink":"https://qussk.github.io/tags/Decod/"},{"name":"REST API","slug":"REST-API","permalink":"https://qussk.github.io/tags/REST-API/"},{"name":"throwing","slug":"throwing","permalink":"https://qussk.github.io/tags/throwing/"},{"name":"do-catch,try","slug":"do-catch-try","permalink":"https://qussk.github.io/tags/do-catch-try/"},{"name":"Result","slug":"Result","permalink":"https://qussk.github.io/tags/Result/"},{"name":"ErrorHandling","slug":"ErrorHandling","permalink":"https://qussk.github.io/tags/ErrorHandling/"},{"name":"scrollToRow","slug":"scrollToRow","permalink":"https://qussk.github.io/tags/scrollToRow/"},{"name":"JSON","slug":"JSON","permalink":"https://qussk.github.io/tags/JSON/"},{"name":"RESTAPI","slug":"RESTAPI","permalink":"https://qussk.github.io/tags/RESTAPI/"},{"name":"Alamofire","slug":"Alamofire","permalink":"https://qussk.github.io/tags/Alamofire/"},{"name":"Error","slug":"Error","permalink":"https://qussk.github.io/tags/Error/"},{"name":"UITableView","slug":"UITableView","permalink":"https://qussk.github.io/tags/UITableView/"},{"name":"UITouch","slug":"UITouch","permalink":"https://qussk.github.io/tags/UITouch/"},{"name":"UILable","slug":"UILable","permalink":"https://qussk.github.io/tags/UILable/"},{"name":"UINavigationController","slug":"UINavigationController","permalink":"https://qussk.github.io/tags/UINavigationController/"},{"name":"UIScrollView","slug":"UIScrollView","permalink":"https://qussk.github.io/tags/UIScrollView/"},{"name":"Scheme","slug":"Scheme","permalink":"https://qussk.github.io/tags/Scheme/"},{"name":"kakao","slug":"kakao","permalink":"https://qussk.github.io/tags/kakao/"},{"name":"UIPasteboard","slug":"UIPasteboard","permalink":"https://qussk.github.io/tags/UIPasteboard/"},{"name":"SwiftyJSON","slug":"SwiftyJSON","permalink":"https://qussk.github.io/tags/SwiftyJSON/"},{"name":"sharedApplication","slug":"sharedApplication","permalink":"https://qussk.github.io/tags/sharedApplication/"},{"name":"UITest","slug":"UITest","permalink":"https://qussk.github.io/tags/UITest/"},{"name":"FireBase","slug":"FireBase","permalink":"https://qussk.github.io/tags/FireBase/"},{"name":"FaceBook","slug":"FaceBook","permalink":"https://qussk.github.io/tags/FaceBook/"},{"name":"ios","slug":"ios","permalink":"https://qussk.github.io/tags/ios/"},{"name":"FierBase","slug":"FierBase","permalink":"https://qussk.github.io/tags/FierBase/"},{"name":"UITextfield","slug":"UITextfield","permalink":"https://qussk.github.io/tags/UITextfield/"},{"name":"resignFirstResponder()","slug":"resignFirstResponder","permalink":"https://qussk.github.io/tags/resignFirstResponder/"},{"name":"Contacts","slug":"Contacts","permalink":"https://qussk.github.io/tags/Contacts/"},{"name":"Tabbar","slug":"Tabbar","permalink":"https://qussk.github.io/tags/Tabbar/"},{"name":"공부","slug":"공부","permalink":"https://qussk.github.io/tags/%EA%B3%B5%EB%B6%80/"},{"name":"SFSymbols","slug":"SFSymbols","permalink":"https://qussk.github.io/tags/SFSymbols/"},{"name":"GoogleLogin","slug":"GoogleLogin","permalink":"https://qussk.github.io/tags/GoogleLogin/"},{"name":"paper-onboarding","slug":"paper-onboarding","permalink":"https://qussk.github.io/tags/paper-onboarding/"},{"name":"UIView","slug":"UIView","permalink":"https://qussk.github.io/tags/UIView/"},{"name":"CustomUI","slug":"CustomUI","permalink":"https://qussk.github.io/tags/CustomUI/"},{"name":"UIPageView","slug":"UIPageView","permalink":"https://qussk.github.io/tags/UIPageView/"},{"name":"NavigationBar","slug":"NavigationBar","permalink":"https://qussk.github.io/tags/NavigationBar/"},{"name":"Kingfisher","slug":"Kingfisher","permalink":"https://qussk.github.io/tags/Kingfisher/"},{"name":"gif","slug":"gif","permalink":"https://qussk.github.io/tags/gif/"},{"name":"Textfield","slug":"Textfield","permalink":"https://qussk.github.io/tags/Textfield/"},{"name":"UIKeyboardType","slug":"UIKeyboardType","permalink":"https://qussk.github.io/tags/UIKeyboardType/"},{"name":"UIFont","slug":"UIFont","permalink":"https://qussk.github.io/tags/UIFont/"},{"name":"SeachBar","slug":"SeachBar","permalink":"https://qussk.github.io/tags/SeachBar/"},{"name":"Bundle","slug":"Bundle","permalink":"https://qussk.github.io/tags/Bundle/"},{"name":"Path","slug":"Path","permalink":"https://qussk.github.io/tags/Path/"},{"name":"Shadow","slug":"Shadow","permalink":"https://qussk.github.io/tags/Shadow/"},{"name":"라이브러리","slug":"라이브러리","permalink":"https://qussk.github.io/tags/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/"},{"name":"SnapKit","slug":"SnapKit","permalink":"https://qussk.github.io/tags/SnapKit/"},{"name":"Text","slug":"Text","permalink":"https://qussk.github.io/tags/Text/"},{"name":"제어문자","slug":"제어문자","permalink":"https://qussk.github.io/tags/%EC%A0%9C%EC%96%B4%EB%AC%B8%EC%9E%90/"},{"name":"Launch Screen","slug":"Launch-Screen","permalink":"https://qussk.github.io/tags/Launch-Screen/"},{"name":"animation","slug":"animation","permalink":"https://qussk.github.io/tags/animation/"},{"name":"CAGradientLayer","slug":"CAGradientLayer","permalink":"https://qussk.github.io/tags/CAGradientLayer/"},{"name":"layr","slug":"layr","permalink":"https://qussk.github.io/tags/layr/"},{"name":"UICollectionView","slug":"UICollectionView","permalink":"https://qussk.github.io/tags/UICollectionView/"},{"name":"CAAnimation","slug":"CAAnimation","permalink":"https://qussk.github.io/tags/CAAnimation/"},{"name":"Gesture","slug":"Gesture","permalink":"https://qussk.github.io/tags/Gesture/"},{"name":"ImageView","slug":"ImageView","permalink":"https://qussk.github.io/tags/ImageView/"},{"name":"Touch","slug":"Touch","permalink":"https://qussk.github.io/tags/Touch/"},{"name":"MapKit","slug":"MapKit","permalink":"https://qussk.github.io/tags/MapKit/"},{"name":"CollectionView","slug":"CollectionView","permalink":"https://qussk.github.io/tags/CollectionView/"},{"name":"HeaderView","slug":"HeaderView","permalink":"https://qussk.github.io/tags/HeaderView/"},{"name":"FooterView","slug":"FooterView","permalink":"https://qussk.github.io/tags/FooterView/"},{"name":"Slider","slug":"Slider","permalink":"https://qussk.github.io/tags/Slider/"},{"name":"Webkit","slug":"Webkit","permalink":"https://qussk.github.io/tags/Webkit/"},{"name":"WKWebView","slug":"WKWebView","permalink":"https://qussk.github.io/tags/WKWebView/"},{"name":"3D touch","slug":"3D-touch","permalink":"https://qussk.github.io/tags/3D-touch/"},{"name":"UIAction","slug":"UIAction","permalink":"https://qussk.github.io/tags/UIAction/"},{"name":"UIContextMenuInteraction","slug":"UIContextMenuInteraction","permalink":"https://qussk.github.io/tags/UIContextMenuInteraction/"},{"name":"Xcode","slug":"Xcode","permalink":"https://qussk.github.io/tags/Xcode/"},{"name":"No Storyboard","slug":"No-Storyboard","permalink":"https://qussk.github.io/tags/No-Storyboard/"},{"name":"ImagePicker","slug":"ImagePicker","permalink":"https://qussk.github.io/tags/ImagePicker/"},{"name":"UIImagePickerController","slug":"UIImagePickerController","permalink":"https://qussk.github.io/tags/UIImagePickerController/"},{"name":"TableView","slug":"TableView","permalink":"https://qussk.github.io/tags/TableView/"},{"name":"AutoLayout","slug":"AutoLayout","permalink":"https://qussk.github.io/tags/AutoLayout/"},{"name":"Frame","slug":"Frame","permalink":"https://qussk.github.io/tags/Frame/"},{"name":"Animate","slug":"Animate","permalink":"https://qussk.github.io/tags/Animate/"},{"name":"TextField","slug":"TextField","permalink":"https://qussk.github.io/tags/TextField/"},{"name":"TextFieldDelegate","slug":"TextFieldDelegate","permalink":"https://qussk.github.io/tags/TextFieldDelegate/"},{"name":"로그인화면","slug":"로그인화면","permalink":"https://qussk.github.io/tags/%EB%A1%9C%EA%B7%B8%EC%9D%B8%ED%99%94%EB%A9%B4/"},{"name":"Array","slug":"Array","permalink":"https://qussk.github.io/tags/Array/"},{"name":"keyboard","slug":"keyboard","permalink":"https://qussk.github.io/tags/keyboard/"},{"name":"UserDefault","slug":"UserDefault","permalink":"https://qussk.github.io/tags/UserDefault/"},{"name":"화면전환","slug":"화면전환","permalink":"https://qussk.github.io/tags/%ED%99%94%EB%A9%B4%EC%A0%84%ED%99%98/"},{"name":"SideMenu","slug":"SideMenu","permalink":"https://qussk.github.io/tags/SideMenu/"},{"name":"Segue","slug":"Segue","permalink":"https://qussk.github.io/tags/Segue/"},{"name":"present","slug":"present","permalink":"https://qussk.github.io/tags/present/"},{"name":"Button","slug":"Button","permalink":"https://qussk.github.io/tags/Button/"},{"name":"개발일기","slug":"개발일기","permalink":"https://qussk.github.io/tags/%EA%B0%9C%EB%B0%9C%EC%9D%BC%EA%B8%B0/"},{"name":"Label","slug":"Label","permalink":"https://qussk.github.io/tags/Label/"},{"name":"Alert","slug":"Alert","permalink":"https://qussk.github.io/tags/Alert/"},{"name":"frame","slug":"frame","permalink":"https://qussk.github.io/tags/frame/"},{"name":"Lable","slug":"Lable","permalink":"https://qussk.github.io/tags/Lable/"},{"name":"feedback","slug":"feedback","permalink":"https://qussk.github.io/tags/feedback/"},{"name":"Simulator","slug":"Simulator","permalink":"https://qussk.github.io/tags/Simulator/"},{"name":"General","slug":"General","permalink":"https://qussk.github.io/tags/General/"},{"name":"Keyborad","slug":"Keyborad","permalink":"https://qussk.github.io/tags/Keyborad/"},{"name":"IQkeyboardManager","slug":"IQkeyboardManager","permalink":"https://qussk.github.io/tags/IQkeyboardManager/"},{"name":"MaskDown","slug":"MaskDown","permalink":"https://qussk.github.io/tags/MaskDown/"},{"name":"Anything","slug":"Anything","permalink":"https://qussk.github.io/tags/Anything/"}]}